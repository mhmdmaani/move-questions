
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Audio
 * 
 */
export type Audio = $Result.DefaultSelection<Prisma.$AudioPayload>
/**
 * Model Authorizations
 * 
 */
export type Authorizations = $Result.DefaultSelection<Prisma.$AuthorizationsPayload>
/**
 * Model Choices
 * 
 */
export type Choices = $Result.DefaultSelection<Prisma.$ChoicesPayload>
/**
 * Model ChoicesLang
 * 
 */
export type ChoicesLang = $Result.DefaultSelection<Prisma.$ChoicesLangPayload>
/**
 * Model FailedJobs
 * 
 */
export type FailedJobs = $Result.DefaultSelection<Prisma.$FailedJobsPayload>
/**
 * Model Groups
 * 
 */
export type Groups = $Result.DefaultSelection<Prisma.$GroupsPayload>
/**
 * Model GroupsLang
 * 
 */
export type GroupsLang = $Result.DefaultSelection<Prisma.$GroupsLangPayload>
/**
 * Model Languages
 * 
 */
export type Languages = $Result.DefaultSelection<Prisma.$LanguagesPayload>
/**
 * Model Licenses
 * 
 */
export type Licenses = $Result.DefaultSelection<Prisma.$LicensesPayload>
/**
 * Model LicensesLang
 * 
 */
export type LicensesLang = $Result.DefaultSelection<Prisma.$LicensesLangPayload>
/**
 * Model Media
 * 
 */
export type Media = $Result.DefaultSelection<Prisma.$MediaPayload>
/**
 * Model Migrations
 * 
 */
export type Migrations = $Result.DefaultSelection<Prisma.$MigrationsPayload>
/**
 * Model PasswordResets
 * 
 */
export type PasswordResets = $Result.DefaultSelection<Prisma.$PasswordResetsPayload>
/**
 * Model Questions
 * 
 */
export type Questions = $Result.DefaultSelection<Prisma.$QuestionsPayload>
/**
 * Model QuestionsLang
 * 
 */
export type QuestionsLang = $Result.DefaultSelection<Prisma.$QuestionsLangPayload>
/**
 * Model Quizzes
 * 
 */
export type Quizzes = $Result.DefaultSelection<Prisma.$QuizzesPayload>
/**
 * Model QuizzesLang
 * 
 */
export type QuizzesLang = $Result.DefaultSelection<Prisma.$QuizzesLangPayload>
/**
 * Model Relations
 * 
 */
export type Relations = $Result.DefaultSelection<Prisma.$RelationsPayload>
/**
 * Model RelationsChoices
 * 
 */
export type RelationsChoices = $Result.DefaultSelection<Prisma.$RelationsChoicesPayload>
/**
 * Model RelationsQuestions
 * 
 */
export type RelationsQuestions = $Result.DefaultSelection<Prisma.$RelationsQuestionsPayload>
/**
 * Model Users
 * 
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>
/**
 * Model UsersAuth
 * 
 */
export type UsersAuth = $Result.DefaultSelection<Prisma.$UsersAuthPayload>
/**
 * Model UsersGroups
 * 
 */
export type UsersGroups = $Result.DefaultSelection<Prisma.$UsersGroupsPayload>
/**
 * Model UsersLogin
 * 
 */
export type UsersLogin = $Result.DefaultSelection<Prisma.$UsersLoginPayload>
/**
 * Model UsersRelations
 * 
 */
export type UsersRelations = $Result.DefaultSelection<Prisma.$UsersRelationsPayload>
/**
 * Model UsersRelationsDetails
 * 
 */
export type UsersRelationsDetails = $Result.DefaultSelection<Prisma.$UsersRelationsDetailsPayload>
/**
 * Model Locations
 * 
 */
export type Locations = $Result.DefaultSelection<Prisma.$LocationsPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Audio
 * const audio = await prisma.audio.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Audio
   * const audio = await prisma.audio.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.audio`: Exposes CRUD operations for the **Audio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Audio
    * const audio = await prisma.audio.findMany()
    * ```
    */
  get audio(): Prisma.AudioDelegate<ExtArgs>;

  /**
   * `prisma.authorizations`: Exposes CRUD operations for the **Authorizations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Authorizations
    * const authorizations = await prisma.authorizations.findMany()
    * ```
    */
  get authorizations(): Prisma.AuthorizationsDelegate<ExtArgs>;

  /**
   * `prisma.choices`: Exposes CRUD operations for the **Choices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Choices
    * const choices = await prisma.choices.findMany()
    * ```
    */
  get choices(): Prisma.ChoicesDelegate<ExtArgs>;

  /**
   * `prisma.choicesLang`: Exposes CRUD operations for the **ChoicesLang** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChoicesLangs
    * const choicesLangs = await prisma.choicesLang.findMany()
    * ```
    */
  get choicesLang(): Prisma.ChoicesLangDelegate<ExtArgs>;

  /**
   * `prisma.failedJobs`: Exposes CRUD operations for the **FailedJobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FailedJobs
    * const failedJobs = await prisma.failedJobs.findMany()
    * ```
    */
  get failedJobs(): Prisma.FailedJobsDelegate<ExtArgs>;

  /**
   * `prisma.groups`: Exposes CRUD operations for the **Groups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.groups.findMany()
    * ```
    */
  get groups(): Prisma.GroupsDelegate<ExtArgs>;

  /**
   * `prisma.groupsLang`: Exposes CRUD operations for the **GroupsLang** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GroupsLangs
    * const groupsLangs = await prisma.groupsLang.findMany()
    * ```
    */
  get groupsLang(): Prisma.GroupsLangDelegate<ExtArgs>;

  /**
   * `prisma.languages`: Exposes CRUD operations for the **Languages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Languages
    * const languages = await prisma.languages.findMany()
    * ```
    */
  get languages(): Prisma.LanguagesDelegate<ExtArgs>;

  /**
   * `prisma.licenses`: Exposes CRUD operations for the **Licenses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Licenses
    * const licenses = await prisma.licenses.findMany()
    * ```
    */
  get licenses(): Prisma.LicensesDelegate<ExtArgs>;

  /**
   * `prisma.licensesLang`: Exposes CRUD operations for the **LicensesLang** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LicensesLangs
    * const licensesLangs = await prisma.licensesLang.findMany()
    * ```
    */
  get licensesLang(): Prisma.LicensesLangDelegate<ExtArgs>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **Media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.MediaDelegate<ExtArgs>;

  /**
   * `prisma.migrations`: Exposes CRUD operations for the **Migrations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Migrations
    * const migrations = await prisma.migrations.findMany()
    * ```
    */
  get migrations(): Prisma.MigrationsDelegate<ExtArgs>;

  /**
   * `prisma.passwordResets`: Exposes CRUD operations for the **PasswordResets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResets
    * const passwordResets = await prisma.passwordResets.findMany()
    * ```
    */
  get passwordResets(): Prisma.PasswordResetsDelegate<ExtArgs>;

  /**
   * `prisma.questions`: Exposes CRUD operations for the **Questions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.questions.findMany()
    * ```
    */
  get questions(): Prisma.QuestionsDelegate<ExtArgs>;

  /**
   * `prisma.questionsLang`: Exposes CRUD operations for the **QuestionsLang** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionsLangs
    * const questionsLangs = await prisma.questionsLang.findMany()
    * ```
    */
  get questionsLang(): Prisma.QuestionsLangDelegate<ExtArgs>;

  /**
   * `prisma.quizzes`: Exposes CRUD operations for the **Quizzes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quizzes
    * const quizzes = await prisma.quizzes.findMany()
    * ```
    */
  get quizzes(): Prisma.QuizzesDelegate<ExtArgs>;

  /**
   * `prisma.quizzesLang`: Exposes CRUD operations for the **QuizzesLang** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizzesLangs
    * const quizzesLangs = await prisma.quizzesLang.findMany()
    * ```
    */
  get quizzesLang(): Prisma.QuizzesLangDelegate<ExtArgs>;

  /**
   * `prisma.relations`: Exposes CRUD operations for the **Relations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Relations
    * const relations = await prisma.relations.findMany()
    * ```
    */
  get relations(): Prisma.RelationsDelegate<ExtArgs>;

  /**
   * `prisma.relationsChoices`: Exposes CRUD operations for the **RelationsChoices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RelationsChoices
    * const relationsChoices = await prisma.relationsChoices.findMany()
    * ```
    */
  get relationsChoices(): Prisma.RelationsChoicesDelegate<ExtArgs>;

  /**
   * `prisma.relationsQuestions`: Exposes CRUD operations for the **RelationsQuestions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RelationsQuestions
    * const relationsQuestions = await prisma.relationsQuestions.findMany()
    * ```
    */
  get relationsQuestions(): Prisma.RelationsQuestionsDelegate<ExtArgs>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<ExtArgs>;

  /**
   * `prisma.usersAuth`: Exposes CRUD operations for the **UsersAuth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsersAuths
    * const usersAuths = await prisma.usersAuth.findMany()
    * ```
    */
  get usersAuth(): Prisma.UsersAuthDelegate<ExtArgs>;

  /**
   * `prisma.usersGroups`: Exposes CRUD operations for the **UsersGroups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsersGroups
    * const usersGroups = await prisma.usersGroups.findMany()
    * ```
    */
  get usersGroups(): Prisma.UsersGroupsDelegate<ExtArgs>;

  /**
   * `prisma.usersLogin`: Exposes CRUD operations for the **UsersLogin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsersLogins
    * const usersLogins = await prisma.usersLogin.findMany()
    * ```
    */
  get usersLogin(): Prisma.UsersLoginDelegate<ExtArgs>;

  /**
   * `prisma.usersRelations`: Exposes CRUD operations for the **UsersRelations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsersRelations
    * const usersRelations = await prisma.usersRelations.findMany()
    * ```
    */
  get usersRelations(): Prisma.UsersRelationsDelegate<ExtArgs>;

  /**
   * `prisma.usersRelationsDetails`: Exposes CRUD operations for the **UsersRelationsDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsersRelationsDetails
    * const usersRelationsDetails = await prisma.usersRelationsDetails.findMany()
    * ```
    */
  get usersRelationsDetails(): Prisma.UsersRelationsDetailsDelegate<ExtArgs>;

  /**
   * `prisma.locations`: Exposes CRUD operations for the **Locations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.locations.findMany()
    * ```
    */
  get locations(): Prisma.LocationsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Audio: 'Audio',
    Authorizations: 'Authorizations',
    Choices: 'Choices',
    ChoicesLang: 'ChoicesLang',
    FailedJobs: 'FailedJobs',
    Groups: 'Groups',
    GroupsLang: 'GroupsLang',
    Languages: 'Languages',
    Licenses: 'Licenses',
    LicensesLang: 'LicensesLang',
    Media: 'Media',
    Migrations: 'Migrations',
    PasswordResets: 'PasswordResets',
    Questions: 'Questions',
    QuestionsLang: 'QuestionsLang',
    Quizzes: 'Quizzes',
    QuizzesLang: 'QuizzesLang',
    Relations: 'Relations',
    RelationsChoices: 'RelationsChoices',
    RelationsQuestions: 'RelationsQuestions',
    Users: 'Users',
    UsersAuth: 'UsersAuth',
    UsersGroups: 'UsersGroups',
    UsersLogin: 'UsersLogin',
    UsersRelations: 'UsersRelations',
    UsersRelationsDetails: 'UsersRelationsDetails',
    Locations: 'Locations'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    old_db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "audio" | "authorizations" | "choices" | "choicesLang" | "failedJobs" | "groups" | "groupsLang" | "languages" | "licenses" | "licensesLang" | "media" | "migrations" | "passwordResets" | "questions" | "questionsLang" | "quizzes" | "quizzesLang" | "relations" | "relationsChoices" | "relationsQuestions" | "users" | "usersAuth" | "usersGroups" | "usersLogin" | "usersRelations" | "usersRelationsDetails" | "locations"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Audio: {
        payload: Prisma.$AudioPayload<ExtArgs>
        fields: Prisma.AudioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AudioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AudioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioPayload>
          }
          findFirst: {
            args: Prisma.AudioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AudioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioPayload>
          }
          findMany: {
            args: Prisma.AudioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioPayload>[]
          }
          create: {
            args: Prisma.AudioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioPayload>
          }
          createMany: {
            args: Prisma.AudioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AudioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioPayload>
          }
          update: {
            args: Prisma.AudioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioPayload>
          }
          deleteMany: {
            args: Prisma.AudioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AudioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AudioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioPayload>
          }
          aggregate: {
            args: Prisma.AudioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudio>
          }
          groupBy: {
            args: Prisma.AudioGroupByArgs<ExtArgs>
            result: $Utils.Optional<AudioGroupByOutputType>[]
          }
          count: {
            args: Prisma.AudioCountArgs<ExtArgs>
            result: $Utils.Optional<AudioCountAggregateOutputType> | number
          }
        }
      }
      Authorizations: {
        payload: Prisma.$AuthorizationsPayload<ExtArgs>
        fields: Prisma.AuthorizationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthorizationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthorizationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationsPayload>
          }
          findFirst: {
            args: Prisma.AuthorizationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthorizationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationsPayload>
          }
          findMany: {
            args: Prisma.AuthorizationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationsPayload>[]
          }
          create: {
            args: Prisma.AuthorizationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationsPayload>
          }
          createMany: {
            args: Prisma.AuthorizationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AuthorizationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationsPayload>
          }
          update: {
            args: Prisma.AuthorizationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationsPayload>
          }
          deleteMany: {
            args: Prisma.AuthorizationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuthorizationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuthorizationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorizationsPayload>
          }
          aggregate: {
            args: Prisma.AuthorizationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthorizations>
          }
          groupBy: {
            args: Prisma.AuthorizationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthorizationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuthorizationsCountArgs<ExtArgs>
            result: $Utils.Optional<AuthorizationsCountAggregateOutputType> | number
          }
        }
      }
      Choices: {
        payload: Prisma.$ChoicesPayload<ExtArgs>
        fields: Prisma.ChoicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChoicesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChoicesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicesPayload>
          }
          findFirst: {
            args: Prisma.ChoicesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChoicesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicesPayload>
          }
          findMany: {
            args: Prisma.ChoicesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicesPayload>[]
          }
          create: {
            args: Prisma.ChoicesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicesPayload>
          }
          createMany: {
            args: Prisma.ChoicesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChoicesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicesPayload>
          }
          update: {
            args: Prisma.ChoicesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicesPayload>
          }
          deleteMany: {
            args: Prisma.ChoicesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChoicesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChoicesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicesPayload>
          }
          aggregate: {
            args: Prisma.ChoicesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChoices>
          }
          groupBy: {
            args: Prisma.ChoicesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChoicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChoicesCountArgs<ExtArgs>
            result: $Utils.Optional<ChoicesCountAggregateOutputType> | number
          }
        }
      }
      ChoicesLang: {
        payload: Prisma.$ChoicesLangPayload<ExtArgs>
        fields: Prisma.ChoicesLangFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChoicesLangFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicesLangPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChoicesLangFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicesLangPayload>
          }
          findFirst: {
            args: Prisma.ChoicesLangFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicesLangPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChoicesLangFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicesLangPayload>
          }
          findMany: {
            args: Prisma.ChoicesLangFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicesLangPayload>[]
          }
          create: {
            args: Prisma.ChoicesLangCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicesLangPayload>
          }
          createMany: {
            args: Prisma.ChoicesLangCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChoicesLangDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicesLangPayload>
          }
          update: {
            args: Prisma.ChoicesLangUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicesLangPayload>
          }
          deleteMany: {
            args: Prisma.ChoicesLangDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChoicesLangUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChoicesLangUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChoicesLangPayload>
          }
          aggregate: {
            args: Prisma.ChoicesLangAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChoicesLang>
          }
          groupBy: {
            args: Prisma.ChoicesLangGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChoicesLangGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChoicesLangCountArgs<ExtArgs>
            result: $Utils.Optional<ChoicesLangCountAggregateOutputType> | number
          }
        }
      }
      FailedJobs: {
        payload: Prisma.$FailedJobsPayload<ExtArgs>
        fields: Prisma.FailedJobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FailedJobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedJobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FailedJobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedJobsPayload>
          }
          findFirst: {
            args: Prisma.FailedJobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedJobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FailedJobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedJobsPayload>
          }
          findMany: {
            args: Prisma.FailedJobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedJobsPayload>[]
          }
          create: {
            args: Prisma.FailedJobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedJobsPayload>
          }
          createMany: {
            args: Prisma.FailedJobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FailedJobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedJobsPayload>
          }
          update: {
            args: Prisma.FailedJobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedJobsPayload>
          }
          deleteMany: {
            args: Prisma.FailedJobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FailedJobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FailedJobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FailedJobsPayload>
          }
          aggregate: {
            args: Prisma.FailedJobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFailedJobs>
          }
          groupBy: {
            args: Prisma.FailedJobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FailedJobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.FailedJobsCountArgs<ExtArgs>
            result: $Utils.Optional<FailedJobsCountAggregateOutputType> | number
          }
        }
      }
      Groups: {
        payload: Prisma.$GroupsPayload<ExtArgs>
        fields: Prisma.GroupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload>
          }
          findFirst: {
            args: Prisma.GroupsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload>
          }
          findMany: {
            args: Prisma.GroupsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload>[]
          }
          create: {
            args: Prisma.GroupsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload>
          }
          createMany: {
            args: Prisma.GroupsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GroupsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload>
          }
          update: {
            args: Prisma.GroupsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload>
          }
          deleteMany: {
            args: Prisma.GroupsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GroupsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsPayload>
          }
          aggregate: {
            args: Prisma.GroupsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroups>
          }
          groupBy: {
            args: Prisma.GroupsGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupsCountArgs<ExtArgs>
            result: $Utils.Optional<GroupsCountAggregateOutputType> | number
          }
        }
      }
      GroupsLang: {
        payload: Prisma.$GroupsLangPayload<ExtArgs>
        fields: Prisma.GroupsLangFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GroupsLangFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsLangPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GroupsLangFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsLangPayload>
          }
          findFirst: {
            args: Prisma.GroupsLangFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsLangPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GroupsLangFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsLangPayload>
          }
          findMany: {
            args: Prisma.GroupsLangFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsLangPayload>[]
          }
          create: {
            args: Prisma.GroupsLangCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsLangPayload>
          }
          createMany: {
            args: Prisma.GroupsLangCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GroupsLangDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsLangPayload>
          }
          update: {
            args: Prisma.GroupsLangUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsLangPayload>
          }
          deleteMany: {
            args: Prisma.GroupsLangDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GroupsLangUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GroupsLangUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GroupsLangPayload>
          }
          aggregate: {
            args: Prisma.GroupsLangAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroupsLang>
          }
          groupBy: {
            args: Prisma.GroupsLangGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupsLangGroupByOutputType>[]
          }
          count: {
            args: Prisma.GroupsLangCountArgs<ExtArgs>
            result: $Utils.Optional<GroupsLangCountAggregateOutputType> | number
          }
        }
      }
      Languages: {
        payload: Prisma.$LanguagesPayload<ExtArgs>
        fields: Prisma.LanguagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LanguagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LanguagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagesPayload>
          }
          findFirst: {
            args: Prisma.LanguagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LanguagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagesPayload>
          }
          findMany: {
            args: Prisma.LanguagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagesPayload>[]
          }
          create: {
            args: Prisma.LanguagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagesPayload>
          }
          createMany: {
            args: Prisma.LanguagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LanguagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagesPayload>
          }
          update: {
            args: Prisma.LanguagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagesPayload>
          }
          deleteMany: {
            args: Prisma.LanguagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LanguagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LanguagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanguagesPayload>
          }
          aggregate: {
            args: Prisma.LanguagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLanguages>
          }
          groupBy: {
            args: Prisma.LanguagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<LanguagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.LanguagesCountArgs<ExtArgs>
            result: $Utils.Optional<LanguagesCountAggregateOutputType> | number
          }
        }
      }
      Licenses: {
        payload: Prisma.$LicensesPayload<ExtArgs>
        fields: Prisma.LicensesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LicensesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LicensesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensesPayload>
          }
          findFirst: {
            args: Prisma.LicensesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LicensesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensesPayload>
          }
          findMany: {
            args: Prisma.LicensesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensesPayload>[]
          }
          create: {
            args: Prisma.LicensesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensesPayload>
          }
          createMany: {
            args: Prisma.LicensesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LicensesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensesPayload>
          }
          update: {
            args: Prisma.LicensesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensesPayload>
          }
          deleteMany: {
            args: Prisma.LicensesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LicensesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LicensesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensesPayload>
          }
          aggregate: {
            args: Prisma.LicensesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLicenses>
          }
          groupBy: {
            args: Prisma.LicensesGroupByArgs<ExtArgs>
            result: $Utils.Optional<LicensesGroupByOutputType>[]
          }
          count: {
            args: Prisma.LicensesCountArgs<ExtArgs>
            result: $Utils.Optional<LicensesCountAggregateOutputType> | number
          }
        }
      }
      LicensesLang: {
        payload: Prisma.$LicensesLangPayload<ExtArgs>
        fields: Prisma.LicensesLangFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LicensesLangFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensesLangPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LicensesLangFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensesLangPayload>
          }
          findFirst: {
            args: Prisma.LicensesLangFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensesLangPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LicensesLangFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensesLangPayload>
          }
          findMany: {
            args: Prisma.LicensesLangFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensesLangPayload>[]
          }
          create: {
            args: Prisma.LicensesLangCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensesLangPayload>
          }
          createMany: {
            args: Prisma.LicensesLangCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LicensesLangDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensesLangPayload>
          }
          update: {
            args: Prisma.LicensesLangUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensesLangPayload>
          }
          deleteMany: {
            args: Prisma.LicensesLangDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LicensesLangUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LicensesLangUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensesLangPayload>
          }
          aggregate: {
            args: Prisma.LicensesLangAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLicensesLang>
          }
          groupBy: {
            args: Prisma.LicensesLangGroupByArgs<ExtArgs>
            result: $Utils.Optional<LicensesLangGroupByOutputType>[]
          }
          count: {
            args: Prisma.LicensesLangCountArgs<ExtArgs>
            result: $Utils.Optional<LicensesLangCountAggregateOutputType> | number
          }
        }
      }
      Media: {
        payload: Prisma.$MediaPayload<ExtArgs>
        fields: Prisma.MediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findFirst: {
            args: Prisma.MediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findMany: {
            args: Prisma.MediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          create: {
            args: Prisma.MediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          createMany: {
            args: Prisma.MediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          update: {
            args: Prisma.MediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          deleteMany: {
            args: Prisma.MediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          aggregate: {
            args: Prisma.MediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedia>
          }
          groupBy: {
            args: Prisma.MediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaCountArgs<ExtArgs>
            result: $Utils.Optional<MediaCountAggregateOutputType> | number
          }
        }
      }
      Migrations: {
        payload: Prisma.$MigrationsPayload<ExtArgs>
        fields: Prisma.MigrationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MigrationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MigrationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MigrationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MigrationsPayload>
          }
          findFirst: {
            args: Prisma.MigrationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MigrationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MigrationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MigrationsPayload>
          }
          findMany: {
            args: Prisma.MigrationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MigrationsPayload>[]
          }
          create: {
            args: Prisma.MigrationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MigrationsPayload>
          }
          createMany: {
            args: Prisma.MigrationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MigrationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MigrationsPayload>
          }
          update: {
            args: Prisma.MigrationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MigrationsPayload>
          }
          deleteMany: {
            args: Prisma.MigrationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MigrationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MigrationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MigrationsPayload>
          }
          aggregate: {
            args: Prisma.MigrationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMigrations>
          }
          groupBy: {
            args: Prisma.MigrationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MigrationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.MigrationsCountArgs<ExtArgs>
            result: $Utils.Optional<MigrationsCountAggregateOutputType> | number
          }
        }
      }
      PasswordResets: {
        payload: Prisma.$PasswordResetsPayload<ExtArgs>
        fields: Prisma.PasswordResetsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetsPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetsPayload>
          }
          findMany: {
            args: Prisma.PasswordResetsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetsPayload>[]
          }
          create: {
            args: Prisma.PasswordResetsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetsPayload>
          }
          createMany: {
            args: Prisma.PasswordResetsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PasswordResetsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetsPayload>
          }
          update: {
            args: Prisma.PasswordResetsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetsPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PasswordResetsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetsPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResets>
          }
          groupBy: {
            args: Prisma.PasswordResetsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetsCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetsCountAggregateOutputType> | number
          }
        }
      }
      Questions: {
        payload: Prisma.$QuestionsPayload<ExtArgs>
        fields: Prisma.QuestionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload>
          }
          findFirst: {
            args: Prisma.QuestionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload>
          }
          findMany: {
            args: Prisma.QuestionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload>[]
          }
          create: {
            args: Prisma.QuestionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload>
          }
          createMany: {
            args: Prisma.QuestionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QuestionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload>
          }
          update: {
            args: Prisma.QuestionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload>
          }
          deleteMany: {
            args: Prisma.QuestionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuestionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsPayload>
          }
          aggregate: {
            args: Prisma.QuestionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestions>
          }
          groupBy: {
            args: Prisma.QuestionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionsCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionsCountAggregateOutputType> | number
          }
        }
      }
      QuestionsLang: {
        payload: Prisma.$QuestionsLangPayload<ExtArgs>
        fields: Prisma.QuestionsLangFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionsLangFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsLangPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionsLangFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsLangPayload>
          }
          findFirst: {
            args: Prisma.QuestionsLangFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsLangPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionsLangFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsLangPayload>
          }
          findMany: {
            args: Prisma.QuestionsLangFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsLangPayload>[]
          }
          create: {
            args: Prisma.QuestionsLangCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsLangPayload>
          }
          createMany: {
            args: Prisma.QuestionsLangCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QuestionsLangDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsLangPayload>
          }
          update: {
            args: Prisma.QuestionsLangUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsLangPayload>
          }
          deleteMany: {
            args: Prisma.QuestionsLangDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionsLangUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuestionsLangUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionsLangPayload>
          }
          aggregate: {
            args: Prisma.QuestionsLangAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionsLang>
          }
          groupBy: {
            args: Prisma.QuestionsLangGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionsLangGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionsLangCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionsLangCountAggregateOutputType> | number
          }
        }
      }
      Quizzes: {
        payload: Prisma.$QuizzesPayload<ExtArgs>
        fields: Prisma.QuizzesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizzesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizzesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizzesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizzesPayload>
          }
          findFirst: {
            args: Prisma.QuizzesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizzesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizzesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizzesPayload>
          }
          findMany: {
            args: Prisma.QuizzesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizzesPayload>[]
          }
          create: {
            args: Prisma.QuizzesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizzesPayload>
          }
          createMany: {
            args: Prisma.QuizzesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QuizzesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizzesPayload>
          }
          update: {
            args: Prisma.QuizzesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizzesPayload>
          }
          deleteMany: {
            args: Prisma.QuizzesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizzesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuizzesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizzesPayload>
          }
          aggregate: {
            args: Prisma.QuizzesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizzes>
          }
          groupBy: {
            args: Prisma.QuizzesGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizzesGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizzesCountArgs<ExtArgs>
            result: $Utils.Optional<QuizzesCountAggregateOutputType> | number
          }
        }
      }
      QuizzesLang: {
        payload: Prisma.$QuizzesLangPayload<ExtArgs>
        fields: Prisma.QuizzesLangFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizzesLangFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizzesLangPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizzesLangFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizzesLangPayload>
          }
          findFirst: {
            args: Prisma.QuizzesLangFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizzesLangPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizzesLangFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizzesLangPayload>
          }
          findMany: {
            args: Prisma.QuizzesLangFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizzesLangPayload>[]
          }
          create: {
            args: Prisma.QuizzesLangCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizzesLangPayload>
          }
          createMany: {
            args: Prisma.QuizzesLangCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.QuizzesLangDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizzesLangPayload>
          }
          update: {
            args: Prisma.QuizzesLangUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizzesLangPayload>
          }
          deleteMany: {
            args: Prisma.QuizzesLangDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizzesLangUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuizzesLangUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizzesLangPayload>
          }
          aggregate: {
            args: Prisma.QuizzesLangAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizzesLang>
          }
          groupBy: {
            args: Prisma.QuizzesLangGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizzesLangGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizzesLangCountArgs<ExtArgs>
            result: $Utils.Optional<QuizzesLangCountAggregateOutputType> | number
          }
        }
      }
      Relations: {
        payload: Prisma.$RelationsPayload<ExtArgs>
        fields: Prisma.RelationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsPayload>
          }
          findFirst: {
            args: Prisma.RelationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsPayload>
          }
          findMany: {
            args: Prisma.RelationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsPayload>[]
          }
          create: {
            args: Prisma.RelationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsPayload>
          }
          createMany: {
            args: Prisma.RelationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RelationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsPayload>
          }
          update: {
            args: Prisma.RelationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsPayload>
          }
          deleteMany: {
            args: Prisma.RelationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RelationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RelationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsPayload>
          }
          aggregate: {
            args: Prisma.RelationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelations>
          }
          groupBy: {
            args: Prisma.RelationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RelationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelationsCountArgs<ExtArgs>
            result: $Utils.Optional<RelationsCountAggregateOutputType> | number
          }
        }
      }
      RelationsChoices: {
        payload: Prisma.$RelationsChoicesPayload<ExtArgs>
        fields: Prisma.RelationsChoicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelationsChoicesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsChoicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelationsChoicesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsChoicesPayload>
          }
          findFirst: {
            args: Prisma.RelationsChoicesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsChoicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelationsChoicesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsChoicesPayload>
          }
          findMany: {
            args: Prisma.RelationsChoicesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsChoicesPayload>[]
          }
          create: {
            args: Prisma.RelationsChoicesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsChoicesPayload>
          }
          createMany: {
            args: Prisma.RelationsChoicesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RelationsChoicesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsChoicesPayload>
          }
          update: {
            args: Prisma.RelationsChoicesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsChoicesPayload>
          }
          deleteMany: {
            args: Prisma.RelationsChoicesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RelationsChoicesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RelationsChoicesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsChoicesPayload>
          }
          aggregate: {
            args: Prisma.RelationsChoicesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelationsChoices>
          }
          groupBy: {
            args: Prisma.RelationsChoicesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RelationsChoicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelationsChoicesCountArgs<ExtArgs>
            result: $Utils.Optional<RelationsChoicesCountAggregateOutputType> | number
          }
        }
      }
      RelationsQuestions: {
        payload: Prisma.$RelationsQuestionsPayload<ExtArgs>
        fields: Prisma.RelationsQuestionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelationsQuestionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsQuestionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelationsQuestionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsQuestionsPayload>
          }
          findFirst: {
            args: Prisma.RelationsQuestionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsQuestionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelationsQuestionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsQuestionsPayload>
          }
          findMany: {
            args: Prisma.RelationsQuestionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsQuestionsPayload>[]
          }
          create: {
            args: Prisma.RelationsQuestionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsQuestionsPayload>
          }
          createMany: {
            args: Prisma.RelationsQuestionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RelationsQuestionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsQuestionsPayload>
          }
          update: {
            args: Prisma.RelationsQuestionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsQuestionsPayload>
          }
          deleteMany: {
            args: Prisma.RelationsQuestionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RelationsQuestionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RelationsQuestionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelationsQuestionsPayload>
          }
          aggregate: {
            args: Prisma.RelationsQuestionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelationsQuestions>
          }
          groupBy: {
            args: Prisma.RelationsQuestionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RelationsQuestionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelationsQuestionsCountArgs<ExtArgs>
            result: $Utils.Optional<RelationsQuestionsCountAggregateOutputType> | number
          }
        }
      }
      Users: {
        payload: Prisma.$UsersPayload<ExtArgs>
        fields: Prisma.UsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      UsersAuth: {
        payload: Prisma.$UsersAuthPayload<ExtArgs>
        fields: Prisma.UsersAuthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersAuthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersAuthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersAuthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersAuthPayload>
          }
          findFirst: {
            args: Prisma.UsersAuthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersAuthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersAuthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersAuthPayload>
          }
          findMany: {
            args: Prisma.UsersAuthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersAuthPayload>[]
          }
          create: {
            args: Prisma.UsersAuthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersAuthPayload>
          }
          createMany: {
            args: Prisma.UsersAuthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UsersAuthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersAuthPayload>
          }
          update: {
            args: Prisma.UsersAuthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersAuthPayload>
          }
          deleteMany: {
            args: Prisma.UsersAuthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersAuthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsersAuthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersAuthPayload>
          }
          aggregate: {
            args: Prisma.UsersAuthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsersAuth>
          }
          groupBy: {
            args: Prisma.UsersAuthGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersAuthGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersAuthCountArgs<ExtArgs>
            result: $Utils.Optional<UsersAuthCountAggregateOutputType> | number
          }
        }
      }
      UsersGroups: {
        payload: Prisma.$UsersGroupsPayload<ExtArgs>
        fields: Prisma.UsersGroupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersGroupsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersGroupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersGroupsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersGroupsPayload>
          }
          findFirst: {
            args: Prisma.UsersGroupsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersGroupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersGroupsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersGroupsPayload>
          }
          findMany: {
            args: Prisma.UsersGroupsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersGroupsPayload>[]
          }
          create: {
            args: Prisma.UsersGroupsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersGroupsPayload>
          }
          createMany: {
            args: Prisma.UsersGroupsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UsersGroupsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersGroupsPayload>
          }
          update: {
            args: Prisma.UsersGroupsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersGroupsPayload>
          }
          deleteMany: {
            args: Prisma.UsersGroupsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersGroupsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsersGroupsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersGroupsPayload>
          }
          aggregate: {
            args: Prisma.UsersGroupsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsersGroups>
          }
          groupBy: {
            args: Prisma.UsersGroupsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersGroupsCountArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupsCountAggregateOutputType> | number
          }
        }
      }
      UsersLogin: {
        payload: Prisma.$UsersLoginPayload<ExtArgs>
        fields: Prisma.UsersLoginFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersLoginFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersLoginPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersLoginFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersLoginPayload>
          }
          findFirst: {
            args: Prisma.UsersLoginFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersLoginPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersLoginFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersLoginPayload>
          }
          findMany: {
            args: Prisma.UsersLoginFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersLoginPayload>[]
          }
          create: {
            args: Prisma.UsersLoginCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersLoginPayload>
          }
          createMany: {
            args: Prisma.UsersLoginCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UsersLoginDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersLoginPayload>
          }
          update: {
            args: Prisma.UsersLoginUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersLoginPayload>
          }
          deleteMany: {
            args: Prisma.UsersLoginDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersLoginUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsersLoginUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersLoginPayload>
          }
          aggregate: {
            args: Prisma.UsersLoginAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsersLogin>
          }
          groupBy: {
            args: Prisma.UsersLoginGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersLoginGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersLoginCountArgs<ExtArgs>
            result: $Utils.Optional<UsersLoginCountAggregateOutputType> | number
          }
        }
      }
      UsersRelations: {
        payload: Prisma.$UsersRelationsPayload<ExtArgs>
        fields: Prisma.UsersRelationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersRelationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersRelationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersRelationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersRelationsPayload>
          }
          findFirst: {
            args: Prisma.UsersRelationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersRelationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersRelationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersRelationsPayload>
          }
          findMany: {
            args: Prisma.UsersRelationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersRelationsPayload>[]
          }
          create: {
            args: Prisma.UsersRelationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersRelationsPayload>
          }
          createMany: {
            args: Prisma.UsersRelationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UsersRelationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersRelationsPayload>
          }
          update: {
            args: Prisma.UsersRelationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersRelationsPayload>
          }
          deleteMany: {
            args: Prisma.UsersRelationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersRelationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsersRelationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersRelationsPayload>
          }
          aggregate: {
            args: Prisma.UsersRelationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsersRelations>
          }
          groupBy: {
            args: Prisma.UsersRelationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersRelationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersRelationsCountArgs<ExtArgs>
            result: $Utils.Optional<UsersRelationsCountAggregateOutputType> | number
          }
        }
      }
      UsersRelationsDetails: {
        payload: Prisma.$UsersRelationsDetailsPayload<ExtArgs>
        fields: Prisma.UsersRelationsDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersRelationsDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersRelationsDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersRelationsDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersRelationsDetailsPayload>
          }
          findFirst: {
            args: Prisma.UsersRelationsDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersRelationsDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersRelationsDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersRelationsDetailsPayload>
          }
          findMany: {
            args: Prisma.UsersRelationsDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersRelationsDetailsPayload>[]
          }
          create: {
            args: Prisma.UsersRelationsDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersRelationsDetailsPayload>
          }
          createMany: {
            args: Prisma.UsersRelationsDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UsersRelationsDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersRelationsDetailsPayload>
          }
          update: {
            args: Prisma.UsersRelationsDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersRelationsDetailsPayload>
          }
          deleteMany: {
            args: Prisma.UsersRelationsDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersRelationsDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsersRelationsDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersRelationsDetailsPayload>
          }
          aggregate: {
            args: Prisma.UsersRelationsDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsersRelationsDetails>
          }
          groupBy: {
            args: Prisma.UsersRelationsDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersRelationsDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersRelationsDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<UsersRelationsDetailsCountAggregateOutputType> | number
          }
        }
      }
      Locations: {
        payload: Prisma.$LocationsPayload<ExtArgs>
        fields: Prisma.LocationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload>
          }
          findFirst: {
            args: Prisma.LocationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload>
          }
          findMany: {
            args: Prisma.LocationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload>[]
          }
          create: {
            args: Prisma.LocationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload>
          }
          createMany: {
            args: Prisma.LocationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LocationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload>
          }
          update: {
            args: Prisma.LocationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload>
          }
          deleteMany: {
            args: Prisma.LocationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationsPayload>
          }
          aggregate: {
            args: Prisma.LocationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocations>
          }
          groupBy: {
            args: Prisma.LocationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationsCountArgs<ExtArgs>
            result: $Utils.Optional<LocationsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AudioCountOutputType
   */

  export type AudioCountOutputType = {
    ChoicesLang: number
    GroupsLang: number
    LicensesLang: number
    QuizzesLang: number
    QuestionsLang: number
  }

  export type AudioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ChoicesLang?: boolean | AudioCountOutputTypeCountChoicesLangArgs
    GroupsLang?: boolean | AudioCountOutputTypeCountGroupsLangArgs
    LicensesLang?: boolean | AudioCountOutputTypeCountLicensesLangArgs
    QuizzesLang?: boolean | AudioCountOutputTypeCountQuizzesLangArgs
    QuestionsLang?: boolean | AudioCountOutputTypeCountQuestionsLangArgs
  }

  // Custom InputTypes
  /**
   * AudioCountOutputType without action
   */
  export type AudioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioCountOutputType
     */
    select?: AudioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AudioCountOutputType without action
   */
  export type AudioCountOutputTypeCountChoicesLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoicesLangWhereInput
  }

  /**
   * AudioCountOutputType without action
   */
  export type AudioCountOutputTypeCountGroupsLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupsLangWhereInput
  }

  /**
   * AudioCountOutputType without action
   */
  export type AudioCountOutputTypeCountLicensesLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LicensesLangWhereInput
  }

  /**
   * AudioCountOutputType without action
   */
  export type AudioCountOutputTypeCountQuizzesLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizzesLangWhereInput
  }

  /**
   * AudioCountOutputType without action
   */
  export type AudioCountOutputTypeCountQuestionsLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionsLangWhereInput
  }


  /**
   * Count Type AuthorizationsCountOutputType
   */

  export type AuthorizationsCountOutputType = {
    UsersAuth: number
  }

  export type AuthorizationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UsersAuth?: boolean | AuthorizationsCountOutputTypeCountUsersAuthArgs
  }

  // Custom InputTypes
  /**
   * AuthorizationsCountOutputType without action
   */
  export type AuthorizationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorizationsCountOutputType
     */
    select?: AuthorizationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuthorizationsCountOutputType without action
   */
  export type AuthorizationsCountOutputTypeCountUsersAuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersAuthWhereInput
  }


  /**
   * Count Type ChoicesCountOutputType
   */

  export type ChoicesCountOutputType = {
    ChoicesLang: number
    RelationsChoices: number
  }

  export type ChoicesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ChoicesLang?: boolean | ChoicesCountOutputTypeCountChoicesLangArgs
    RelationsChoices?: boolean | ChoicesCountOutputTypeCountRelationsChoicesArgs
  }

  // Custom InputTypes
  /**
   * ChoicesCountOutputType without action
   */
  export type ChoicesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoicesCountOutputType
     */
    select?: ChoicesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChoicesCountOutputType without action
   */
  export type ChoicesCountOutputTypeCountChoicesLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoicesLangWhereInput
  }

  /**
   * ChoicesCountOutputType without action
   */
  export type ChoicesCountOutputTypeCountRelationsChoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationsChoicesWhereInput
  }


  /**
   * Count Type GroupsCountOutputType
   */

  export type GroupsCountOutputType = {
    GroupsLang: number
    Relations: number
    UsersGroups: number
  }

  export type GroupsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    GroupsLang?: boolean | GroupsCountOutputTypeCountGroupsLangArgs
    Relations?: boolean | GroupsCountOutputTypeCountRelationsArgs
    UsersGroups?: boolean | GroupsCountOutputTypeCountUsersGroupsArgs
  }

  // Custom InputTypes
  /**
   * GroupsCountOutputType without action
   */
  export type GroupsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupsCountOutputType
     */
    select?: GroupsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GroupsCountOutputType without action
   */
  export type GroupsCountOutputTypeCountGroupsLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupsLangWhereInput
  }

  /**
   * GroupsCountOutputType without action
   */
  export type GroupsCountOutputTypeCountRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationsWhereInput
  }

  /**
   * GroupsCountOutputType without action
   */
  export type GroupsCountOutputTypeCountUsersGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersGroupsWhereInput
  }


  /**
   * Count Type LanguagesCountOutputType
   */

  export type LanguagesCountOutputType = {
    ChoicesLang: number
    GroupsLang: number
    LicensesLang: number
    QuestionsLang: number
    QuizzesLang: number
  }

  export type LanguagesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ChoicesLang?: boolean | LanguagesCountOutputTypeCountChoicesLangArgs
    GroupsLang?: boolean | LanguagesCountOutputTypeCountGroupsLangArgs
    LicensesLang?: boolean | LanguagesCountOutputTypeCountLicensesLangArgs
    QuestionsLang?: boolean | LanguagesCountOutputTypeCountQuestionsLangArgs
    QuizzesLang?: boolean | LanguagesCountOutputTypeCountQuizzesLangArgs
  }

  // Custom InputTypes
  /**
   * LanguagesCountOutputType without action
   */
  export type LanguagesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LanguagesCountOutputType
     */
    select?: LanguagesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LanguagesCountOutputType without action
   */
  export type LanguagesCountOutputTypeCountChoicesLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoicesLangWhereInput
  }

  /**
   * LanguagesCountOutputType without action
   */
  export type LanguagesCountOutputTypeCountGroupsLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupsLangWhereInput
  }

  /**
   * LanguagesCountOutputType without action
   */
  export type LanguagesCountOutputTypeCountLicensesLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LicensesLangWhereInput
  }

  /**
   * LanguagesCountOutputType without action
   */
  export type LanguagesCountOutputTypeCountQuestionsLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionsLangWhereInput
  }

  /**
   * LanguagesCountOutputType without action
   */
  export type LanguagesCountOutputTypeCountQuizzesLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizzesLangWhereInput
  }


  /**
   * Count Type LicensesCountOutputType
   */

  export type LicensesCountOutputType = {
    LicensesLang: number
    Relations: number
  }

  export type LicensesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    LicensesLang?: boolean | LicensesCountOutputTypeCountLicensesLangArgs
    Relations?: boolean | LicensesCountOutputTypeCountRelationsArgs
  }

  // Custom InputTypes
  /**
   * LicensesCountOutputType without action
   */
  export type LicensesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicensesCountOutputType
     */
    select?: LicensesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LicensesCountOutputType without action
   */
  export type LicensesCountOutputTypeCountLicensesLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LicensesLangWhereInput
  }

  /**
   * LicensesCountOutputType without action
   */
  export type LicensesCountOutputTypeCountRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationsWhereInput
  }


  /**
   * Count Type MediaCountOutputType
   */

  export type MediaCountOutputType = {
    Groups: number
    Licenses: number
    RelationsChoices: number
    RelationsQuestions: number
    Quizzes: number
  }

  export type MediaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Groups?: boolean | MediaCountOutputTypeCountGroupsArgs
    Licenses?: boolean | MediaCountOutputTypeCountLicensesArgs
    RelationsChoices?: boolean | MediaCountOutputTypeCountRelationsChoicesArgs
    RelationsQuestions?: boolean | MediaCountOutputTypeCountRelationsQuestionsArgs
    Quizzes?: boolean | MediaCountOutputTypeCountQuizzesArgs
  }

  // Custom InputTypes
  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaCountOutputType
     */
    select?: MediaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupsWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountLicensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LicensesWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountRelationsChoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationsChoicesWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountRelationsQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationsQuestionsWhereInput
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountQuizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizzesWhereInput
  }


  /**
   * Count Type QuestionsCountOutputType
   */

  export type QuestionsCountOutputType = {
    QuestionsLang: number
    RelationsQuestions: number
  }

  export type QuestionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    QuestionsLang?: boolean | QuestionsCountOutputTypeCountQuestionsLangArgs
    RelationsQuestions?: boolean | QuestionsCountOutputTypeCountRelationsQuestionsArgs
  }

  // Custom InputTypes
  /**
   * QuestionsCountOutputType without action
   */
  export type QuestionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsCountOutputType
     */
    select?: QuestionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionsCountOutputType without action
   */
  export type QuestionsCountOutputTypeCountQuestionsLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionsLangWhereInput
  }

  /**
   * QuestionsCountOutputType without action
   */
  export type QuestionsCountOutputTypeCountRelationsQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationsQuestionsWhereInput
  }


  /**
   * Count Type QuizzesCountOutputType
   */

  export type QuizzesCountOutputType = {
    QuizzesLang: number
    Relations: number
  }

  export type QuizzesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    QuizzesLang?: boolean | QuizzesCountOutputTypeCountQuizzesLangArgs
    Relations?: boolean | QuizzesCountOutputTypeCountRelationsArgs
  }

  // Custom InputTypes
  /**
   * QuizzesCountOutputType without action
   */
  export type QuizzesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizzesCountOutputType
     */
    select?: QuizzesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizzesCountOutputType without action
   */
  export type QuizzesCountOutputTypeCountQuizzesLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizzesLangWhereInput
  }

  /**
   * QuizzesCountOutputType without action
   */
  export type QuizzesCountOutputTypeCountRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationsWhereInput
  }


  /**
   * Count Type RelationsCountOutputType
   */

  export type RelationsCountOutputType = {
    RelationsChoices: number
    RelationsQuestions: number
    UsersRelations: number
  }

  export type RelationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RelationsChoices?: boolean | RelationsCountOutputTypeCountRelationsChoicesArgs
    RelationsQuestions?: boolean | RelationsCountOutputTypeCountRelationsQuestionsArgs
    UsersRelations?: boolean | RelationsCountOutputTypeCountUsersRelationsArgs
  }

  // Custom InputTypes
  /**
   * RelationsCountOutputType without action
   */
  export type RelationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsCountOutputType
     */
    select?: RelationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RelationsCountOutputType without action
   */
  export type RelationsCountOutputTypeCountRelationsChoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationsChoicesWhereInput
  }

  /**
   * RelationsCountOutputType without action
   */
  export type RelationsCountOutputTypeCountRelationsQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationsQuestionsWhereInput
  }

  /**
   * RelationsCountOutputType without action
   */
  export type RelationsCountOutputTypeCountUsersRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersRelationsWhereInput
  }


  /**
   * Count Type RelationsChoicesCountOutputType
   */

  export type RelationsChoicesCountOutputType = {
    UsersRelationsDetails: number
  }

  export type RelationsChoicesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UsersRelationsDetails?: boolean | RelationsChoicesCountOutputTypeCountUsersRelationsDetailsArgs
  }

  // Custom InputTypes
  /**
   * RelationsChoicesCountOutputType without action
   */
  export type RelationsChoicesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsChoicesCountOutputType
     */
    select?: RelationsChoicesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RelationsChoicesCountOutputType without action
   */
  export type RelationsChoicesCountOutputTypeCountUsersRelationsDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersRelationsDetailsWhereInput
  }


  /**
   * Count Type RelationsQuestionsCountOutputType
   */

  export type RelationsQuestionsCountOutputType = {
    RelationsChoices: number
    UsersRelationsDetails: number
  }

  export type RelationsQuestionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RelationsChoices?: boolean | RelationsQuestionsCountOutputTypeCountRelationsChoicesArgs
    UsersRelationsDetails?: boolean | RelationsQuestionsCountOutputTypeCountUsersRelationsDetailsArgs
  }

  // Custom InputTypes
  /**
   * RelationsQuestionsCountOutputType without action
   */
  export type RelationsQuestionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsQuestionsCountOutputType
     */
    select?: RelationsQuestionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RelationsQuestionsCountOutputType without action
   */
  export type RelationsQuestionsCountOutputTypeCountRelationsChoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationsChoicesWhereInput
  }

  /**
   * RelationsQuestionsCountOutputType without action
   */
  export type RelationsQuestionsCountOutputTypeCountUsersRelationsDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersRelationsDetailsWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    UsersAuth: number
    UsersGroups: number
    UsersLogin: number
    UsersRelations: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UsersAuth?: boolean | UsersCountOutputTypeCountUsersAuthArgs
    UsersGroups?: boolean | UsersCountOutputTypeCountUsersGroupsArgs
    UsersLogin?: boolean | UsersCountOutputTypeCountUsersLoginArgs
    UsersRelations?: boolean | UsersCountOutputTypeCountUsersRelationsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUsersAuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersAuthWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUsersGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersGroupsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUsersLoginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersLoginWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUsersRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersRelationsWhereInput
  }


  /**
   * Count Type UsersRelationsCountOutputType
   */

  export type UsersRelationsCountOutputType = {
    UsersRelationsDetails: number
  }

  export type UsersRelationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UsersRelationsDetails?: boolean | UsersRelationsCountOutputTypeCountUsersRelationsDetailsArgs
  }

  // Custom InputTypes
  /**
   * UsersRelationsCountOutputType without action
   */
  export type UsersRelationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersRelationsCountOutputType
     */
    select?: UsersRelationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersRelationsCountOutputType without action
   */
  export type UsersRelationsCountOutputTypeCountUsersRelationsDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersRelationsDetailsWhereInput
  }


  /**
   * Count Type LocationsCountOutputType
   */

  export type LocationsCountOutputType = {
    Users: number
  }

  export type LocationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | LocationsCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * LocationsCountOutputType without action
   */
  export type LocationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationsCountOutputType
     */
    select?: LocationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationsCountOutputType without action
   */
  export type LocationsCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Audio
   */

  export type AggregateAudio = {
    _count: AudioCountAggregateOutputType | null
    _avg: AudioAvgAggregateOutputType | null
    _sum: AudioSumAggregateOutputType | null
    _min: AudioMinAggregateOutputType | null
    _max: AudioMaxAggregateOutputType | null
  }

  export type AudioAvgAggregateOutputType = {
    id: number | null
  }

  export type AudioSumAggregateOutputType = {
    id: bigint | null
  }

  export type AudioMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    url: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AudioMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    url: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AudioCountAggregateOutputType = {
    id: number
    name: number
    url: number
    enabled: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type AudioAvgAggregateInputType = {
    id?: true
  }

  export type AudioSumAggregateInputType = {
    id?: true
  }

  export type AudioMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AudioMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AudioCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type AudioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Audio to aggregate.
     */
    where?: AudioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audio to fetch.
     */
    orderBy?: AudioOrderByWithRelationInput | AudioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AudioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audio from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audio.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Audio
    **/
    _count?: true | AudioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AudioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AudioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AudioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AudioMaxAggregateInputType
  }

  export type GetAudioAggregateType<T extends AudioAggregateArgs> = {
        [P in keyof T & keyof AggregateAudio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudio[P]>
      : GetScalarType<T[P], AggregateAudio[P]>
  }




  export type AudioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioWhereInput
    orderBy?: AudioOrderByWithAggregationInput | AudioOrderByWithAggregationInput[]
    by: AudioScalarFieldEnum[] | AudioScalarFieldEnum
    having?: AudioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AudioCountAggregateInputType | true
    _avg?: AudioAvgAggregateInputType
    _sum?: AudioSumAggregateInputType
    _min?: AudioMinAggregateInputType
    _max?: AudioMaxAggregateInputType
  }

  export type AudioGroupByOutputType = {
    id: bigint
    name: string
    url: string
    enabled: boolean
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: AudioCountAggregateOutputType | null
    _avg: AudioAvgAggregateOutputType | null
    _sum: AudioSumAggregateOutputType | null
    _min: AudioMinAggregateOutputType | null
    _max: AudioMaxAggregateOutputType | null
  }

  type GetAudioGroupByPayload<T extends AudioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AudioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AudioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AudioGroupByOutputType[P]>
            : GetScalarType<T[P], AudioGroupByOutputType[P]>
        }
      >
    >


  export type AudioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    ChoicesLang?: boolean | Audio$ChoicesLangArgs<ExtArgs>
    GroupsLang?: boolean | Audio$GroupsLangArgs<ExtArgs>
    LicensesLang?: boolean | Audio$LicensesLangArgs<ExtArgs>
    QuizzesLang?: boolean | Audio$QuizzesLangArgs<ExtArgs>
    QuestionsLang?: boolean | Audio$QuestionsLangArgs<ExtArgs>
    _count?: boolean | AudioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audio"]>


  export type AudioSelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type AudioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ChoicesLang?: boolean | Audio$ChoicesLangArgs<ExtArgs>
    GroupsLang?: boolean | Audio$GroupsLangArgs<ExtArgs>
    LicensesLang?: boolean | Audio$LicensesLangArgs<ExtArgs>
    QuizzesLang?: boolean | Audio$QuizzesLangArgs<ExtArgs>
    QuestionsLang?: boolean | Audio$QuestionsLangArgs<ExtArgs>
    _count?: boolean | AudioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AudioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Audio"
    objects: {
      ChoicesLang: Prisma.$ChoicesLangPayload<ExtArgs>[]
      GroupsLang: Prisma.$GroupsLangPayload<ExtArgs>[]
      LicensesLang: Prisma.$LicensesLangPayload<ExtArgs>[]
      QuizzesLang: Prisma.$QuizzesLangPayload<ExtArgs>[]
      QuestionsLang: Prisma.$QuestionsLangPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      url: string
      enabled: boolean
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["audio"]>
    composites: {}
  }

  type AudioGetPayload<S extends boolean | null | undefined | AudioDefaultArgs> = $Result.GetResult<Prisma.$AudioPayload, S>

  type AudioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AudioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AudioCountAggregateInputType | true
    }

  export interface AudioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Audio'], meta: { name: 'Audio' } }
    /**
     * Find zero or one Audio that matches the filter.
     * @param {AudioFindUniqueArgs} args - Arguments to find a Audio
     * @example
     * // Get one Audio
     * const audio = await prisma.audio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AudioFindUniqueArgs>(args: SelectSubset<T, AudioFindUniqueArgs<ExtArgs>>): Prisma__AudioClient<$Result.GetResult<Prisma.$AudioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Audio that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AudioFindUniqueOrThrowArgs} args - Arguments to find a Audio
     * @example
     * // Get one Audio
     * const audio = await prisma.audio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AudioFindUniqueOrThrowArgs>(args: SelectSubset<T, AudioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AudioClient<$Result.GetResult<Prisma.$AudioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Audio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioFindFirstArgs} args - Arguments to find a Audio
     * @example
     * // Get one Audio
     * const audio = await prisma.audio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AudioFindFirstArgs>(args?: SelectSubset<T, AudioFindFirstArgs<ExtArgs>>): Prisma__AudioClient<$Result.GetResult<Prisma.$AudioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Audio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioFindFirstOrThrowArgs} args - Arguments to find a Audio
     * @example
     * // Get one Audio
     * const audio = await prisma.audio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AudioFindFirstOrThrowArgs>(args?: SelectSubset<T, AudioFindFirstOrThrowArgs<ExtArgs>>): Prisma__AudioClient<$Result.GetResult<Prisma.$AudioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Audio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Audio
     * const audio = await prisma.audio.findMany()
     * 
     * // Get first 10 Audio
     * const audio = await prisma.audio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audioWithIdOnly = await prisma.audio.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AudioFindManyArgs>(args?: SelectSubset<T, AudioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Audio.
     * @param {AudioCreateArgs} args - Arguments to create a Audio.
     * @example
     * // Create one Audio
     * const Audio = await prisma.audio.create({
     *   data: {
     *     // ... data to create a Audio
     *   }
     * })
     * 
     */
    create<T extends AudioCreateArgs>(args: SelectSubset<T, AudioCreateArgs<ExtArgs>>): Prisma__AudioClient<$Result.GetResult<Prisma.$AudioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Audio.
     * @param {AudioCreateManyArgs} args - Arguments to create many Audio.
     * @example
     * // Create many Audio
     * const audio = await prisma.audio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AudioCreateManyArgs>(args?: SelectSubset<T, AudioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Audio.
     * @param {AudioDeleteArgs} args - Arguments to delete one Audio.
     * @example
     * // Delete one Audio
     * const Audio = await prisma.audio.delete({
     *   where: {
     *     // ... filter to delete one Audio
     *   }
     * })
     * 
     */
    delete<T extends AudioDeleteArgs>(args: SelectSubset<T, AudioDeleteArgs<ExtArgs>>): Prisma__AudioClient<$Result.GetResult<Prisma.$AudioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Audio.
     * @param {AudioUpdateArgs} args - Arguments to update one Audio.
     * @example
     * // Update one Audio
     * const audio = await prisma.audio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AudioUpdateArgs>(args: SelectSubset<T, AudioUpdateArgs<ExtArgs>>): Prisma__AudioClient<$Result.GetResult<Prisma.$AudioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Audio.
     * @param {AudioDeleteManyArgs} args - Arguments to filter Audio to delete.
     * @example
     * // Delete a few Audio
     * const { count } = await prisma.audio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AudioDeleteManyArgs>(args?: SelectSubset<T, AudioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Audio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Audio
     * const audio = await prisma.audio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AudioUpdateManyArgs>(args: SelectSubset<T, AudioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Audio.
     * @param {AudioUpsertArgs} args - Arguments to update or create a Audio.
     * @example
     * // Update or create a Audio
     * const audio = await prisma.audio.upsert({
     *   create: {
     *     // ... data to create a Audio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Audio we want to update
     *   }
     * })
     */
    upsert<T extends AudioUpsertArgs>(args: SelectSubset<T, AudioUpsertArgs<ExtArgs>>): Prisma__AudioClient<$Result.GetResult<Prisma.$AudioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Audio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioCountArgs} args - Arguments to filter Audio to count.
     * @example
     * // Count the number of Audio
     * const count = await prisma.audio.count({
     *   where: {
     *     // ... the filter for the Audio we want to count
     *   }
     * })
    **/
    count<T extends AudioCountArgs>(
      args?: Subset<T, AudioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AudioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Audio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AudioAggregateArgs>(args: Subset<T, AudioAggregateArgs>): Prisma.PrismaPromise<GetAudioAggregateType<T>>

    /**
     * Group by Audio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AudioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AudioGroupByArgs['orderBy'] }
        : { orderBy?: AudioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AudioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Audio model
   */
  readonly fields: AudioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Audio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AudioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ChoicesLang<T extends Audio$ChoicesLangArgs<ExtArgs> = {}>(args?: Subset<T, Audio$ChoicesLangArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoicesLangPayload<ExtArgs>, T, "findMany"> | Null>
    GroupsLang<T extends Audio$GroupsLangArgs<ExtArgs> = {}>(args?: Subset<T, Audio$GroupsLangArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupsLangPayload<ExtArgs>, T, "findMany"> | Null>
    LicensesLang<T extends Audio$LicensesLangArgs<ExtArgs> = {}>(args?: Subset<T, Audio$LicensesLangArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicensesLangPayload<ExtArgs>, T, "findMany"> | Null>
    QuizzesLang<T extends Audio$QuizzesLangArgs<ExtArgs> = {}>(args?: Subset<T, Audio$QuizzesLangArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizzesLangPayload<ExtArgs>, T, "findMany"> | Null>
    QuestionsLang<T extends Audio$QuestionsLangArgs<ExtArgs> = {}>(args?: Subset<T, Audio$QuestionsLangArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionsLangPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Audio model
   */ 
  interface AudioFieldRefs {
    readonly id: FieldRef<"Audio", 'BigInt'>
    readonly name: FieldRef<"Audio", 'String'>
    readonly url: FieldRef<"Audio", 'String'>
    readonly enabled: FieldRef<"Audio", 'Boolean'>
    readonly createdAt: FieldRef<"Audio", 'DateTime'>
    readonly updatedAt: FieldRef<"Audio", 'DateTime'>
    readonly deletedAt: FieldRef<"Audio", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Audio findUnique
   */
  export type AudioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audio
     */
    select?: AudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioInclude<ExtArgs> | null
    /**
     * Filter, which Audio to fetch.
     */
    where: AudioWhereUniqueInput
  }

  /**
   * Audio findUniqueOrThrow
   */
  export type AudioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audio
     */
    select?: AudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioInclude<ExtArgs> | null
    /**
     * Filter, which Audio to fetch.
     */
    where: AudioWhereUniqueInput
  }

  /**
   * Audio findFirst
   */
  export type AudioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audio
     */
    select?: AudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioInclude<ExtArgs> | null
    /**
     * Filter, which Audio to fetch.
     */
    where?: AudioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audio to fetch.
     */
    orderBy?: AudioOrderByWithRelationInput | AudioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Audio.
     */
    cursor?: AudioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audio from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audio.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Audio.
     */
    distinct?: AudioScalarFieldEnum | AudioScalarFieldEnum[]
  }

  /**
   * Audio findFirstOrThrow
   */
  export type AudioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audio
     */
    select?: AudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioInclude<ExtArgs> | null
    /**
     * Filter, which Audio to fetch.
     */
    where?: AudioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audio to fetch.
     */
    orderBy?: AudioOrderByWithRelationInput | AudioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Audio.
     */
    cursor?: AudioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audio from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audio.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Audio.
     */
    distinct?: AudioScalarFieldEnum | AudioScalarFieldEnum[]
  }

  /**
   * Audio findMany
   */
  export type AudioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audio
     */
    select?: AudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioInclude<ExtArgs> | null
    /**
     * Filter, which Audio to fetch.
     */
    where?: AudioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Audio to fetch.
     */
    orderBy?: AudioOrderByWithRelationInput | AudioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Audio.
     */
    cursor?: AudioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Audio from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Audio.
     */
    skip?: number
    distinct?: AudioScalarFieldEnum | AudioScalarFieldEnum[]
  }

  /**
   * Audio create
   */
  export type AudioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audio
     */
    select?: AudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioInclude<ExtArgs> | null
    /**
     * The data needed to create a Audio.
     */
    data: XOR<AudioCreateInput, AudioUncheckedCreateInput>
  }

  /**
   * Audio createMany
   */
  export type AudioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Audio.
     */
    data: AudioCreateManyInput | AudioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Audio update
   */
  export type AudioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audio
     */
    select?: AudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioInclude<ExtArgs> | null
    /**
     * The data needed to update a Audio.
     */
    data: XOR<AudioUpdateInput, AudioUncheckedUpdateInput>
    /**
     * Choose, which Audio to update.
     */
    where: AudioWhereUniqueInput
  }

  /**
   * Audio updateMany
   */
  export type AudioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Audio.
     */
    data: XOR<AudioUpdateManyMutationInput, AudioUncheckedUpdateManyInput>
    /**
     * Filter which Audio to update
     */
    where?: AudioWhereInput
  }

  /**
   * Audio upsert
   */
  export type AudioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audio
     */
    select?: AudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioInclude<ExtArgs> | null
    /**
     * The filter to search for the Audio to update in case it exists.
     */
    where: AudioWhereUniqueInput
    /**
     * In case the Audio found by the `where` argument doesn't exist, create a new Audio with this data.
     */
    create: XOR<AudioCreateInput, AudioUncheckedCreateInput>
    /**
     * In case the Audio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AudioUpdateInput, AudioUncheckedUpdateInput>
  }

  /**
   * Audio delete
   */
  export type AudioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audio
     */
    select?: AudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioInclude<ExtArgs> | null
    /**
     * Filter which Audio to delete.
     */
    where: AudioWhereUniqueInput
  }

  /**
   * Audio deleteMany
   */
  export type AudioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Audio to delete
     */
    where?: AudioWhereInput
  }

  /**
   * Audio.ChoicesLang
   */
  export type Audio$ChoicesLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoicesLang
     */
    select?: ChoicesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoicesLangInclude<ExtArgs> | null
    where?: ChoicesLangWhereInput
    orderBy?: ChoicesLangOrderByWithRelationInput | ChoicesLangOrderByWithRelationInput[]
    cursor?: ChoicesLangWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChoicesLangScalarFieldEnum | ChoicesLangScalarFieldEnum[]
  }

  /**
   * Audio.GroupsLang
   */
  export type Audio$GroupsLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupsLang
     */
    select?: GroupsLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsLangInclude<ExtArgs> | null
    where?: GroupsLangWhereInput
    orderBy?: GroupsLangOrderByWithRelationInput | GroupsLangOrderByWithRelationInput[]
    cursor?: GroupsLangWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupsLangScalarFieldEnum | GroupsLangScalarFieldEnum[]
  }

  /**
   * Audio.LicensesLang
   */
  export type Audio$LicensesLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicensesLang
     */
    select?: LicensesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicensesLangInclude<ExtArgs> | null
    where?: LicensesLangWhereInput
    orderBy?: LicensesLangOrderByWithRelationInput | LicensesLangOrderByWithRelationInput[]
    cursor?: LicensesLangWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LicensesLangScalarFieldEnum | LicensesLangScalarFieldEnum[]
  }

  /**
   * Audio.QuizzesLang
   */
  export type Audio$QuizzesLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizzesLang
     */
    select?: QuizzesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizzesLangInclude<ExtArgs> | null
    where?: QuizzesLangWhereInput
    orderBy?: QuizzesLangOrderByWithRelationInput | QuizzesLangOrderByWithRelationInput[]
    cursor?: QuizzesLangWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizzesLangScalarFieldEnum | QuizzesLangScalarFieldEnum[]
  }

  /**
   * Audio.QuestionsLang
   */
  export type Audio$QuestionsLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsLang
     */
    select?: QuestionsLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsLangInclude<ExtArgs> | null
    where?: QuestionsLangWhereInput
    orderBy?: QuestionsLangOrderByWithRelationInput | QuestionsLangOrderByWithRelationInput[]
    cursor?: QuestionsLangWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionsLangScalarFieldEnum | QuestionsLangScalarFieldEnum[]
  }

  /**
   * Audio without action
   */
  export type AudioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audio
     */
    select?: AudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioInclude<ExtArgs> | null
  }


  /**
   * Model Authorizations
   */

  export type AggregateAuthorizations = {
    _count: AuthorizationsCountAggregateOutputType | null
    _avg: AuthorizationsAvgAggregateOutputType | null
    _sum: AuthorizationsSumAggregateOutputType | null
    _min: AuthorizationsMinAggregateOutputType | null
    _max: AuthorizationsMaxAggregateOutputType | null
  }

  export type AuthorizationsAvgAggregateOutputType = {
    id: number | null
  }

  export type AuthorizationsSumAggregateOutputType = {
    id: bigint | null
  }

  export type AuthorizationsMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuthorizationsMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuthorizationsCountAggregateOutputType = {
    id: number
    name: number
    enabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuthorizationsAvgAggregateInputType = {
    id?: true
  }

  export type AuthorizationsSumAggregateInputType = {
    id?: true
  }

  export type AuthorizationsMinAggregateInputType = {
    id?: true
    name?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuthorizationsMaxAggregateInputType = {
    id?: true
    name?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuthorizationsCountAggregateInputType = {
    id?: true
    name?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuthorizationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Authorizations to aggregate.
     */
    where?: AuthorizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authorizations to fetch.
     */
    orderBy?: AuthorizationsOrderByWithRelationInput | AuthorizationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthorizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authorizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authorizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Authorizations
    **/
    _count?: true | AuthorizationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuthorizationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuthorizationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthorizationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthorizationsMaxAggregateInputType
  }

  export type GetAuthorizationsAggregateType<T extends AuthorizationsAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthorizations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthorizations[P]>
      : GetScalarType<T[P], AggregateAuthorizations[P]>
  }




  export type AuthorizationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthorizationsWhereInput
    orderBy?: AuthorizationsOrderByWithAggregationInput | AuthorizationsOrderByWithAggregationInput[]
    by: AuthorizationsScalarFieldEnum[] | AuthorizationsScalarFieldEnum
    having?: AuthorizationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthorizationsCountAggregateInputType | true
    _avg?: AuthorizationsAvgAggregateInputType
    _sum?: AuthorizationsSumAggregateInputType
    _min?: AuthorizationsMinAggregateInputType
    _max?: AuthorizationsMaxAggregateInputType
  }

  export type AuthorizationsGroupByOutputType = {
    id: bigint
    name: string
    enabled: boolean
    createdAt: Date | null
    updatedAt: Date | null
    _count: AuthorizationsCountAggregateOutputType | null
    _avg: AuthorizationsAvgAggregateOutputType | null
    _sum: AuthorizationsSumAggregateOutputType | null
    _min: AuthorizationsMinAggregateOutputType | null
    _max: AuthorizationsMaxAggregateOutputType | null
  }

  type GetAuthorizationsGroupByPayload<T extends AuthorizationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthorizationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthorizationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthorizationsGroupByOutputType[P]>
            : GetScalarType<T[P], AuthorizationsGroupByOutputType[P]>
        }
      >
    >


  export type AuthorizationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    UsersAuth?: boolean | Authorizations$UsersAuthArgs<ExtArgs>
    _count?: boolean | AuthorizationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authorizations"]>


  export type AuthorizationsSelectScalar = {
    id?: boolean
    name?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuthorizationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UsersAuth?: boolean | Authorizations$UsersAuthArgs<ExtArgs>
    _count?: boolean | AuthorizationsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AuthorizationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Authorizations"
    objects: {
      UsersAuth: Prisma.$UsersAuthPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      enabled: boolean
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["authorizations"]>
    composites: {}
  }

  type AuthorizationsGetPayload<S extends boolean | null | undefined | AuthorizationsDefaultArgs> = $Result.GetResult<Prisma.$AuthorizationsPayload, S>

  type AuthorizationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuthorizationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuthorizationsCountAggregateInputType | true
    }

  export interface AuthorizationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Authorizations'], meta: { name: 'Authorizations' } }
    /**
     * Find zero or one Authorizations that matches the filter.
     * @param {AuthorizationsFindUniqueArgs} args - Arguments to find a Authorizations
     * @example
     * // Get one Authorizations
     * const authorizations = await prisma.authorizations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuthorizationsFindUniqueArgs>(args: SelectSubset<T, AuthorizationsFindUniqueArgs<ExtArgs>>): Prisma__AuthorizationsClient<$Result.GetResult<Prisma.$AuthorizationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Authorizations that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuthorizationsFindUniqueOrThrowArgs} args - Arguments to find a Authorizations
     * @example
     * // Get one Authorizations
     * const authorizations = await prisma.authorizations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuthorizationsFindUniqueOrThrowArgs>(args: SelectSubset<T, AuthorizationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuthorizationsClient<$Result.GetResult<Prisma.$AuthorizationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Authorizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorizationsFindFirstArgs} args - Arguments to find a Authorizations
     * @example
     * // Get one Authorizations
     * const authorizations = await prisma.authorizations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuthorizationsFindFirstArgs>(args?: SelectSubset<T, AuthorizationsFindFirstArgs<ExtArgs>>): Prisma__AuthorizationsClient<$Result.GetResult<Prisma.$AuthorizationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Authorizations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorizationsFindFirstOrThrowArgs} args - Arguments to find a Authorizations
     * @example
     * // Get one Authorizations
     * const authorizations = await prisma.authorizations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuthorizationsFindFirstOrThrowArgs>(args?: SelectSubset<T, AuthorizationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuthorizationsClient<$Result.GetResult<Prisma.$AuthorizationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Authorizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorizationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Authorizations
     * const authorizations = await prisma.authorizations.findMany()
     * 
     * // Get first 10 Authorizations
     * const authorizations = await prisma.authorizations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authorizationsWithIdOnly = await prisma.authorizations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuthorizationsFindManyArgs>(args?: SelectSubset<T, AuthorizationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorizationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Authorizations.
     * @param {AuthorizationsCreateArgs} args - Arguments to create a Authorizations.
     * @example
     * // Create one Authorizations
     * const Authorizations = await prisma.authorizations.create({
     *   data: {
     *     // ... data to create a Authorizations
     *   }
     * })
     * 
     */
    create<T extends AuthorizationsCreateArgs>(args: SelectSubset<T, AuthorizationsCreateArgs<ExtArgs>>): Prisma__AuthorizationsClient<$Result.GetResult<Prisma.$AuthorizationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Authorizations.
     * @param {AuthorizationsCreateManyArgs} args - Arguments to create many Authorizations.
     * @example
     * // Create many Authorizations
     * const authorizations = await prisma.authorizations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuthorizationsCreateManyArgs>(args?: SelectSubset<T, AuthorizationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Authorizations.
     * @param {AuthorizationsDeleteArgs} args - Arguments to delete one Authorizations.
     * @example
     * // Delete one Authorizations
     * const Authorizations = await prisma.authorizations.delete({
     *   where: {
     *     // ... filter to delete one Authorizations
     *   }
     * })
     * 
     */
    delete<T extends AuthorizationsDeleteArgs>(args: SelectSubset<T, AuthorizationsDeleteArgs<ExtArgs>>): Prisma__AuthorizationsClient<$Result.GetResult<Prisma.$AuthorizationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Authorizations.
     * @param {AuthorizationsUpdateArgs} args - Arguments to update one Authorizations.
     * @example
     * // Update one Authorizations
     * const authorizations = await prisma.authorizations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuthorizationsUpdateArgs>(args: SelectSubset<T, AuthorizationsUpdateArgs<ExtArgs>>): Prisma__AuthorizationsClient<$Result.GetResult<Prisma.$AuthorizationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Authorizations.
     * @param {AuthorizationsDeleteManyArgs} args - Arguments to filter Authorizations to delete.
     * @example
     * // Delete a few Authorizations
     * const { count } = await prisma.authorizations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuthorizationsDeleteManyArgs>(args?: SelectSubset<T, AuthorizationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authorizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorizationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Authorizations
     * const authorizations = await prisma.authorizations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuthorizationsUpdateManyArgs>(args: SelectSubset<T, AuthorizationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Authorizations.
     * @param {AuthorizationsUpsertArgs} args - Arguments to update or create a Authorizations.
     * @example
     * // Update or create a Authorizations
     * const authorizations = await prisma.authorizations.upsert({
     *   create: {
     *     // ... data to create a Authorizations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Authorizations we want to update
     *   }
     * })
     */
    upsert<T extends AuthorizationsUpsertArgs>(args: SelectSubset<T, AuthorizationsUpsertArgs<ExtArgs>>): Prisma__AuthorizationsClient<$Result.GetResult<Prisma.$AuthorizationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Authorizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorizationsCountArgs} args - Arguments to filter Authorizations to count.
     * @example
     * // Count the number of Authorizations
     * const count = await prisma.authorizations.count({
     *   where: {
     *     // ... the filter for the Authorizations we want to count
     *   }
     * })
    **/
    count<T extends AuthorizationsCountArgs>(
      args?: Subset<T, AuthorizationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthorizationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Authorizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorizationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthorizationsAggregateArgs>(args: Subset<T, AuthorizationsAggregateArgs>): Prisma.PrismaPromise<GetAuthorizationsAggregateType<T>>

    /**
     * Group by Authorizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorizationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthorizationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthorizationsGroupByArgs['orderBy'] }
        : { orderBy?: AuthorizationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthorizationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthorizationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Authorizations model
   */
  readonly fields: AuthorizationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Authorizations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthorizationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    UsersAuth<T extends Authorizations$UsersAuthArgs<ExtArgs> = {}>(args?: Subset<T, Authorizations$UsersAuthArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersAuthPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Authorizations model
   */ 
  interface AuthorizationsFieldRefs {
    readonly id: FieldRef<"Authorizations", 'BigInt'>
    readonly name: FieldRef<"Authorizations", 'String'>
    readonly enabled: FieldRef<"Authorizations", 'Boolean'>
    readonly createdAt: FieldRef<"Authorizations", 'DateTime'>
    readonly updatedAt: FieldRef<"Authorizations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Authorizations findUnique
   */
  export type AuthorizationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authorizations
     */
    select?: AuthorizationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationsInclude<ExtArgs> | null
    /**
     * Filter, which Authorizations to fetch.
     */
    where: AuthorizationsWhereUniqueInput
  }

  /**
   * Authorizations findUniqueOrThrow
   */
  export type AuthorizationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authorizations
     */
    select?: AuthorizationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationsInclude<ExtArgs> | null
    /**
     * Filter, which Authorizations to fetch.
     */
    where: AuthorizationsWhereUniqueInput
  }

  /**
   * Authorizations findFirst
   */
  export type AuthorizationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authorizations
     */
    select?: AuthorizationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationsInclude<ExtArgs> | null
    /**
     * Filter, which Authorizations to fetch.
     */
    where?: AuthorizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authorizations to fetch.
     */
    orderBy?: AuthorizationsOrderByWithRelationInput | AuthorizationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authorizations.
     */
    cursor?: AuthorizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authorizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authorizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authorizations.
     */
    distinct?: AuthorizationsScalarFieldEnum | AuthorizationsScalarFieldEnum[]
  }

  /**
   * Authorizations findFirstOrThrow
   */
  export type AuthorizationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authorizations
     */
    select?: AuthorizationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationsInclude<ExtArgs> | null
    /**
     * Filter, which Authorizations to fetch.
     */
    where?: AuthorizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authorizations to fetch.
     */
    orderBy?: AuthorizationsOrderByWithRelationInput | AuthorizationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authorizations.
     */
    cursor?: AuthorizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authorizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authorizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authorizations.
     */
    distinct?: AuthorizationsScalarFieldEnum | AuthorizationsScalarFieldEnum[]
  }

  /**
   * Authorizations findMany
   */
  export type AuthorizationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authorizations
     */
    select?: AuthorizationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationsInclude<ExtArgs> | null
    /**
     * Filter, which Authorizations to fetch.
     */
    where?: AuthorizationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authorizations to fetch.
     */
    orderBy?: AuthorizationsOrderByWithRelationInput | AuthorizationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Authorizations.
     */
    cursor?: AuthorizationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authorizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authorizations.
     */
    skip?: number
    distinct?: AuthorizationsScalarFieldEnum | AuthorizationsScalarFieldEnum[]
  }

  /**
   * Authorizations create
   */
  export type AuthorizationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authorizations
     */
    select?: AuthorizationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationsInclude<ExtArgs> | null
    /**
     * The data needed to create a Authorizations.
     */
    data: XOR<AuthorizationsCreateInput, AuthorizationsUncheckedCreateInput>
  }

  /**
   * Authorizations createMany
   */
  export type AuthorizationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Authorizations.
     */
    data: AuthorizationsCreateManyInput | AuthorizationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Authorizations update
   */
  export type AuthorizationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authorizations
     */
    select?: AuthorizationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationsInclude<ExtArgs> | null
    /**
     * The data needed to update a Authorizations.
     */
    data: XOR<AuthorizationsUpdateInput, AuthorizationsUncheckedUpdateInput>
    /**
     * Choose, which Authorizations to update.
     */
    where: AuthorizationsWhereUniqueInput
  }

  /**
   * Authorizations updateMany
   */
  export type AuthorizationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Authorizations.
     */
    data: XOR<AuthorizationsUpdateManyMutationInput, AuthorizationsUncheckedUpdateManyInput>
    /**
     * Filter which Authorizations to update
     */
    where?: AuthorizationsWhereInput
  }

  /**
   * Authorizations upsert
   */
  export type AuthorizationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authorizations
     */
    select?: AuthorizationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationsInclude<ExtArgs> | null
    /**
     * The filter to search for the Authorizations to update in case it exists.
     */
    where: AuthorizationsWhereUniqueInput
    /**
     * In case the Authorizations found by the `where` argument doesn't exist, create a new Authorizations with this data.
     */
    create: XOR<AuthorizationsCreateInput, AuthorizationsUncheckedCreateInput>
    /**
     * In case the Authorizations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthorizationsUpdateInput, AuthorizationsUncheckedUpdateInput>
  }

  /**
   * Authorizations delete
   */
  export type AuthorizationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authorizations
     */
    select?: AuthorizationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationsInclude<ExtArgs> | null
    /**
     * Filter which Authorizations to delete.
     */
    where: AuthorizationsWhereUniqueInput
  }

  /**
   * Authorizations deleteMany
   */
  export type AuthorizationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Authorizations to delete
     */
    where?: AuthorizationsWhereInput
  }

  /**
   * Authorizations.UsersAuth
   */
  export type Authorizations$UsersAuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersAuth
     */
    select?: UsersAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersAuthInclude<ExtArgs> | null
    where?: UsersAuthWhereInput
    orderBy?: UsersAuthOrderByWithRelationInput | UsersAuthOrderByWithRelationInput[]
    cursor?: UsersAuthWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersAuthScalarFieldEnum | UsersAuthScalarFieldEnum[]
  }

  /**
   * Authorizations without action
   */
  export type AuthorizationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Authorizations
     */
    select?: AuthorizationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorizationsInclude<ExtArgs> | null
  }


  /**
   * Model Choices
   */

  export type AggregateChoices = {
    _count: ChoicesCountAggregateOutputType | null
    _avg: ChoicesAvgAggregateOutputType | null
    _sum: ChoicesSumAggregateOutputType | null
    _min: ChoicesMinAggregateOutputType | null
    _max: ChoicesMaxAggregateOutputType | null
  }

  export type ChoicesAvgAggregateOutputType = {
    id: number | null
  }

  export type ChoicesSumAggregateOutputType = {
    id: bigint | null
  }

  export type ChoicesMinAggregateOutputType = {
    id: bigint | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ChoicesMaxAggregateOutputType = {
    id: bigint | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ChoicesCountAggregateOutputType = {
    id: number
    enabled: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ChoicesAvgAggregateInputType = {
    id?: true
  }

  export type ChoicesSumAggregateInputType = {
    id?: true
  }

  export type ChoicesMinAggregateInputType = {
    id?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ChoicesMaxAggregateInputType = {
    id?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ChoicesCountAggregateInputType = {
    id?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ChoicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Choices to aggregate.
     */
    where?: ChoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Choices to fetch.
     */
    orderBy?: ChoicesOrderByWithRelationInput | ChoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Choices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Choices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Choices
    **/
    _count?: true | ChoicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChoicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChoicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChoicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChoicesMaxAggregateInputType
  }

  export type GetChoicesAggregateType<T extends ChoicesAggregateArgs> = {
        [P in keyof T & keyof AggregateChoices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChoices[P]>
      : GetScalarType<T[P], AggregateChoices[P]>
  }




  export type ChoicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoicesWhereInput
    orderBy?: ChoicesOrderByWithAggregationInput | ChoicesOrderByWithAggregationInput[]
    by: ChoicesScalarFieldEnum[] | ChoicesScalarFieldEnum
    having?: ChoicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChoicesCountAggregateInputType | true
    _avg?: ChoicesAvgAggregateInputType
    _sum?: ChoicesSumAggregateInputType
    _min?: ChoicesMinAggregateInputType
    _max?: ChoicesMaxAggregateInputType
  }

  export type ChoicesGroupByOutputType = {
    id: bigint
    enabled: boolean
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: ChoicesCountAggregateOutputType | null
    _avg: ChoicesAvgAggregateOutputType | null
    _sum: ChoicesSumAggregateOutputType | null
    _min: ChoicesMinAggregateOutputType | null
    _max: ChoicesMaxAggregateOutputType | null
  }

  type GetChoicesGroupByPayload<T extends ChoicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChoicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChoicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChoicesGroupByOutputType[P]>
            : GetScalarType<T[P], ChoicesGroupByOutputType[P]>
        }
      >
    >


  export type ChoicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    ChoicesLang?: boolean | Choices$ChoicesLangArgs<ExtArgs>
    RelationsChoices?: boolean | Choices$RelationsChoicesArgs<ExtArgs>
    _count?: boolean | ChoicesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["choices"]>


  export type ChoicesSelectScalar = {
    id?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ChoicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ChoicesLang?: boolean | Choices$ChoicesLangArgs<ExtArgs>
    RelationsChoices?: boolean | Choices$RelationsChoicesArgs<ExtArgs>
    _count?: boolean | ChoicesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ChoicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Choices"
    objects: {
      ChoicesLang: Prisma.$ChoicesLangPayload<ExtArgs>[]
      RelationsChoices: Prisma.$RelationsChoicesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      enabled: boolean
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["choices"]>
    composites: {}
  }

  type ChoicesGetPayload<S extends boolean | null | undefined | ChoicesDefaultArgs> = $Result.GetResult<Prisma.$ChoicesPayload, S>

  type ChoicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChoicesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChoicesCountAggregateInputType | true
    }

  export interface ChoicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Choices'], meta: { name: 'Choices' } }
    /**
     * Find zero or one Choices that matches the filter.
     * @param {ChoicesFindUniqueArgs} args - Arguments to find a Choices
     * @example
     * // Get one Choices
     * const choices = await prisma.choices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChoicesFindUniqueArgs>(args: SelectSubset<T, ChoicesFindUniqueArgs<ExtArgs>>): Prisma__ChoicesClient<$Result.GetResult<Prisma.$ChoicesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Choices that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChoicesFindUniqueOrThrowArgs} args - Arguments to find a Choices
     * @example
     * // Get one Choices
     * const choices = await prisma.choices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChoicesFindUniqueOrThrowArgs>(args: SelectSubset<T, ChoicesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChoicesClient<$Result.GetResult<Prisma.$ChoicesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Choices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoicesFindFirstArgs} args - Arguments to find a Choices
     * @example
     * // Get one Choices
     * const choices = await prisma.choices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChoicesFindFirstArgs>(args?: SelectSubset<T, ChoicesFindFirstArgs<ExtArgs>>): Prisma__ChoicesClient<$Result.GetResult<Prisma.$ChoicesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Choices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoicesFindFirstOrThrowArgs} args - Arguments to find a Choices
     * @example
     * // Get one Choices
     * const choices = await prisma.choices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChoicesFindFirstOrThrowArgs>(args?: SelectSubset<T, ChoicesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChoicesClient<$Result.GetResult<Prisma.$ChoicesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Choices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoicesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Choices
     * const choices = await prisma.choices.findMany()
     * 
     * // Get first 10 Choices
     * const choices = await prisma.choices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const choicesWithIdOnly = await prisma.choices.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChoicesFindManyArgs>(args?: SelectSubset<T, ChoicesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoicesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Choices.
     * @param {ChoicesCreateArgs} args - Arguments to create a Choices.
     * @example
     * // Create one Choices
     * const Choices = await prisma.choices.create({
     *   data: {
     *     // ... data to create a Choices
     *   }
     * })
     * 
     */
    create<T extends ChoicesCreateArgs>(args: SelectSubset<T, ChoicesCreateArgs<ExtArgs>>): Prisma__ChoicesClient<$Result.GetResult<Prisma.$ChoicesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Choices.
     * @param {ChoicesCreateManyArgs} args - Arguments to create many Choices.
     * @example
     * // Create many Choices
     * const choices = await prisma.choices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChoicesCreateManyArgs>(args?: SelectSubset<T, ChoicesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Choices.
     * @param {ChoicesDeleteArgs} args - Arguments to delete one Choices.
     * @example
     * // Delete one Choices
     * const Choices = await prisma.choices.delete({
     *   where: {
     *     // ... filter to delete one Choices
     *   }
     * })
     * 
     */
    delete<T extends ChoicesDeleteArgs>(args: SelectSubset<T, ChoicesDeleteArgs<ExtArgs>>): Prisma__ChoicesClient<$Result.GetResult<Prisma.$ChoicesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Choices.
     * @param {ChoicesUpdateArgs} args - Arguments to update one Choices.
     * @example
     * // Update one Choices
     * const choices = await prisma.choices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChoicesUpdateArgs>(args: SelectSubset<T, ChoicesUpdateArgs<ExtArgs>>): Prisma__ChoicesClient<$Result.GetResult<Prisma.$ChoicesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Choices.
     * @param {ChoicesDeleteManyArgs} args - Arguments to filter Choices to delete.
     * @example
     * // Delete a few Choices
     * const { count } = await prisma.choices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChoicesDeleteManyArgs>(args?: SelectSubset<T, ChoicesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Choices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Choices
     * const choices = await prisma.choices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChoicesUpdateManyArgs>(args: SelectSubset<T, ChoicesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Choices.
     * @param {ChoicesUpsertArgs} args - Arguments to update or create a Choices.
     * @example
     * // Update or create a Choices
     * const choices = await prisma.choices.upsert({
     *   create: {
     *     // ... data to create a Choices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Choices we want to update
     *   }
     * })
     */
    upsert<T extends ChoicesUpsertArgs>(args: SelectSubset<T, ChoicesUpsertArgs<ExtArgs>>): Prisma__ChoicesClient<$Result.GetResult<Prisma.$ChoicesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Choices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoicesCountArgs} args - Arguments to filter Choices to count.
     * @example
     * // Count the number of Choices
     * const count = await prisma.choices.count({
     *   where: {
     *     // ... the filter for the Choices we want to count
     *   }
     * })
    **/
    count<T extends ChoicesCountArgs>(
      args?: Subset<T, ChoicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChoicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Choices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChoicesAggregateArgs>(args: Subset<T, ChoicesAggregateArgs>): Prisma.PrismaPromise<GetChoicesAggregateType<T>>

    /**
     * Group by Choices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChoicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChoicesGroupByArgs['orderBy'] }
        : { orderBy?: ChoicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChoicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChoicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Choices model
   */
  readonly fields: ChoicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Choices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChoicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ChoicesLang<T extends Choices$ChoicesLangArgs<ExtArgs> = {}>(args?: Subset<T, Choices$ChoicesLangArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoicesLangPayload<ExtArgs>, T, "findMany"> | Null>
    RelationsChoices<T extends Choices$RelationsChoicesArgs<ExtArgs> = {}>(args?: Subset<T, Choices$RelationsChoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationsChoicesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Choices model
   */ 
  interface ChoicesFieldRefs {
    readonly id: FieldRef<"Choices", 'BigInt'>
    readonly enabled: FieldRef<"Choices", 'Boolean'>
    readonly createdAt: FieldRef<"Choices", 'DateTime'>
    readonly updatedAt: FieldRef<"Choices", 'DateTime'>
    readonly deletedAt: FieldRef<"Choices", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Choices findUnique
   */
  export type ChoicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choices
     */
    select?: ChoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoicesInclude<ExtArgs> | null
    /**
     * Filter, which Choices to fetch.
     */
    where: ChoicesWhereUniqueInput
  }

  /**
   * Choices findUniqueOrThrow
   */
  export type ChoicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choices
     */
    select?: ChoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoicesInclude<ExtArgs> | null
    /**
     * Filter, which Choices to fetch.
     */
    where: ChoicesWhereUniqueInput
  }

  /**
   * Choices findFirst
   */
  export type ChoicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choices
     */
    select?: ChoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoicesInclude<ExtArgs> | null
    /**
     * Filter, which Choices to fetch.
     */
    where?: ChoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Choices to fetch.
     */
    orderBy?: ChoicesOrderByWithRelationInput | ChoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Choices.
     */
    cursor?: ChoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Choices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Choices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Choices.
     */
    distinct?: ChoicesScalarFieldEnum | ChoicesScalarFieldEnum[]
  }

  /**
   * Choices findFirstOrThrow
   */
  export type ChoicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choices
     */
    select?: ChoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoicesInclude<ExtArgs> | null
    /**
     * Filter, which Choices to fetch.
     */
    where?: ChoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Choices to fetch.
     */
    orderBy?: ChoicesOrderByWithRelationInput | ChoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Choices.
     */
    cursor?: ChoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Choices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Choices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Choices.
     */
    distinct?: ChoicesScalarFieldEnum | ChoicesScalarFieldEnum[]
  }

  /**
   * Choices findMany
   */
  export type ChoicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choices
     */
    select?: ChoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoicesInclude<ExtArgs> | null
    /**
     * Filter, which Choices to fetch.
     */
    where?: ChoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Choices to fetch.
     */
    orderBy?: ChoicesOrderByWithRelationInput | ChoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Choices.
     */
    cursor?: ChoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Choices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Choices.
     */
    skip?: number
    distinct?: ChoicesScalarFieldEnum | ChoicesScalarFieldEnum[]
  }

  /**
   * Choices create
   */
  export type ChoicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choices
     */
    select?: ChoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoicesInclude<ExtArgs> | null
    /**
     * The data needed to create a Choices.
     */
    data?: XOR<ChoicesCreateInput, ChoicesUncheckedCreateInput>
  }

  /**
   * Choices createMany
   */
  export type ChoicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Choices.
     */
    data: ChoicesCreateManyInput | ChoicesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Choices update
   */
  export type ChoicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choices
     */
    select?: ChoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoicesInclude<ExtArgs> | null
    /**
     * The data needed to update a Choices.
     */
    data: XOR<ChoicesUpdateInput, ChoicesUncheckedUpdateInput>
    /**
     * Choose, which Choices to update.
     */
    where: ChoicesWhereUniqueInput
  }

  /**
   * Choices updateMany
   */
  export type ChoicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Choices.
     */
    data: XOR<ChoicesUpdateManyMutationInput, ChoicesUncheckedUpdateManyInput>
    /**
     * Filter which Choices to update
     */
    where?: ChoicesWhereInput
  }

  /**
   * Choices upsert
   */
  export type ChoicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choices
     */
    select?: ChoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoicesInclude<ExtArgs> | null
    /**
     * The filter to search for the Choices to update in case it exists.
     */
    where: ChoicesWhereUniqueInput
    /**
     * In case the Choices found by the `where` argument doesn't exist, create a new Choices with this data.
     */
    create: XOR<ChoicesCreateInput, ChoicesUncheckedCreateInput>
    /**
     * In case the Choices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChoicesUpdateInput, ChoicesUncheckedUpdateInput>
  }

  /**
   * Choices delete
   */
  export type ChoicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choices
     */
    select?: ChoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoicesInclude<ExtArgs> | null
    /**
     * Filter which Choices to delete.
     */
    where: ChoicesWhereUniqueInput
  }

  /**
   * Choices deleteMany
   */
  export type ChoicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Choices to delete
     */
    where?: ChoicesWhereInput
  }

  /**
   * Choices.ChoicesLang
   */
  export type Choices$ChoicesLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoicesLang
     */
    select?: ChoicesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoicesLangInclude<ExtArgs> | null
    where?: ChoicesLangWhereInput
    orderBy?: ChoicesLangOrderByWithRelationInput | ChoicesLangOrderByWithRelationInput[]
    cursor?: ChoicesLangWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChoicesLangScalarFieldEnum | ChoicesLangScalarFieldEnum[]
  }

  /**
   * Choices.RelationsChoices
   */
  export type Choices$RelationsChoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsChoices
     */
    select?: RelationsChoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsChoicesInclude<ExtArgs> | null
    where?: RelationsChoicesWhereInput
    orderBy?: RelationsChoicesOrderByWithRelationInput | RelationsChoicesOrderByWithRelationInput[]
    cursor?: RelationsChoicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelationsChoicesScalarFieldEnum | RelationsChoicesScalarFieldEnum[]
  }

  /**
   * Choices without action
   */
  export type ChoicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Choices
     */
    select?: ChoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoicesInclude<ExtArgs> | null
  }


  /**
   * Model ChoicesLang
   */

  export type AggregateChoicesLang = {
    _count: ChoicesLangCountAggregateOutputType | null
    _avg: ChoicesLangAvgAggregateOutputType | null
    _sum: ChoicesLangSumAggregateOutputType | null
    _min: ChoicesLangMinAggregateOutputType | null
    _max: ChoicesLangMaxAggregateOutputType | null
  }

  export type ChoicesLangAvgAggregateOutputType = {
    id: number | null
    chId: number | null
    lang: number | null
    audio: number | null
  }

  export type ChoicesLangSumAggregateOutputType = {
    id: bigint | null
    chId: bigint | null
    lang: bigint | null
    audio: bigint | null
  }

  export type ChoicesLangMinAggregateOutputType = {
    id: bigint | null
    chId: bigint | null
    lang: bigint | null
    text: string | null
    hint: string | null
    audio: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ChoicesLangMaxAggregateOutputType = {
    id: bigint | null
    chId: bigint | null
    lang: bigint | null
    text: string | null
    hint: string | null
    audio: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ChoicesLangCountAggregateOutputType = {
    id: number
    chId: number
    lang: number
    text: number
    hint: number
    audio: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ChoicesLangAvgAggregateInputType = {
    id?: true
    chId?: true
    lang?: true
    audio?: true
  }

  export type ChoicesLangSumAggregateInputType = {
    id?: true
    chId?: true
    lang?: true
    audio?: true
  }

  export type ChoicesLangMinAggregateInputType = {
    id?: true
    chId?: true
    lang?: true
    text?: true
    hint?: true
    audio?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ChoicesLangMaxAggregateInputType = {
    id?: true
    chId?: true
    lang?: true
    text?: true
    hint?: true
    audio?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ChoicesLangCountAggregateInputType = {
    id?: true
    chId?: true
    lang?: true
    text?: true
    hint?: true
    audio?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ChoicesLangAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChoicesLang to aggregate.
     */
    where?: ChoicesLangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoicesLangs to fetch.
     */
    orderBy?: ChoicesLangOrderByWithRelationInput | ChoicesLangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChoicesLangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoicesLangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoicesLangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChoicesLangs
    **/
    _count?: true | ChoicesLangCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChoicesLangAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChoicesLangSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChoicesLangMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChoicesLangMaxAggregateInputType
  }

  export type GetChoicesLangAggregateType<T extends ChoicesLangAggregateArgs> = {
        [P in keyof T & keyof AggregateChoicesLang]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChoicesLang[P]>
      : GetScalarType<T[P], AggregateChoicesLang[P]>
  }




  export type ChoicesLangGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChoicesLangWhereInput
    orderBy?: ChoicesLangOrderByWithAggregationInput | ChoicesLangOrderByWithAggregationInput[]
    by: ChoicesLangScalarFieldEnum[] | ChoicesLangScalarFieldEnum
    having?: ChoicesLangScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChoicesLangCountAggregateInputType | true
    _avg?: ChoicesLangAvgAggregateInputType
    _sum?: ChoicesLangSumAggregateInputType
    _min?: ChoicesLangMinAggregateInputType
    _max?: ChoicesLangMaxAggregateInputType
  }

  export type ChoicesLangGroupByOutputType = {
    id: bigint
    chId: bigint
    lang: bigint
    text: string
    hint: string | null
    audio: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: ChoicesLangCountAggregateOutputType | null
    _avg: ChoicesLangAvgAggregateOutputType | null
    _sum: ChoicesLangSumAggregateOutputType | null
    _min: ChoicesLangMinAggregateOutputType | null
    _max: ChoicesLangMaxAggregateOutputType | null
  }

  type GetChoicesLangGroupByPayload<T extends ChoicesLangGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChoicesLangGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChoicesLangGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChoicesLangGroupByOutputType[P]>
            : GetScalarType<T[P], ChoicesLangGroupByOutputType[P]>
        }
      >
    >


  export type ChoicesLangSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chId?: boolean
    lang?: boolean
    text?: boolean
    hint?: boolean
    audio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    Choices?: boolean | ChoicesDefaultArgs<ExtArgs>
    Languages?: boolean | LanguagesDefaultArgs<ExtArgs>
    Audio?: boolean | ChoicesLang$AudioArgs<ExtArgs>
  }, ExtArgs["result"]["choicesLang"]>


  export type ChoicesLangSelectScalar = {
    id?: boolean
    chId?: boolean
    lang?: boolean
    text?: boolean
    hint?: boolean
    audio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ChoicesLangInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Choices?: boolean | ChoicesDefaultArgs<ExtArgs>
    Languages?: boolean | LanguagesDefaultArgs<ExtArgs>
    Audio?: boolean | ChoicesLang$AudioArgs<ExtArgs>
  }

  export type $ChoicesLangPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChoicesLang"
    objects: {
      Choices: Prisma.$ChoicesPayload<ExtArgs>
      Languages: Prisma.$LanguagesPayload<ExtArgs>
      Audio: Prisma.$AudioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      chId: bigint
      lang: bigint
      text: string
      hint: string | null
      audio: bigint | null
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["choicesLang"]>
    composites: {}
  }

  type ChoicesLangGetPayload<S extends boolean | null | undefined | ChoicesLangDefaultArgs> = $Result.GetResult<Prisma.$ChoicesLangPayload, S>

  type ChoicesLangCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChoicesLangFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChoicesLangCountAggregateInputType | true
    }

  export interface ChoicesLangDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChoicesLang'], meta: { name: 'ChoicesLang' } }
    /**
     * Find zero or one ChoicesLang that matches the filter.
     * @param {ChoicesLangFindUniqueArgs} args - Arguments to find a ChoicesLang
     * @example
     * // Get one ChoicesLang
     * const choicesLang = await prisma.choicesLang.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChoicesLangFindUniqueArgs>(args: SelectSubset<T, ChoicesLangFindUniqueArgs<ExtArgs>>): Prisma__ChoicesLangClient<$Result.GetResult<Prisma.$ChoicesLangPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChoicesLang that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChoicesLangFindUniqueOrThrowArgs} args - Arguments to find a ChoicesLang
     * @example
     * // Get one ChoicesLang
     * const choicesLang = await prisma.choicesLang.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChoicesLangFindUniqueOrThrowArgs>(args: SelectSubset<T, ChoicesLangFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChoicesLangClient<$Result.GetResult<Prisma.$ChoicesLangPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChoicesLang that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoicesLangFindFirstArgs} args - Arguments to find a ChoicesLang
     * @example
     * // Get one ChoicesLang
     * const choicesLang = await prisma.choicesLang.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChoicesLangFindFirstArgs>(args?: SelectSubset<T, ChoicesLangFindFirstArgs<ExtArgs>>): Prisma__ChoicesLangClient<$Result.GetResult<Prisma.$ChoicesLangPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChoicesLang that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoicesLangFindFirstOrThrowArgs} args - Arguments to find a ChoicesLang
     * @example
     * // Get one ChoicesLang
     * const choicesLang = await prisma.choicesLang.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChoicesLangFindFirstOrThrowArgs>(args?: SelectSubset<T, ChoicesLangFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChoicesLangClient<$Result.GetResult<Prisma.$ChoicesLangPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChoicesLangs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoicesLangFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChoicesLangs
     * const choicesLangs = await prisma.choicesLang.findMany()
     * 
     * // Get first 10 ChoicesLangs
     * const choicesLangs = await prisma.choicesLang.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const choicesLangWithIdOnly = await prisma.choicesLang.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChoicesLangFindManyArgs>(args?: SelectSubset<T, ChoicesLangFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoicesLangPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChoicesLang.
     * @param {ChoicesLangCreateArgs} args - Arguments to create a ChoicesLang.
     * @example
     * // Create one ChoicesLang
     * const ChoicesLang = await prisma.choicesLang.create({
     *   data: {
     *     // ... data to create a ChoicesLang
     *   }
     * })
     * 
     */
    create<T extends ChoicesLangCreateArgs>(args: SelectSubset<T, ChoicesLangCreateArgs<ExtArgs>>): Prisma__ChoicesLangClient<$Result.GetResult<Prisma.$ChoicesLangPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChoicesLangs.
     * @param {ChoicesLangCreateManyArgs} args - Arguments to create many ChoicesLangs.
     * @example
     * // Create many ChoicesLangs
     * const choicesLang = await prisma.choicesLang.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChoicesLangCreateManyArgs>(args?: SelectSubset<T, ChoicesLangCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChoicesLang.
     * @param {ChoicesLangDeleteArgs} args - Arguments to delete one ChoicesLang.
     * @example
     * // Delete one ChoicesLang
     * const ChoicesLang = await prisma.choicesLang.delete({
     *   where: {
     *     // ... filter to delete one ChoicesLang
     *   }
     * })
     * 
     */
    delete<T extends ChoicesLangDeleteArgs>(args: SelectSubset<T, ChoicesLangDeleteArgs<ExtArgs>>): Prisma__ChoicesLangClient<$Result.GetResult<Prisma.$ChoicesLangPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChoicesLang.
     * @param {ChoicesLangUpdateArgs} args - Arguments to update one ChoicesLang.
     * @example
     * // Update one ChoicesLang
     * const choicesLang = await prisma.choicesLang.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChoicesLangUpdateArgs>(args: SelectSubset<T, ChoicesLangUpdateArgs<ExtArgs>>): Prisma__ChoicesLangClient<$Result.GetResult<Prisma.$ChoicesLangPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChoicesLangs.
     * @param {ChoicesLangDeleteManyArgs} args - Arguments to filter ChoicesLangs to delete.
     * @example
     * // Delete a few ChoicesLangs
     * const { count } = await prisma.choicesLang.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChoicesLangDeleteManyArgs>(args?: SelectSubset<T, ChoicesLangDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChoicesLangs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoicesLangUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChoicesLangs
     * const choicesLang = await prisma.choicesLang.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChoicesLangUpdateManyArgs>(args: SelectSubset<T, ChoicesLangUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChoicesLang.
     * @param {ChoicesLangUpsertArgs} args - Arguments to update or create a ChoicesLang.
     * @example
     * // Update or create a ChoicesLang
     * const choicesLang = await prisma.choicesLang.upsert({
     *   create: {
     *     // ... data to create a ChoicesLang
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChoicesLang we want to update
     *   }
     * })
     */
    upsert<T extends ChoicesLangUpsertArgs>(args: SelectSubset<T, ChoicesLangUpsertArgs<ExtArgs>>): Prisma__ChoicesLangClient<$Result.GetResult<Prisma.$ChoicesLangPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChoicesLangs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoicesLangCountArgs} args - Arguments to filter ChoicesLangs to count.
     * @example
     * // Count the number of ChoicesLangs
     * const count = await prisma.choicesLang.count({
     *   where: {
     *     // ... the filter for the ChoicesLangs we want to count
     *   }
     * })
    **/
    count<T extends ChoicesLangCountArgs>(
      args?: Subset<T, ChoicesLangCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChoicesLangCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChoicesLang.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoicesLangAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChoicesLangAggregateArgs>(args: Subset<T, ChoicesLangAggregateArgs>): Prisma.PrismaPromise<GetChoicesLangAggregateType<T>>

    /**
     * Group by ChoicesLang.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChoicesLangGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChoicesLangGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChoicesLangGroupByArgs['orderBy'] }
        : { orderBy?: ChoicesLangGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChoicesLangGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChoicesLangGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChoicesLang model
   */
  readonly fields: ChoicesLangFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChoicesLang.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChoicesLangClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Choices<T extends ChoicesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChoicesDefaultArgs<ExtArgs>>): Prisma__ChoicesClient<$Result.GetResult<Prisma.$ChoicesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Languages<T extends LanguagesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguagesDefaultArgs<ExtArgs>>): Prisma__LanguagesClient<$Result.GetResult<Prisma.$LanguagesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Audio<T extends ChoicesLang$AudioArgs<ExtArgs> = {}>(args?: Subset<T, ChoicesLang$AudioArgs<ExtArgs>>): Prisma__AudioClient<$Result.GetResult<Prisma.$AudioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChoicesLang model
   */ 
  interface ChoicesLangFieldRefs {
    readonly id: FieldRef<"ChoicesLang", 'BigInt'>
    readonly chId: FieldRef<"ChoicesLang", 'BigInt'>
    readonly lang: FieldRef<"ChoicesLang", 'BigInt'>
    readonly text: FieldRef<"ChoicesLang", 'String'>
    readonly hint: FieldRef<"ChoicesLang", 'String'>
    readonly audio: FieldRef<"ChoicesLang", 'BigInt'>
    readonly createdAt: FieldRef<"ChoicesLang", 'DateTime'>
    readonly updatedAt: FieldRef<"ChoicesLang", 'DateTime'>
    readonly deletedAt: FieldRef<"ChoicesLang", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChoicesLang findUnique
   */
  export type ChoicesLangFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoicesLang
     */
    select?: ChoicesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoicesLangInclude<ExtArgs> | null
    /**
     * Filter, which ChoicesLang to fetch.
     */
    where: ChoicesLangWhereUniqueInput
  }

  /**
   * ChoicesLang findUniqueOrThrow
   */
  export type ChoicesLangFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoicesLang
     */
    select?: ChoicesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoicesLangInclude<ExtArgs> | null
    /**
     * Filter, which ChoicesLang to fetch.
     */
    where: ChoicesLangWhereUniqueInput
  }

  /**
   * ChoicesLang findFirst
   */
  export type ChoicesLangFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoicesLang
     */
    select?: ChoicesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoicesLangInclude<ExtArgs> | null
    /**
     * Filter, which ChoicesLang to fetch.
     */
    where?: ChoicesLangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoicesLangs to fetch.
     */
    orderBy?: ChoicesLangOrderByWithRelationInput | ChoicesLangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChoicesLangs.
     */
    cursor?: ChoicesLangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoicesLangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoicesLangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChoicesLangs.
     */
    distinct?: ChoicesLangScalarFieldEnum | ChoicesLangScalarFieldEnum[]
  }

  /**
   * ChoicesLang findFirstOrThrow
   */
  export type ChoicesLangFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoicesLang
     */
    select?: ChoicesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoicesLangInclude<ExtArgs> | null
    /**
     * Filter, which ChoicesLang to fetch.
     */
    where?: ChoicesLangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoicesLangs to fetch.
     */
    orderBy?: ChoicesLangOrderByWithRelationInput | ChoicesLangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChoicesLangs.
     */
    cursor?: ChoicesLangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoicesLangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoicesLangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChoicesLangs.
     */
    distinct?: ChoicesLangScalarFieldEnum | ChoicesLangScalarFieldEnum[]
  }

  /**
   * ChoicesLang findMany
   */
  export type ChoicesLangFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoicesLang
     */
    select?: ChoicesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoicesLangInclude<ExtArgs> | null
    /**
     * Filter, which ChoicesLangs to fetch.
     */
    where?: ChoicesLangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChoicesLangs to fetch.
     */
    orderBy?: ChoicesLangOrderByWithRelationInput | ChoicesLangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChoicesLangs.
     */
    cursor?: ChoicesLangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChoicesLangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChoicesLangs.
     */
    skip?: number
    distinct?: ChoicesLangScalarFieldEnum | ChoicesLangScalarFieldEnum[]
  }

  /**
   * ChoicesLang create
   */
  export type ChoicesLangCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoicesLang
     */
    select?: ChoicesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoicesLangInclude<ExtArgs> | null
    /**
     * The data needed to create a ChoicesLang.
     */
    data: XOR<ChoicesLangCreateInput, ChoicesLangUncheckedCreateInput>
  }

  /**
   * ChoicesLang createMany
   */
  export type ChoicesLangCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChoicesLangs.
     */
    data: ChoicesLangCreateManyInput | ChoicesLangCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChoicesLang update
   */
  export type ChoicesLangUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoicesLang
     */
    select?: ChoicesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoicesLangInclude<ExtArgs> | null
    /**
     * The data needed to update a ChoicesLang.
     */
    data: XOR<ChoicesLangUpdateInput, ChoicesLangUncheckedUpdateInput>
    /**
     * Choose, which ChoicesLang to update.
     */
    where: ChoicesLangWhereUniqueInput
  }

  /**
   * ChoicesLang updateMany
   */
  export type ChoicesLangUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChoicesLangs.
     */
    data: XOR<ChoicesLangUpdateManyMutationInput, ChoicesLangUncheckedUpdateManyInput>
    /**
     * Filter which ChoicesLangs to update
     */
    where?: ChoicesLangWhereInput
  }

  /**
   * ChoicesLang upsert
   */
  export type ChoicesLangUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoicesLang
     */
    select?: ChoicesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoicesLangInclude<ExtArgs> | null
    /**
     * The filter to search for the ChoicesLang to update in case it exists.
     */
    where: ChoicesLangWhereUniqueInput
    /**
     * In case the ChoicesLang found by the `where` argument doesn't exist, create a new ChoicesLang with this data.
     */
    create: XOR<ChoicesLangCreateInput, ChoicesLangUncheckedCreateInput>
    /**
     * In case the ChoicesLang was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChoicesLangUpdateInput, ChoicesLangUncheckedUpdateInput>
  }

  /**
   * ChoicesLang delete
   */
  export type ChoicesLangDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoicesLang
     */
    select?: ChoicesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoicesLangInclude<ExtArgs> | null
    /**
     * Filter which ChoicesLang to delete.
     */
    where: ChoicesLangWhereUniqueInput
  }

  /**
   * ChoicesLang deleteMany
   */
  export type ChoicesLangDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChoicesLangs to delete
     */
    where?: ChoicesLangWhereInput
  }

  /**
   * ChoicesLang.Audio
   */
  export type ChoicesLang$AudioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audio
     */
    select?: AudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioInclude<ExtArgs> | null
    where?: AudioWhereInput
  }

  /**
   * ChoicesLang without action
   */
  export type ChoicesLangDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoicesLang
     */
    select?: ChoicesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoicesLangInclude<ExtArgs> | null
  }


  /**
   * Model FailedJobs
   */

  export type AggregateFailedJobs = {
    _count: FailedJobsCountAggregateOutputType | null
    _avg: FailedJobsAvgAggregateOutputType | null
    _sum: FailedJobsSumAggregateOutputType | null
    _min: FailedJobsMinAggregateOutputType | null
    _max: FailedJobsMaxAggregateOutputType | null
  }

  export type FailedJobsAvgAggregateOutputType = {
    id: number | null
  }

  export type FailedJobsSumAggregateOutputType = {
    id: bigint | null
  }

  export type FailedJobsMinAggregateOutputType = {
    id: bigint | null
    uuid: string | null
    connection: string | null
    queue: string | null
    payload: string | null
    exception: string | null
    failedAt: Date | null
  }

  export type FailedJobsMaxAggregateOutputType = {
    id: bigint | null
    uuid: string | null
    connection: string | null
    queue: string | null
    payload: string | null
    exception: string | null
    failedAt: Date | null
  }

  export type FailedJobsCountAggregateOutputType = {
    id: number
    uuid: number
    connection: number
    queue: number
    payload: number
    exception: number
    failedAt: number
    _all: number
  }


  export type FailedJobsAvgAggregateInputType = {
    id?: true
  }

  export type FailedJobsSumAggregateInputType = {
    id?: true
  }

  export type FailedJobsMinAggregateInputType = {
    id?: true
    uuid?: true
    connection?: true
    queue?: true
    payload?: true
    exception?: true
    failedAt?: true
  }

  export type FailedJobsMaxAggregateInputType = {
    id?: true
    uuid?: true
    connection?: true
    queue?: true
    payload?: true
    exception?: true
    failedAt?: true
  }

  export type FailedJobsCountAggregateInputType = {
    id?: true
    uuid?: true
    connection?: true
    queue?: true
    payload?: true
    exception?: true
    failedAt?: true
    _all?: true
  }

  export type FailedJobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FailedJobs to aggregate.
     */
    where?: FailedJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FailedJobs to fetch.
     */
    orderBy?: FailedJobsOrderByWithRelationInput | FailedJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FailedJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FailedJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FailedJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FailedJobs
    **/
    _count?: true | FailedJobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FailedJobsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FailedJobsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FailedJobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FailedJobsMaxAggregateInputType
  }

  export type GetFailedJobsAggregateType<T extends FailedJobsAggregateArgs> = {
        [P in keyof T & keyof AggregateFailedJobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFailedJobs[P]>
      : GetScalarType<T[P], AggregateFailedJobs[P]>
  }




  export type FailedJobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FailedJobsWhereInput
    orderBy?: FailedJobsOrderByWithAggregationInput | FailedJobsOrderByWithAggregationInput[]
    by: FailedJobsScalarFieldEnum[] | FailedJobsScalarFieldEnum
    having?: FailedJobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FailedJobsCountAggregateInputType | true
    _avg?: FailedJobsAvgAggregateInputType
    _sum?: FailedJobsSumAggregateInputType
    _min?: FailedJobsMinAggregateInputType
    _max?: FailedJobsMaxAggregateInputType
  }

  export type FailedJobsGroupByOutputType = {
    id: bigint
    uuid: string
    connection: string
    queue: string
    payload: string
    exception: string
    failedAt: Date
    _count: FailedJobsCountAggregateOutputType | null
    _avg: FailedJobsAvgAggregateOutputType | null
    _sum: FailedJobsSumAggregateOutputType | null
    _min: FailedJobsMinAggregateOutputType | null
    _max: FailedJobsMaxAggregateOutputType | null
  }

  type GetFailedJobsGroupByPayload<T extends FailedJobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FailedJobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FailedJobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FailedJobsGroupByOutputType[P]>
            : GetScalarType<T[P], FailedJobsGroupByOutputType[P]>
        }
      >
    >


  export type FailedJobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    connection?: boolean
    queue?: boolean
    payload?: boolean
    exception?: boolean
    failedAt?: boolean
  }, ExtArgs["result"]["failedJobs"]>


  export type FailedJobsSelectScalar = {
    id?: boolean
    uuid?: boolean
    connection?: boolean
    queue?: boolean
    payload?: boolean
    exception?: boolean
    failedAt?: boolean
  }


  export type $FailedJobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FailedJobs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      uuid: string
      connection: string
      queue: string
      payload: string
      exception: string
      failedAt: Date
    }, ExtArgs["result"]["failedJobs"]>
    composites: {}
  }

  type FailedJobsGetPayload<S extends boolean | null | undefined | FailedJobsDefaultArgs> = $Result.GetResult<Prisma.$FailedJobsPayload, S>

  type FailedJobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FailedJobsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FailedJobsCountAggregateInputType | true
    }

  export interface FailedJobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FailedJobs'], meta: { name: 'FailedJobs' } }
    /**
     * Find zero or one FailedJobs that matches the filter.
     * @param {FailedJobsFindUniqueArgs} args - Arguments to find a FailedJobs
     * @example
     * // Get one FailedJobs
     * const failedJobs = await prisma.failedJobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FailedJobsFindUniqueArgs>(args: SelectSubset<T, FailedJobsFindUniqueArgs<ExtArgs>>): Prisma__FailedJobsClient<$Result.GetResult<Prisma.$FailedJobsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FailedJobs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FailedJobsFindUniqueOrThrowArgs} args - Arguments to find a FailedJobs
     * @example
     * // Get one FailedJobs
     * const failedJobs = await prisma.failedJobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FailedJobsFindUniqueOrThrowArgs>(args: SelectSubset<T, FailedJobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FailedJobsClient<$Result.GetResult<Prisma.$FailedJobsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FailedJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedJobsFindFirstArgs} args - Arguments to find a FailedJobs
     * @example
     * // Get one FailedJobs
     * const failedJobs = await prisma.failedJobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FailedJobsFindFirstArgs>(args?: SelectSubset<T, FailedJobsFindFirstArgs<ExtArgs>>): Prisma__FailedJobsClient<$Result.GetResult<Prisma.$FailedJobsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FailedJobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedJobsFindFirstOrThrowArgs} args - Arguments to find a FailedJobs
     * @example
     * // Get one FailedJobs
     * const failedJobs = await prisma.failedJobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FailedJobsFindFirstOrThrowArgs>(args?: SelectSubset<T, FailedJobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__FailedJobsClient<$Result.GetResult<Prisma.$FailedJobsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FailedJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedJobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FailedJobs
     * const failedJobs = await prisma.failedJobs.findMany()
     * 
     * // Get first 10 FailedJobs
     * const failedJobs = await prisma.failedJobs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const failedJobsWithIdOnly = await prisma.failedJobs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FailedJobsFindManyArgs>(args?: SelectSubset<T, FailedJobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FailedJobsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FailedJobs.
     * @param {FailedJobsCreateArgs} args - Arguments to create a FailedJobs.
     * @example
     * // Create one FailedJobs
     * const FailedJobs = await prisma.failedJobs.create({
     *   data: {
     *     // ... data to create a FailedJobs
     *   }
     * })
     * 
     */
    create<T extends FailedJobsCreateArgs>(args: SelectSubset<T, FailedJobsCreateArgs<ExtArgs>>): Prisma__FailedJobsClient<$Result.GetResult<Prisma.$FailedJobsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FailedJobs.
     * @param {FailedJobsCreateManyArgs} args - Arguments to create many FailedJobs.
     * @example
     * // Create many FailedJobs
     * const failedJobs = await prisma.failedJobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FailedJobsCreateManyArgs>(args?: SelectSubset<T, FailedJobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FailedJobs.
     * @param {FailedJobsDeleteArgs} args - Arguments to delete one FailedJobs.
     * @example
     * // Delete one FailedJobs
     * const FailedJobs = await prisma.failedJobs.delete({
     *   where: {
     *     // ... filter to delete one FailedJobs
     *   }
     * })
     * 
     */
    delete<T extends FailedJobsDeleteArgs>(args: SelectSubset<T, FailedJobsDeleteArgs<ExtArgs>>): Prisma__FailedJobsClient<$Result.GetResult<Prisma.$FailedJobsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FailedJobs.
     * @param {FailedJobsUpdateArgs} args - Arguments to update one FailedJobs.
     * @example
     * // Update one FailedJobs
     * const failedJobs = await prisma.failedJobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FailedJobsUpdateArgs>(args: SelectSubset<T, FailedJobsUpdateArgs<ExtArgs>>): Prisma__FailedJobsClient<$Result.GetResult<Prisma.$FailedJobsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FailedJobs.
     * @param {FailedJobsDeleteManyArgs} args - Arguments to filter FailedJobs to delete.
     * @example
     * // Delete a few FailedJobs
     * const { count } = await prisma.failedJobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FailedJobsDeleteManyArgs>(args?: SelectSubset<T, FailedJobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FailedJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedJobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FailedJobs
     * const failedJobs = await prisma.failedJobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FailedJobsUpdateManyArgs>(args: SelectSubset<T, FailedJobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FailedJobs.
     * @param {FailedJobsUpsertArgs} args - Arguments to update or create a FailedJobs.
     * @example
     * // Update or create a FailedJobs
     * const failedJobs = await prisma.failedJobs.upsert({
     *   create: {
     *     // ... data to create a FailedJobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FailedJobs we want to update
     *   }
     * })
     */
    upsert<T extends FailedJobsUpsertArgs>(args: SelectSubset<T, FailedJobsUpsertArgs<ExtArgs>>): Prisma__FailedJobsClient<$Result.GetResult<Prisma.$FailedJobsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FailedJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedJobsCountArgs} args - Arguments to filter FailedJobs to count.
     * @example
     * // Count the number of FailedJobs
     * const count = await prisma.failedJobs.count({
     *   where: {
     *     // ... the filter for the FailedJobs we want to count
     *   }
     * })
    **/
    count<T extends FailedJobsCountArgs>(
      args?: Subset<T, FailedJobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FailedJobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FailedJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedJobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FailedJobsAggregateArgs>(args: Subset<T, FailedJobsAggregateArgs>): Prisma.PrismaPromise<GetFailedJobsAggregateType<T>>

    /**
     * Group by FailedJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FailedJobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FailedJobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FailedJobsGroupByArgs['orderBy'] }
        : { orderBy?: FailedJobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FailedJobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFailedJobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FailedJobs model
   */
  readonly fields: FailedJobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FailedJobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FailedJobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FailedJobs model
   */ 
  interface FailedJobsFieldRefs {
    readonly id: FieldRef<"FailedJobs", 'BigInt'>
    readonly uuid: FieldRef<"FailedJobs", 'String'>
    readonly connection: FieldRef<"FailedJobs", 'String'>
    readonly queue: FieldRef<"FailedJobs", 'String'>
    readonly payload: FieldRef<"FailedJobs", 'String'>
    readonly exception: FieldRef<"FailedJobs", 'String'>
    readonly failedAt: FieldRef<"FailedJobs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FailedJobs findUnique
   */
  export type FailedJobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedJobs
     */
    select?: FailedJobsSelect<ExtArgs> | null
    /**
     * Filter, which FailedJobs to fetch.
     */
    where: FailedJobsWhereUniqueInput
  }

  /**
   * FailedJobs findUniqueOrThrow
   */
  export type FailedJobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedJobs
     */
    select?: FailedJobsSelect<ExtArgs> | null
    /**
     * Filter, which FailedJobs to fetch.
     */
    where: FailedJobsWhereUniqueInput
  }

  /**
   * FailedJobs findFirst
   */
  export type FailedJobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedJobs
     */
    select?: FailedJobsSelect<ExtArgs> | null
    /**
     * Filter, which FailedJobs to fetch.
     */
    where?: FailedJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FailedJobs to fetch.
     */
    orderBy?: FailedJobsOrderByWithRelationInput | FailedJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FailedJobs.
     */
    cursor?: FailedJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FailedJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FailedJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FailedJobs.
     */
    distinct?: FailedJobsScalarFieldEnum | FailedJobsScalarFieldEnum[]
  }

  /**
   * FailedJobs findFirstOrThrow
   */
  export type FailedJobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedJobs
     */
    select?: FailedJobsSelect<ExtArgs> | null
    /**
     * Filter, which FailedJobs to fetch.
     */
    where?: FailedJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FailedJobs to fetch.
     */
    orderBy?: FailedJobsOrderByWithRelationInput | FailedJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FailedJobs.
     */
    cursor?: FailedJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FailedJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FailedJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FailedJobs.
     */
    distinct?: FailedJobsScalarFieldEnum | FailedJobsScalarFieldEnum[]
  }

  /**
   * FailedJobs findMany
   */
  export type FailedJobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedJobs
     */
    select?: FailedJobsSelect<ExtArgs> | null
    /**
     * Filter, which FailedJobs to fetch.
     */
    where?: FailedJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FailedJobs to fetch.
     */
    orderBy?: FailedJobsOrderByWithRelationInput | FailedJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FailedJobs.
     */
    cursor?: FailedJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FailedJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FailedJobs.
     */
    skip?: number
    distinct?: FailedJobsScalarFieldEnum | FailedJobsScalarFieldEnum[]
  }

  /**
   * FailedJobs create
   */
  export type FailedJobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedJobs
     */
    select?: FailedJobsSelect<ExtArgs> | null
    /**
     * The data needed to create a FailedJobs.
     */
    data: XOR<FailedJobsCreateInput, FailedJobsUncheckedCreateInput>
  }

  /**
   * FailedJobs createMany
   */
  export type FailedJobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FailedJobs.
     */
    data: FailedJobsCreateManyInput | FailedJobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FailedJobs update
   */
  export type FailedJobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedJobs
     */
    select?: FailedJobsSelect<ExtArgs> | null
    /**
     * The data needed to update a FailedJobs.
     */
    data: XOR<FailedJobsUpdateInput, FailedJobsUncheckedUpdateInput>
    /**
     * Choose, which FailedJobs to update.
     */
    where: FailedJobsWhereUniqueInput
  }

  /**
   * FailedJobs updateMany
   */
  export type FailedJobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FailedJobs.
     */
    data: XOR<FailedJobsUpdateManyMutationInput, FailedJobsUncheckedUpdateManyInput>
    /**
     * Filter which FailedJobs to update
     */
    where?: FailedJobsWhereInput
  }

  /**
   * FailedJobs upsert
   */
  export type FailedJobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedJobs
     */
    select?: FailedJobsSelect<ExtArgs> | null
    /**
     * The filter to search for the FailedJobs to update in case it exists.
     */
    where: FailedJobsWhereUniqueInput
    /**
     * In case the FailedJobs found by the `where` argument doesn't exist, create a new FailedJobs with this data.
     */
    create: XOR<FailedJobsCreateInput, FailedJobsUncheckedCreateInput>
    /**
     * In case the FailedJobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FailedJobsUpdateInput, FailedJobsUncheckedUpdateInput>
  }

  /**
   * FailedJobs delete
   */
  export type FailedJobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedJobs
     */
    select?: FailedJobsSelect<ExtArgs> | null
    /**
     * Filter which FailedJobs to delete.
     */
    where: FailedJobsWhereUniqueInput
  }

  /**
   * FailedJobs deleteMany
   */
  export type FailedJobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FailedJobs to delete
     */
    where?: FailedJobsWhereInput
  }

  /**
   * FailedJobs without action
   */
  export type FailedJobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FailedJobs
     */
    select?: FailedJobsSelect<ExtArgs> | null
  }


  /**
   * Model Groups
   */

  export type AggregateGroups = {
    _count: GroupsCountAggregateOutputType | null
    _avg: GroupsAvgAggregateOutputType | null
    _sum: GroupsSumAggregateOutputType | null
    _min: GroupsMinAggregateOutputType | null
    _max: GroupsMaxAggregateOutputType | null
  }

  export type GroupsAvgAggregateOutputType = {
    id: number | null
    level: number | null
    media: number | null
    randCount: number | null
  }

  export type GroupsSumAggregateOutputType = {
    id: bigint | null
    level: number | null
    media: bigint | null
    randCount: number | null
  }

  export type GroupsMinAggregateOutputType = {
    id: bigint | null
    code: string | null
    level: number | null
    media: bigint | null
    randCount: number | null
    enabled: boolean | null
    other: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type GroupsMaxAggregateOutputType = {
    id: bigint | null
    code: string | null
    level: number | null
    media: bigint | null
    randCount: number | null
    enabled: boolean | null
    other: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type GroupsCountAggregateOutputType = {
    id: number
    code: number
    level: number
    media: number
    randCount: number
    enabled: number
    other: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type GroupsAvgAggregateInputType = {
    id?: true
    level?: true
    media?: true
    randCount?: true
  }

  export type GroupsSumAggregateInputType = {
    id?: true
    level?: true
    media?: true
    randCount?: true
  }

  export type GroupsMinAggregateInputType = {
    id?: true
    code?: true
    level?: true
    media?: true
    randCount?: true
    enabled?: true
    other?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type GroupsMaxAggregateInputType = {
    id?: true
    code?: true
    level?: true
    media?: true
    randCount?: true
    enabled?: true
    other?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type GroupsCountAggregateInputType = {
    id?: true
    code?: true
    level?: true
    media?: true
    randCount?: true
    enabled?: true
    other?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type GroupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to aggregate.
     */
    where?: GroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupsOrderByWithRelationInput | GroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Groups
    **/
    _count?: true | GroupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupsMaxAggregateInputType
  }

  export type GetGroupsAggregateType<T extends GroupsAggregateArgs> = {
        [P in keyof T & keyof AggregateGroups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroups[P]>
      : GetScalarType<T[P], AggregateGroups[P]>
  }




  export type GroupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupsWhereInput
    orderBy?: GroupsOrderByWithAggregationInput | GroupsOrderByWithAggregationInput[]
    by: GroupsScalarFieldEnum[] | GroupsScalarFieldEnum
    having?: GroupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupsCountAggregateInputType | true
    _avg?: GroupsAvgAggregateInputType
    _sum?: GroupsSumAggregateInputType
    _min?: GroupsMinAggregateInputType
    _max?: GroupsMaxAggregateInputType
  }

  export type GroupsGroupByOutputType = {
    id: bigint
    code: string
    level: number
    media: bigint | null
    randCount: number
    enabled: boolean
    other: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: GroupsCountAggregateOutputType | null
    _avg: GroupsAvgAggregateOutputType | null
    _sum: GroupsSumAggregateOutputType | null
    _min: GroupsMinAggregateOutputType | null
    _max: GroupsMaxAggregateOutputType | null
  }

  type GetGroupsGroupByPayload<T extends GroupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupsGroupByOutputType[P]>
            : GetScalarType<T[P], GroupsGroupByOutputType[P]>
        }
      >
    >


  export type GroupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    level?: boolean
    media?: boolean
    randCount?: boolean
    enabled?: boolean
    other?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    Media?: boolean | Groups$MediaArgs<ExtArgs>
    GroupsLang?: boolean | Groups$GroupsLangArgs<ExtArgs>
    Relations?: boolean | Groups$RelationsArgs<ExtArgs>
    UsersGroups?: boolean | Groups$UsersGroupsArgs<ExtArgs>
    _count?: boolean | GroupsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["groups"]>


  export type GroupsSelectScalar = {
    id?: boolean
    code?: boolean
    level?: boolean
    media?: boolean
    randCount?: boolean
    enabled?: boolean
    other?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type GroupsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Media?: boolean | Groups$MediaArgs<ExtArgs>
    GroupsLang?: boolean | Groups$GroupsLangArgs<ExtArgs>
    Relations?: boolean | Groups$RelationsArgs<ExtArgs>
    UsersGroups?: boolean | Groups$UsersGroupsArgs<ExtArgs>
    _count?: boolean | GroupsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $GroupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Groups"
    objects: {
      Media: Prisma.$MediaPayload<ExtArgs> | null
      GroupsLang: Prisma.$GroupsLangPayload<ExtArgs>[]
      Relations: Prisma.$RelationsPayload<ExtArgs>[]
      UsersGroups: Prisma.$UsersGroupsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      code: string
      level: number
      media: bigint | null
      randCount: number
      enabled: boolean
      other: string | null
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["groups"]>
    composites: {}
  }

  type GroupsGetPayload<S extends boolean | null | undefined | GroupsDefaultArgs> = $Result.GetResult<Prisma.$GroupsPayload, S>

  type GroupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GroupsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GroupsCountAggregateInputType | true
    }

  export interface GroupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Groups'], meta: { name: 'Groups' } }
    /**
     * Find zero or one Groups that matches the filter.
     * @param {GroupsFindUniqueArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupsFindUniqueArgs>(args: SelectSubset<T, GroupsFindUniqueArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Groups that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GroupsFindUniqueOrThrowArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupsFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsFindFirstArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupsFindFirstArgs>(args?: SelectSubset<T, GroupsFindFirstArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Groups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsFindFirstOrThrowArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupsFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupsFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.groups.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.groups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupsWithIdOnly = await prisma.groups.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupsFindManyArgs>(args?: SelectSubset<T, GroupsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Groups.
     * @param {GroupsCreateArgs} args - Arguments to create a Groups.
     * @example
     * // Create one Groups
     * const Groups = await prisma.groups.create({
     *   data: {
     *     // ... data to create a Groups
     *   }
     * })
     * 
     */
    create<T extends GroupsCreateArgs>(args: SelectSubset<T, GroupsCreateArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Groups.
     * @param {GroupsCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const groups = await prisma.groups.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupsCreateManyArgs>(args?: SelectSubset<T, GroupsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Groups.
     * @param {GroupsDeleteArgs} args - Arguments to delete one Groups.
     * @example
     * // Delete one Groups
     * const Groups = await prisma.groups.delete({
     *   where: {
     *     // ... filter to delete one Groups
     *   }
     * })
     * 
     */
    delete<T extends GroupsDeleteArgs>(args: SelectSubset<T, GroupsDeleteArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Groups.
     * @param {GroupsUpdateArgs} args - Arguments to update one Groups.
     * @example
     * // Update one Groups
     * const groups = await prisma.groups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupsUpdateArgs>(args: SelectSubset<T, GroupsUpdateArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Groups.
     * @param {GroupsDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.groups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupsDeleteManyArgs>(args?: SelectSubset<T, GroupsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const groups = await prisma.groups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupsUpdateManyArgs>(args: SelectSubset<T, GroupsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Groups.
     * @param {GroupsUpsertArgs} args - Arguments to update or create a Groups.
     * @example
     * // Update or create a Groups
     * const groups = await prisma.groups.upsert({
     *   create: {
     *     // ... data to create a Groups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Groups we want to update
     *   }
     * })
     */
    upsert<T extends GroupsUpsertArgs>(args: SelectSubset<T, GroupsUpsertArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.groups.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends GroupsCountArgs>(
      args?: Subset<T, GroupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupsAggregateArgs>(args: Subset<T, GroupsAggregateArgs>): Prisma.PrismaPromise<GetGroupsAggregateType<T>>

    /**
     * Group by Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupsGroupByArgs['orderBy'] }
        : { orderBy?: GroupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Groups model
   */
  readonly fields: GroupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Groups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Media<T extends Groups$MediaArgs<ExtArgs> = {}>(args?: Subset<T, Groups$MediaArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    GroupsLang<T extends Groups$GroupsLangArgs<ExtArgs> = {}>(args?: Subset<T, Groups$GroupsLangArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupsLangPayload<ExtArgs>, T, "findMany"> | Null>
    Relations<T extends Groups$RelationsArgs<ExtArgs> = {}>(args?: Subset<T, Groups$RelationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationsPayload<ExtArgs>, T, "findMany"> | Null>
    UsersGroups<T extends Groups$UsersGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Groups$UsersGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersGroupsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Groups model
   */ 
  interface GroupsFieldRefs {
    readonly id: FieldRef<"Groups", 'BigInt'>
    readonly code: FieldRef<"Groups", 'String'>
    readonly level: FieldRef<"Groups", 'Int'>
    readonly media: FieldRef<"Groups", 'BigInt'>
    readonly randCount: FieldRef<"Groups", 'Int'>
    readonly enabled: FieldRef<"Groups", 'Boolean'>
    readonly other: FieldRef<"Groups", 'String'>
    readonly createdAt: FieldRef<"Groups", 'DateTime'>
    readonly updatedAt: FieldRef<"Groups", 'DateTime'>
    readonly deletedAt: FieldRef<"Groups", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Groups findUnique
   */
  export type GroupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where: GroupsWhereUniqueInput
  }

  /**
   * Groups findUniqueOrThrow
   */
  export type GroupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where: GroupsWhereUniqueInput
  }

  /**
   * Groups findFirst
   */
  export type GroupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupsOrderByWithRelationInput | GroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupsScalarFieldEnum | GroupsScalarFieldEnum[]
  }

  /**
   * Groups findFirstOrThrow
   */
  export type GroupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupsOrderByWithRelationInput | GroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Groups.
     */
    cursor?: GroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Groups.
     */
    distinct?: GroupsScalarFieldEnum | GroupsScalarFieldEnum[]
  }

  /**
   * Groups findMany
   */
  export type GroupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * Filter, which Groups to fetch.
     */
    where?: GroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Groups to fetch.
     */
    orderBy?: GroupsOrderByWithRelationInput | GroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Groups.
     */
    cursor?: GroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Groups.
     */
    skip?: number
    distinct?: GroupsScalarFieldEnum | GroupsScalarFieldEnum[]
  }

  /**
   * Groups create
   */
  export type GroupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * The data needed to create a Groups.
     */
    data: XOR<GroupsCreateInput, GroupsUncheckedCreateInput>
  }

  /**
   * Groups createMany
   */
  export type GroupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Groups.
     */
    data: GroupsCreateManyInput | GroupsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Groups update
   */
  export type GroupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * The data needed to update a Groups.
     */
    data: XOR<GroupsUpdateInput, GroupsUncheckedUpdateInput>
    /**
     * Choose, which Groups to update.
     */
    where: GroupsWhereUniqueInput
  }

  /**
   * Groups updateMany
   */
  export type GroupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Groups.
     */
    data: XOR<GroupsUpdateManyMutationInput, GroupsUncheckedUpdateManyInput>
    /**
     * Filter which Groups to update
     */
    where?: GroupsWhereInput
  }

  /**
   * Groups upsert
   */
  export type GroupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * The filter to search for the Groups to update in case it exists.
     */
    where: GroupsWhereUniqueInput
    /**
     * In case the Groups found by the `where` argument doesn't exist, create a new Groups with this data.
     */
    create: XOR<GroupsCreateInput, GroupsUncheckedCreateInput>
    /**
     * In case the Groups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupsUpdateInput, GroupsUncheckedUpdateInput>
  }

  /**
   * Groups delete
   */
  export type GroupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    /**
     * Filter which Groups to delete.
     */
    where: GroupsWhereUniqueInput
  }

  /**
   * Groups deleteMany
   */
  export type GroupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Groups to delete
     */
    where?: GroupsWhereInput
  }

  /**
   * Groups.Media
   */
  export type Groups$MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Groups.GroupsLang
   */
  export type Groups$GroupsLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupsLang
     */
    select?: GroupsLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsLangInclude<ExtArgs> | null
    where?: GroupsLangWhereInput
    orderBy?: GroupsLangOrderByWithRelationInput | GroupsLangOrderByWithRelationInput[]
    cursor?: GroupsLangWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupsLangScalarFieldEnum | GroupsLangScalarFieldEnum[]
  }

  /**
   * Groups.Relations
   */
  export type Groups$RelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relations
     */
    select?: RelationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsInclude<ExtArgs> | null
    where?: RelationsWhereInput
    orderBy?: RelationsOrderByWithRelationInput | RelationsOrderByWithRelationInput[]
    cursor?: RelationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelationsScalarFieldEnum | RelationsScalarFieldEnum[]
  }

  /**
   * Groups.UsersGroups
   */
  export type Groups$UsersGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersGroups
     */
    select?: UsersGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersGroupsInclude<ExtArgs> | null
    where?: UsersGroupsWhereInput
    orderBy?: UsersGroupsOrderByWithRelationInput | UsersGroupsOrderByWithRelationInput[]
    cursor?: UsersGroupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersGroupsScalarFieldEnum | UsersGroupsScalarFieldEnum[]
  }

  /**
   * Groups without action
   */
  export type GroupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
  }


  /**
   * Model GroupsLang
   */

  export type AggregateGroupsLang = {
    _count: GroupsLangCountAggregateOutputType | null
    _avg: GroupsLangAvgAggregateOutputType | null
    _sum: GroupsLangSumAggregateOutputType | null
    _min: GroupsLangMinAggregateOutputType | null
    _max: GroupsLangMaxAggregateOutputType | null
  }

  export type GroupsLangAvgAggregateOutputType = {
    id: number | null
    gpId: number | null
    lang: number | null
    audio: number | null
  }

  export type GroupsLangSumAggregateOutputType = {
    id: bigint | null
    gpId: bigint | null
    lang: bigint | null
    audio: bigint | null
  }

  export type GroupsLangMinAggregateOutputType = {
    id: bigint | null
    gpId: bigint | null
    lang: bigint | null
    name: string | null
    desc: string | null
    audio: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type GroupsLangMaxAggregateOutputType = {
    id: bigint | null
    gpId: bigint | null
    lang: bigint | null
    name: string | null
    desc: string | null
    audio: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type GroupsLangCountAggregateOutputType = {
    id: number
    gpId: number
    lang: number
    name: number
    desc: number
    audio: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type GroupsLangAvgAggregateInputType = {
    id?: true
    gpId?: true
    lang?: true
    audio?: true
  }

  export type GroupsLangSumAggregateInputType = {
    id?: true
    gpId?: true
    lang?: true
    audio?: true
  }

  export type GroupsLangMinAggregateInputType = {
    id?: true
    gpId?: true
    lang?: true
    name?: true
    desc?: true
    audio?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type GroupsLangMaxAggregateInputType = {
    id?: true
    gpId?: true
    lang?: true
    name?: true
    desc?: true
    audio?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type GroupsLangCountAggregateInputType = {
    id?: true
    gpId?: true
    lang?: true
    name?: true
    desc?: true
    audio?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type GroupsLangAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupsLang to aggregate.
     */
    where?: GroupsLangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupsLangs to fetch.
     */
    orderBy?: GroupsLangOrderByWithRelationInput | GroupsLangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GroupsLangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupsLangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupsLangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GroupsLangs
    **/
    _count?: true | GroupsLangCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GroupsLangAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GroupsLangSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupsLangMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupsLangMaxAggregateInputType
  }

  export type GetGroupsLangAggregateType<T extends GroupsLangAggregateArgs> = {
        [P in keyof T & keyof AggregateGroupsLang]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroupsLang[P]>
      : GetScalarType<T[P], AggregateGroupsLang[P]>
  }




  export type GroupsLangGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GroupsLangWhereInput
    orderBy?: GroupsLangOrderByWithAggregationInput | GroupsLangOrderByWithAggregationInput[]
    by: GroupsLangScalarFieldEnum[] | GroupsLangScalarFieldEnum
    having?: GroupsLangScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupsLangCountAggregateInputType | true
    _avg?: GroupsLangAvgAggregateInputType
    _sum?: GroupsLangSumAggregateInputType
    _min?: GroupsLangMinAggregateInputType
    _max?: GroupsLangMaxAggregateInputType
  }

  export type GroupsLangGroupByOutputType = {
    id: bigint
    gpId: bigint
    lang: bigint
    name: string
    desc: string | null
    audio: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: GroupsLangCountAggregateOutputType | null
    _avg: GroupsLangAvgAggregateOutputType | null
    _sum: GroupsLangSumAggregateOutputType | null
    _min: GroupsLangMinAggregateOutputType | null
    _max: GroupsLangMaxAggregateOutputType | null
  }

  type GetGroupsLangGroupByPayload<T extends GroupsLangGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupsLangGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupsLangGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupsLangGroupByOutputType[P]>
            : GetScalarType<T[P], GroupsLangGroupByOutputType[P]>
        }
      >
    >


  export type GroupsLangSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gpId?: boolean
    lang?: boolean
    name?: boolean
    desc?: boolean
    audio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    Groups?: boolean | GroupsDefaultArgs<ExtArgs>
    Languages?: boolean | LanguagesDefaultArgs<ExtArgs>
    Audio?: boolean | GroupsLang$AudioArgs<ExtArgs>
  }, ExtArgs["result"]["groupsLang"]>


  export type GroupsLangSelectScalar = {
    id?: boolean
    gpId?: boolean
    lang?: boolean
    name?: boolean
    desc?: boolean
    audio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type GroupsLangInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Groups?: boolean | GroupsDefaultArgs<ExtArgs>
    Languages?: boolean | LanguagesDefaultArgs<ExtArgs>
    Audio?: boolean | GroupsLang$AudioArgs<ExtArgs>
  }

  export type $GroupsLangPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GroupsLang"
    objects: {
      Groups: Prisma.$GroupsPayload<ExtArgs>
      Languages: Prisma.$LanguagesPayload<ExtArgs>
      Audio: Prisma.$AudioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      gpId: bigint
      lang: bigint
      name: string
      desc: string | null
      audio: bigint | null
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["groupsLang"]>
    composites: {}
  }

  type GroupsLangGetPayload<S extends boolean | null | undefined | GroupsLangDefaultArgs> = $Result.GetResult<Prisma.$GroupsLangPayload, S>

  type GroupsLangCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GroupsLangFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GroupsLangCountAggregateInputType | true
    }

  export interface GroupsLangDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GroupsLang'], meta: { name: 'GroupsLang' } }
    /**
     * Find zero or one GroupsLang that matches the filter.
     * @param {GroupsLangFindUniqueArgs} args - Arguments to find a GroupsLang
     * @example
     * // Get one GroupsLang
     * const groupsLang = await prisma.groupsLang.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GroupsLangFindUniqueArgs>(args: SelectSubset<T, GroupsLangFindUniqueArgs<ExtArgs>>): Prisma__GroupsLangClient<$Result.GetResult<Prisma.$GroupsLangPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one GroupsLang that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GroupsLangFindUniqueOrThrowArgs} args - Arguments to find a GroupsLang
     * @example
     * // Get one GroupsLang
     * const groupsLang = await prisma.groupsLang.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GroupsLangFindUniqueOrThrowArgs>(args: SelectSubset<T, GroupsLangFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GroupsLangClient<$Result.GetResult<Prisma.$GroupsLangPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first GroupsLang that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsLangFindFirstArgs} args - Arguments to find a GroupsLang
     * @example
     * // Get one GroupsLang
     * const groupsLang = await prisma.groupsLang.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GroupsLangFindFirstArgs>(args?: SelectSubset<T, GroupsLangFindFirstArgs<ExtArgs>>): Prisma__GroupsLangClient<$Result.GetResult<Prisma.$GroupsLangPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first GroupsLang that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsLangFindFirstOrThrowArgs} args - Arguments to find a GroupsLang
     * @example
     * // Get one GroupsLang
     * const groupsLang = await prisma.groupsLang.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GroupsLangFindFirstOrThrowArgs>(args?: SelectSubset<T, GroupsLangFindFirstOrThrowArgs<ExtArgs>>): Prisma__GroupsLangClient<$Result.GetResult<Prisma.$GroupsLangPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more GroupsLangs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsLangFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GroupsLangs
     * const groupsLangs = await prisma.groupsLang.findMany()
     * 
     * // Get first 10 GroupsLangs
     * const groupsLangs = await prisma.groupsLang.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupsLangWithIdOnly = await prisma.groupsLang.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GroupsLangFindManyArgs>(args?: SelectSubset<T, GroupsLangFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupsLangPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a GroupsLang.
     * @param {GroupsLangCreateArgs} args - Arguments to create a GroupsLang.
     * @example
     * // Create one GroupsLang
     * const GroupsLang = await prisma.groupsLang.create({
     *   data: {
     *     // ... data to create a GroupsLang
     *   }
     * })
     * 
     */
    create<T extends GroupsLangCreateArgs>(args: SelectSubset<T, GroupsLangCreateArgs<ExtArgs>>): Prisma__GroupsLangClient<$Result.GetResult<Prisma.$GroupsLangPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many GroupsLangs.
     * @param {GroupsLangCreateManyArgs} args - Arguments to create many GroupsLangs.
     * @example
     * // Create many GroupsLangs
     * const groupsLang = await prisma.groupsLang.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GroupsLangCreateManyArgs>(args?: SelectSubset<T, GroupsLangCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GroupsLang.
     * @param {GroupsLangDeleteArgs} args - Arguments to delete one GroupsLang.
     * @example
     * // Delete one GroupsLang
     * const GroupsLang = await prisma.groupsLang.delete({
     *   where: {
     *     // ... filter to delete one GroupsLang
     *   }
     * })
     * 
     */
    delete<T extends GroupsLangDeleteArgs>(args: SelectSubset<T, GroupsLangDeleteArgs<ExtArgs>>): Prisma__GroupsLangClient<$Result.GetResult<Prisma.$GroupsLangPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one GroupsLang.
     * @param {GroupsLangUpdateArgs} args - Arguments to update one GroupsLang.
     * @example
     * // Update one GroupsLang
     * const groupsLang = await prisma.groupsLang.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GroupsLangUpdateArgs>(args: SelectSubset<T, GroupsLangUpdateArgs<ExtArgs>>): Prisma__GroupsLangClient<$Result.GetResult<Prisma.$GroupsLangPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more GroupsLangs.
     * @param {GroupsLangDeleteManyArgs} args - Arguments to filter GroupsLangs to delete.
     * @example
     * // Delete a few GroupsLangs
     * const { count } = await prisma.groupsLang.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GroupsLangDeleteManyArgs>(args?: SelectSubset<T, GroupsLangDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GroupsLangs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsLangUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GroupsLangs
     * const groupsLang = await prisma.groupsLang.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GroupsLangUpdateManyArgs>(args: SelectSubset<T, GroupsLangUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GroupsLang.
     * @param {GroupsLangUpsertArgs} args - Arguments to update or create a GroupsLang.
     * @example
     * // Update or create a GroupsLang
     * const groupsLang = await prisma.groupsLang.upsert({
     *   create: {
     *     // ... data to create a GroupsLang
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GroupsLang we want to update
     *   }
     * })
     */
    upsert<T extends GroupsLangUpsertArgs>(args: SelectSubset<T, GroupsLangUpsertArgs<ExtArgs>>): Prisma__GroupsLangClient<$Result.GetResult<Prisma.$GroupsLangPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of GroupsLangs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsLangCountArgs} args - Arguments to filter GroupsLangs to count.
     * @example
     * // Count the number of GroupsLangs
     * const count = await prisma.groupsLang.count({
     *   where: {
     *     // ... the filter for the GroupsLangs we want to count
     *   }
     * })
    **/
    count<T extends GroupsLangCountArgs>(
      args?: Subset<T, GroupsLangCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupsLangCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GroupsLang.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsLangAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupsLangAggregateArgs>(args: Subset<T, GroupsLangAggregateArgs>): Prisma.PrismaPromise<GetGroupsLangAggregateType<T>>

    /**
     * Group by GroupsLang.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsLangGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GroupsLangGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GroupsLangGroupByArgs['orderBy'] }
        : { orderBy?: GroupsLangGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GroupsLangGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupsLangGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GroupsLang model
   */
  readonly fields: GroupsLangFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GroupsLang.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GroupsLangClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Groups<T extends GroupsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupsDefaultArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Languages<T extends LanguagesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguagesDefaultArgs<ExtArgs>>): Prisma__LanguagesClient<$Result.GetResult<Prisma.$LanguagesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Audio<T extends GroupsLang$AudioArgs<ExtArgs> = {}>(args?: Subset<T, GroupsLang$AudioArgs<ExtArgs>>): Prisma__AudioClient<$Result.GetResult<Prisma.$AudioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GroupsLang model
   */ 
  interface GroupsLangFieldRefs {
    readonly id: FieldRef<"GroupsLang", 'BigInt'>
    readonly gpId: FieldRef<"GroupsLang", 'BigInt'>
    readonly lang: FieldRef<"GroupsLang", 'BigInt'>
    readonly name: FieldRef<"GroupsLang", 'String'>
    readonly desc: FieldRef<"GroupsLang", 'String'>
    readonly audio: FieldRef<"GroupsLang", 'BigInt'>
    readonly createdAt: FieldRef<"GroupsLang", 'DateTime'>
    readonly updatedAt: FieldRef<"GroupsLang", 'DateTime'>
    readonly deletedAt: FieldRef<"GroupsLang", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GroupsLang findUnique
   */
  export type GroupsLangFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupsLang
     */
    select?: GroupsLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsLangInclude<ExtArgs> | null
    /**
     * Filter, which GroupsLang to fetch.
     */
    where: GroupsLangWhereUniqueInput
  }

  /**
   * GroupsLang findUniqueOrThrow
   */
  export type GroupsLangFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupsLang
     */
    select?: GroupsLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsLangInclude<ExtArgs> | null
    /**
     * Filter, which GroupsLang to fetch.
     */
    where: GroupsLangWhereUniqueInput
  }

  /**
   * GroupsLang findFirst
   */
  export type GroupsLangFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupsLang
     */
    select?: GroupsLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsLangInclude<ExtArgs> | null
    /**
     * Filter, which GroupsLang to fetch.
     */
    where?: GroupsLangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupsLangs to fetch.
     */
    orderBy?: GroupsLangOrderByWithRelationInput | GroupsLangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupsLangs.
     */
    cursor?: GroupsLangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupsLangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupsLangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupsLangs.
     */
    distinct?: GroupsLangScalarFieldEnum | GroupsLangScalarFieldEnum[]
  }

  /**
   * GroupsLang findFirstOrThrow
   */
  export type GroupsLangFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupsLang
     */
    select?: GroupsLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsLangInclude<ExtArgs> | null
    /**
     * Filter, which GroupsLang to fetch.
     */
    where?: GroupsLangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupsLangs to fetch.
     */
    orderBy?: GroupsLangOrderByWithRelationInput | GroupsLangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GroupsLangs.
     */
    cursor?: GroupsLangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupsLangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupsLangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GroupsLangs.
     */
    distinct?: GroupsLangScalarFieldEnum | GroupsLangScalarFieldEnum[]
  }

  /**
   * GroupsLang findMany
   */
  export type GroupsLangFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupsLang
     */
    select?: GroupsLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsLangInclude<ExtArgs> | null
    /**
     * Filter, which GroupsLangs to fetch.
     */
    where?: GroupsLangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GroupsLangs to fetch.
     */
    orderBy?: GroupsLangOrderByWithRelationInput | GroupsLangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GroupsLangs.
     */
    cursor?: GroupsLangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GroupsLangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GroupsLangs.
     */
    skip?: number
    distinct?: GroupsLangScalarFieldEnum | GroupsLangScalarFieldEnum[]
  }

  /**
   * GroupsLang create
   */
  export type GroupsLangCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupsLang
     */
    select?: GroupsLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsLangInclude<ExtArgs> | null
    /**
     * The data needed to create a GroupsLang.
     */
    data: XOR<GroupsLangCreateInput, GroupsLangUncheckedCreateInput>
  }

  /**
   * GroupsLang createMany
   */
  export type GroupsLangCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GroupsLangs.
     */
    data: GroupsLangCreateManyInput | GroupsLangCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GroupsLang update
   */
  export type GroupsLangUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupsLang
     */
    select?: GroupsLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsLangInclude<ExtArgs> | null
    /**
     * The data needed to update a GroupsLang.
     */
    data: XOR<GroupsLangUpdateInput, GroupsLangUncheckedUpdateInput>
    /**
     * Choose, which GroupsLang to update.
     */
    where: GroupsLangWhereUniqueInput
  }

  /**
   * GroupsLang updateMany
   */
  export type GroupsLangUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GroupsLangs.
     */
    data: XOR<GroupsLangUpdateManyMutationInput, GroupsLangUncheckedUpdateManyInput>
    /**
     * Filter which GroupsLangs to update
     */
    where?: GroupsLangWhereInput
  }

  /**
   * GroupsLang upsert
   */
  export type GroupsLangUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupsLang
     */
    select?: GroupsLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsLangInclude<ExtArgs> | null
    /**
     * The filter to search for the GroupsLang to update in case it exists.
     */
    where: GroupsLangWhereUniqueInput
    /**
     * In case the GroupsLang found by the `where` argument doesn't exist, create a new GroupsLang with this data.
     */
    create: XOR<GroupsLangCreateInput, GroupsLangUncheckedCreateInput>
    /**
     * In case the GroupsLang was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GroupsLangUpdateInput, GroupsLangUncheckedUpdateInput>
  }

  /**
   * GroupsLang delete
   */
  export type GroupsLangDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupsLang
     */
    select?: GroupsLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsLangInclude<ExtArgs> | null
    /**
     * Filter which GroupsLang to delete.
     */
    where: GroupsLangWhereUniqueInput
  }

  /**
   * GroupsLang deleteMany
   */
  export type GroupsLangDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GroupsLangs to delete
     */
    where?: GroupsLangWhereInput
  }

  /**
   * GroupsLang.Audio
   */
  export type GroupsLang$AudioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audio
     */
    select?: AudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioInclude<ExtArgs> | null
    where?: AudioWhereInput
  }

  /**
   * GroupsLang without action
   */
  export type GroupsLangDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupsLang
     */
    select?: GroupsLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsLangInclude<ExtArgs> | null
  }


  /**
   * Model Languages
   */

  export type AggregateLanguages = {
    _count: LanguagesCountAggregateOutputType | null
    _avg: LanguagesAvgAggregateOutputType | null
    _sum: LanguagesSumAggregateOutputType | null
    _min: LanguagesMinAggregateOutputType | null
    _max: LanguagesMaxAggregateOutputType | null
  }

  export type LanguagesAvgAggregateOutputType = {
    id: number | null
  }

  export type LanguagesSumAggregateOutputType = {
    id: bigint | null
  }

  export type LanguagesMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    code: string | null
    voiceCode: string | null
    voiceType: string | null
    voiceName: string | null
    voiceGender: string | null
    voiceProfile: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type LanguagesMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    code: string | null
    voiceCode: string | null
    voiceType: string | null
    voiceName: string | null
    voiceGender: string | null
    voiceProfile: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type LanguagesCountAggregateOutputType = {
    id: number
    name: number
    code: number
    voiceCode: number
    voiceType: number
    voiceName: number
    voiceGender: number
    voiceProfile: number
    enabled: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type LanguagesAvgAggregateInputType = {
    id?: true
  }

  export type LanguagesSumAggregateInputType = {
    id?: true
  }

  export type LanguagesMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    voiceCode?: true
    voiceType?: true
    voiceName?: true
    voiceGender?: true
    voiceProfile?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type LanguagesMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    voiceCode?: true
    voiceType?: true
    voiceName?: true
    voiceGender?: true
    voiceProfile?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type LanguagesCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    voiceCode?: true
    voiceType?: true
    voiceName?: true
    voiceGender?: true
    voiceProfile?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type LanguagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Languages to aggregate.
     */
    where?: LanguagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguagesOrderByWithRelationInput | LanguagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LanguagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Languages
    **/
    _count?: true | LanguagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LanguagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LanguagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LanguagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LanguagesMaxAggregateInputType
  }

  export type GetLanguagesAggregateType<T extends LanguagesAggregateArgs> = {
        [P in keyof T & keyof AggregateLanguages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLanguages[P]>
      : GetScalarType<T[P], AggregateLanguages[P]>
  }




  export type LanguagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LanguagesWhereInput
    orderBy?: LanguagesOrderByWithAggregationInput | LanguagesOrderByWithAggregationInput[]
    by: LanguagesScalarFieldEnum[] | LanguagesScalarFieldEnum
    having?: LanguagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LanguagesCountAggregateInputType | true
    _avg?: LanguagesAvgAggregateInputType
    _sum?: LanguagesSumAggregateInputType
    _min?: LanguagesMinAggregateInputType
    _max?: LanguagesMaxAggregateInputType
  }

  export type LanguagesGroupByOutputType = {
    id: bigint
    name: string
    code: string
    voiceCode: string
    voiceType: string
    voiceName: string
    voiceGender: string
    voiceProfile: string
    enabled: boolean
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: LanguagesCountAggregateOutputType | null
    _avg: LanguagesAvgAggregateOutputType | null
    _sum: LanguagesSumAggregateOutputType | null
    _min: LanguagesMinAggregateOutputType | null
    _max: LanguagesMaxAggregateOutputType | null
  }

  type GetLanguagesGroupByPayload<T extends LanguagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LanguagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LanguagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LanguagesGroupByOutputType[P]>
            : GetScalarType<T[P], LanguagesGroupByOutputType[P]>
        }
      >
    >


  export type LanguagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    voiceCode?: boolean
    voiceType?: boolean
    voiceName?: boolean
    voiceGender?: boolean
    voiceProfile?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    ChoicesLang?: boolean | Languages$ChoicesLangArgs<ExtArgs>
    GroupsLang?: boolean | Languages$GroupsLangArgs<ExtArgs>
    LicensesLang?: boolean | Languages$LicensesLangArgs<ExtArgs>
    QuestionsLang?: boolean | Languages$QuestionsLangArgs<ExtArgs>
    QuizzesLang?: boolean | Languages$QuizzesLangArgs<ExtArgs>
    _count?: boolean | LanguagesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["languages"]>


  export type LanguagesSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    voiceCode?: boolean
    voiceType?: boolean
    voiceName?: boolean
    voiceGender?: boolean
    voiceProfile?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type LanguagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ChoicesLang?: boolean | Languages$ChoicesLangArgs<ExtArgs>
    GroupsLang?: boolean | Languages$GroupsLangArgs<ExtArgs>
    LicensesLang?: boolean | Languages$LicensesLangArgs<ExtArgs>
    QuestionsLang?: boolean | Languages$QuestionsLangArgs<ExtArgs>
    QuizzesLang?: boolean | Languages$QuizzesLangArgs<ExtArgs>
    _count?: boolean | LanguagesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LanguagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Languages"
    objects: {
      ChoicesLang: Prisma.$ChoicesLangPayload<ExtArgs>[]
      GroupsLang: Prisma.$GroupsLangPayload<ExtArgs>[]
      LicensesLang: Prisma.$LicensesLangPayload<ExtArgs>[]
      QuestionsLang: Prisma.$QuestionsLangPayload<ExtArgs>[]
      QuizzesLang: Prisma.$QuizzesLangPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      code: string
      voiceCode: string
      voiceType: string
      voiceName: string
      voiceGender: string
      voiceProfile: string
      enabled: boolean
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["languages"]>
    composites: {}
  }

  type LanguagesGetPayload<S extends boolean | null | undefined | LanguagesDefaultArgs> = $Result.GetResult<Prisma.$LanguagesPayload, S>

  type LanguagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LanguagesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LanguagesCountAggregateInputType | true
    }

  export interface LanguagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Languages'], meta: { name: 'Languages' } }
    /**
     * Find zero or one Languages that matches the filter.
     * @param {LanguagesFindUniqueArgs} args - Arguments to find a Languages
     * @example
     * // Get one Languages
     * const languages = await prisma.languages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LanguagesFindUniqueArgs>(args: SelectSubset<T, LanguagesFindUniqueArgs<ExtArgs>>): Prisma__LanguagesClient<$Result.GetResult<Prisma.$LanguagesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Languages that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LanguagesFindUniqueOrThrowArgs} args - Arguments to find a Languages
     * @example
     * // Get one Languages
     * const languages = await prisma.languages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LanguagesFindUniqueOrThrowArgs>(args: SelectSubset<T, LanguagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LanguagesClient<$Result.GetResult<Prisma.$LanguagesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguagesFindFirstArgs} args - Arguments to find a Languages
     * @example
     * // Get one Languages
     * const languages = await prisma.languages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LanguagesFindFirstArgs>(args?: SelectSubset<T, LanguagesFindFirstArgs<ExtArgs>>): Prisma__LanguagesClient<$Result.GetResult<Prisma.$LanguagesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Languages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguagesFindFirstOrThrowArgs} args - Arguments to find a Languages
     * @example
     * // Get one Languages
     * const languages = await prisma.languages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LanguagesFindFirstOrThrowArgs>(args?: SelectSubset<T, LanguagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__LanguagesClient<$Result.GetResult<Prisma.$LanguagesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Languages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Languages
     * const languages = await prisma.languages.findMany()
     * 
     * // Get first 10 Languages
     * const languages = await prisma.languages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const languagesWithIdOnly = await prisma.languages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LanguagesFindManyArgs>(args?: SelectSubset<T, LanguagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanguagesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Languages.
     * @param {LanguagesCreateArgs} args - Arguments to create a Languages.
     * @example
     * // Create one Languages
     * const Languages = await prisma.languages.create({
     *   data: {
     *     // ... data to create a Languages
     *   }
     * })
     * 
     */
    create<T extends LanguagesCreateArgs>(args: SelectSubset<T, LanguagesCreateArgs<ExtArgs>>): Prisma__LanguagesClient<$Result.GetResult<Prisma.$LanguagesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Languages.
     * @param {LanguagesCreateManyArgs} args - Arguments to create many Languages.
     * @example
     * // Create many Languages
     * const languages = await prisma.languages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LanguagesCreateManyArgs>(args?: SelectSubset<T, LanguagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Languages.
     * @param {LanguagesDeleteArgs} args - Arguments to delete one Languages.
     * @example
     * // Delete one Languages
     * const Languages = await prisma.languages.delete({
     *   where: {
     *     // ... filter to delete one Languages
     *   }
     * })
     * 
     */
    delete<T extends LanguagesDeleteArgs>(args: SelectSubset<T, LanguagesDeleteArgs<ExtArgs>>): Prisma__LanguagesClient<$Result.GetResult<Prisma.$LanguagesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Languages.
     * @param {LanguagesUpdateArgs} args - Arguments to update one Languages.
     * @example
     * // Update one Languages
     * const languages = await prisma.languages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LanguagesUpdateArgs>(args: SelectSubset<T, LanguagesUpdateArgs<ExtArgs>>): Prisma__LanguagesClient<$Result.GetResult<Prisma.$LanguagesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Languages.
     * @param {LanguagesDeleteManyArgs} args - Arguments to filter Languages to delete.
     * @example
     * // Delete a few Languages
     * const { count } = await prisma.languages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LanguagesDeleteManyArgs>(args?: SelectSubset<T, LanguagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Languages
     * const languages = await prisma.languages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LanguagesUpdateManyArgs>(args: SelectSubset<T, LanguagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Languages.
     * @param {LanguagesUpsertArgs} args - Arguments to update or create a Languages.
     * @example
     * // Update or create a Languages
     * const languages = await prisma.languages.upsert({
     *   create: {
     *     // ... data to create a Languages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Languages we want to update
     *   }
     * })
     */
    upsert<T extends LanguagesUpsertArgs>(args: SelectSubset<T, LanguagesUpsertArgs<ExtArgs>>): Prisma__LanguagesClient<$Result.GetResult<Prisma.$LanguagesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguagesCountArgs} args - Arguments to filter Languages to count.
     * @example
     * // Count the number of Languages
     * const count = await prisma.languages.count({
     *   where: {
     *     // ... the filter for the Languages we want to count
     *   }
     * })
    **/
    count<T extends LanguagesCountArgs>(
      args?: Subset<T, LanguagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LanguagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LanguagesAggregateArgs>(args: Subset<T, LanguagesAggregateArgs>): Prisma.PrismaPromise<GetLanguagesAggregateType<T>>

    /**
     * Group by Languages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LanguagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LanguagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LanguagesGroupByArgs['orderBy'] }
        : { orderBy?: LanguagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LanguagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLanguagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Languages model
   */
  readonly fields: LanguagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Languages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LanguagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ChoicesLang<T extends Languages$ChoicesLangArgs<ExtArgs> = {}>(args?: Subset<T, Languages$ChoicesLangArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChoicesLangPayload<ExtArgs>, T, "findMany"> | Null>
    GroupsLang<T extends Languages$GroupsLangArgs<ExtArgs> = {}>(args?: Subset<T, Languages$GroupsLangArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupsLangPayload<ExtArgs>, T, "findMany"> | Null>
    LicensesLang<T extends Languages$LicensesLangArgs<ExtArgs> = {}>(args?: Subset<T, Languages$LicensesLangArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicensesLangPayload<ExtArgs>, T, "findMany"> | Null>
    QuestionsLang<T extends Languages$QuestionsLangArgs<ExtArgs> = {}>(args?: Subset<T, Languages$QuestionsLangArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionsLangPayload<ExtArgs>, T, "findMany"> | Null>
    QuizzesLang<T extends Languages$QuizzesLangArgs<ExtArgs> = {}>(args?: Subset<T, Languages$QuizzesLangArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizzesLangPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Languages model
   */ 
  interface LanguagesFieldRefs {
    readonly id: FieldRef<"Languages", 'BigInt'>
    readonly name: FieldRef<"Languages", 'String'>
    readonly code: FieldRef<"Languages", 'String'>
    readonly voiceCode: FieldRef<"Languages", 'String'>
    readonly voiceType: FieldRef<"Languages", 'String'>
    readonly voiceName: FieldRef<"Languages", 'String'>
    readonly voiceGender: FieldRef<"Languages", 'String'>
    readonly voiceProfile: FieldRef<"Languages", 'String'>
    readonly enabled: FieldRef<"Languages", 'Boolean'>
    readonly createdAt: FieldRef<"Languages", 'DateTime'>
    readonly updatedAt: FieldRef<"Languages", 'DateTime'>
    readonly deletedAt: FieldRef<"Languages", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Languages findUnique
   */
  export type LanguagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Languages
     */
    select?: LanguagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguagesInclude<ExtArgs> | null
    /**
     * Filter, which Languages to fetch.
     */
    where: LanguagesWhereUniqueInput
  }

  /**
   * Languages findUniqueOrThrow
   */
  export type LanguagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Languages
     */
    select?: LanguagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguagesInclude<ExtArgs> | null
    /**
     * Filter, which Languages to fetch.
     */
    where: LanguagesWhereUniqueInput
  }

  /**
   * Languages findFirst
   */
  export type LanguagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Languages
     */
    select?: LanguagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguagesInclude<ExtArgs> | null
    /**
     * Filter, which Languages to fetch.
     */
    where?: LanguagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguagesOrderByWithRelationInput | LanguagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguagesScalarFieldEnum | LanguagesScalarFieldEnum[]
  }

  /**
   * Languages findFirstOrThrow
   */
  export type LanguagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Languages
     */
    select?: LanguagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguagesInclude<ExtArgs> | null
    /**
     * Filter, which Languages to fetch.
     */
    where?: LanguagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguagesOrderByWithRelationInput | LanguagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Languages.
     */
    cursor?: LanguagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Languages.
     */
    distinct?: LanguagesScalarFieldEnum | LanguagesScalarFieldEnum[]
  }

  /**
   * Languages findMany
   */
  export type LanguagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Languages
     */
    select?: LanguagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguagesInclude<ExtArgs> | null
    /**
     * Filter, which Languages to fetch.
     */
    where?: LanguagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Languages to fetch.
     */
    orderBy?: LanguagesOrderByWithRelationInput | LanguagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Languages.
     */
    cursor?: LanguagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Languages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Languages.
     */
    skip?: number
    distinct?: LanguagesScalarFieldEnum | LanguagesScalarFieldEnum[]
  }

  /**
   * Languages create
   */
  export type LanguagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Languages
     */
    select?: LanguagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguagesInclude<ExtArgs> | null
    /**
     * The data needed to create a Languages.
     */
    data: XOR<LanguagesCreateInput, LanguagesUncheckedCreateInput>
  }

  /**
   * Languages createMany
   */
  export type LanguagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Languages.
     */
    data: LanguagesCreateManyInput | LanguagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Languages update
   */
  export type LanguagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Languages
     */
    select?: LanguagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguagesInclude<ExtArgs> | null
    /**
     * The data needed to update a Languages.
     */
    data: XOR<LanguagesUpdateInput, LanguagesUncheckedUpdateInput>
    /**
     * Choose, which Languages to update.
     */
    where: LanguagesWhereUniqueInput
  }

  /**
   * Languages updateMany
   */
  export type LanguagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Languages.
     */
    data: XOR<LanguagesUpdateManyMutationInput, LanguagesUncheckedUpdateManyInput>
    /**
     * Filter which Languages to update
     */
    where?: LanguagesWhereInput
  }

  /**
   * Languages upsert
   */
  export type LanguagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Languages
     */
    select?: LanguagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguagesInclude<ExtArgs> | null
    /**
     * The filter to search for the Languages to update in case it exists.
     */
    where: LanguagesWhereUniqueInput
    /**
     * In case the Languages found by the `where` argument doesn't exist, create a new Languages with this data.
     */
    create: XOR<LanguagesCreateInput, LanguagesUncheckedCreateInput>
    /**
     * In case the Languages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LanguagesUpdateInput, LanguagesUncheckedUpdateInput>
  }

  /**
   * Languages delete
   */
  export type LanguagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Languages
     */
    select?: LanguagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguagesInclude<ExtArgs> | null
    /**
     * Filter which Languages to delete.
     */
    where: LanguagesWhereUniqueInput
  }

  /**
   * Languages deleteMany
   */
  export type LanguagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Languages to delete
     */
    where?: LanguagesWhereInput
  }

  /**
   * Languages.ChoicesLang
   */
  export type Languages$ChoicesLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChoicesLang
     */
    select?: ChoicesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChoicesLangInclude<ExtArgs> | null
    where?: ChoicesLangWhereInput
    orderBy?: ChoicesLangOrderByWithRelationInput | ChoicesLangOrderByWithRelationInput[]
    cursor?: ChoicesLangWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChoicesLangScalarFieldEnum | ChoicesLangScalarFieldEnum[]
  }

  /**
   * Languages.GroupsLang
   */
  export type Languages$GroupsLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GroupsLang
     */
    select?: GroupsLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsLangInclude<ExtArgs> | null
    where?: GroupsLangWhereInput
    orderBy?: GroupsLangOrderByWithRelationInput | GroupsLangOrderByWithRelationInput[]
    cursor?: GroupsLangWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupsLangScalarFieldEnum | GroupsLangScalarFieldEnum[]
  }

  /**
   * Languages.LicensesLang
   */
  export type Languages$LicensesLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicensesLang
     */
    select?: LicensesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicensesLangInclude<ExtArgs> | null
    where?: LicensesLangWhereInput
    orderBy?: LicensesLangOrderByWithRelationInput | LicensesLangOrderByWithRelationInput[]
    cursor?: LicensesLangWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LicensesLangScalarFieldEnum | LicensesLangScalarFieldEnum[]
  }

  /**
   * Languages.QuestionsLang
   */
  export type Languages$QuestionsLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsLang
     */
    select?: QuestionsLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsLangInclude<ExtArgs> | null
    where?: QuestionsLangWhereInput
    orderBy?: QuestionsLangOrderByWithRelationInput | QuestionsLangOrderByWithRelationInput[]
    cursor?: QuestionsLangWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionsLangScalarFieldEnum | QuestionsLangScalarFieldEnum[]
  }

  /**
   * Languages.QuizzesLang
   */
  export type Languages$QuizzesLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizzesLang
     */
    select?: QuizzesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizzesLangInclude<ExtArgs> | null
    where?: QuizzesLangWhereInput
    orderBy?: QuizzesLangOrderByWithRelationInput | QuizzesLangOrderByWithRelationInput[]
    cursor?: QuizzesLangWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizzesLangScalarFieldEnum | QuizzesLangScalarFieldEnum[]
  }

  /**
   * Languages without action
   */
  export type LanguagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Languages
     */
    select?: LanguagesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LanguagesInclude<ExtArgs> | null
  }


  /**
   * Model Licenses
   */

  export type AggregateLicenses = {
    _count: LicensesCountAggregateOutputType | null
    _avg: LicensesAvgAggregateOutputType | null
    _sum: LicensesSumAggregateOutputType | null
    _min: LicensesMinAggregateOutputType | null
    _max: LicensesMaxAggregateOutputType | null
  }

  export type LicensesAvgAggregateOutputType = {
    id: number | null
    media: number | null
  }

  export type LicensesSumAggregateOutputType = {
    id: bigint | null
    media: bigint | null
  }

  export type LicensesMinAggregateOutputType = {
    id: bigint | null
    code: string | null
    media: bigint | null
    enabled: boolean | null
    other: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type LicensesMaxAggregateOutputType = {
    id: bigint | null
    code: string | null
    media: bigint | null
    enabled: boolean | null
    other: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type LicensesCountAggregateOutputType = {
    id: number
    code: number
    media: number
    enabled: number
    other: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type LicensesAvgAggregateInputType = {
    id?: true
    media?: true
  }

  export type LicensesSumAggregateInputType = {
    id?: true
    media?: true
  }

  export type LicensesMinAggregateInputType = {
    id?: true
    code?: true
    media?: true
    enabled?: true
    other?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type LicensesMaxAggregateInputType = {
    id?: true
    code?: true
    media?: true
    enabled?: true
    other?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type LicensesCountAggregateInputType = {
    id?: true
    code?: true
    media?: true
    enabled?: true
    other?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type LicensesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Licenses to aggregate.
     */
    where?: LicensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicensesOrderByWithRelationInput | LicensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LicensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Licenses
    **/
    _count?: true | LicensesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LicensesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LicensesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LicensesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LicensesMaxAggregateInputType
  }

  export type GetLicensesAggregateType<T extends LicensesAggregateArgs> = {
        [P in keyof T & keyof AggregateLicenses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLicenses[P]>
      : GetScalarType<T[P], AggregateLicenses[P]>
  }




  export type LicensesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LicensesWhereInput
    orderBy?: LicensesOrderByWithAggregationInput | LicensesOrderByWithAggregationInput[]
    by: LicensesScalarFieldEnum[] | LicensesScalarFieldEnum
    having?: LicensesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LicensesCountAggregateInputType | true
    _avg?: LicensesAvgAggregateInputType
    _sum?: LicensesSumAggregateInputType
    _min?: LicensesMinAggregateInputType
    _max?: LicensesMaxAggregateInputType
  }

  export type LicensesGroupByOutputType = {
    id: bigint
    code: string
    media: bigint | null
    enabled: boolean
    other: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: LicensesCountAggregateOutputType | null
    _avg: LicensesAvgAggregateOutputType | null
    _sum: LicensesSumAggregateOutputType | null
    _min: LicensesMinAggregateOutputType | null
    _max: LicensesMaxAggregateOutputType | null
  }

  type GetLicensesGroupByPayload<T extends LicensesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LicensesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LicensesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LicensesGroupByOutputType[P]>
            : GetScalarType<T[P], LicensesGroupByOutputType[P]>
        }
      >
    >


  export type LicensesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    media?: boolean
    enabled?: boolean
    other?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    Media?: boolean | Licenses$MediaArgs<ExtArgs>
    LicensesLang?: boolean | Licenses$LicensesLangArgs<ExtArgs>
    Relations?: boolean | Licenses$RelationsArgs<ExtArgs>
    _count?: boolean | LicensesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["licenses"]>


  export type LicensesSelectScalar = {
    id?: boolean
    code?: boolean
    media?: boolean
    enabled?: boolean
    other?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type LicensesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Media?: boolean | Licenses$MediaArgs<ExtArgs>
    LicensesLang?: boolean | Licenses$LicensesLangArgs<ExtArgs>
    Relations?: boolean | Licenses$RelationsArgs<ExtArgs>
    _count?: boolean | LicensesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LicensesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Licenses"
    objects: {
      Media: Prisma.$MediaPayload<ExtArgs> | null
      LicensesLang: Prisma.$LicensesLangPayload<ExtArgs>[]
      Relations: Prisma.$RelationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      code: string
      media: bigint | null
      enabled: boolean
      other: string | null
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["licenses"]>
    composites: {}
  }

  type LicensesGetPayload<S extends boolean | null | undefined | LicensesDefaultArgs> = $Result.GetResult<Prisma.$LicensesPayload, S>

  type LicensesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LicensesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LicensesCountAggregateInputType | true
    }

  export interface LicensesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Licenses'], meta: { name: 'Licenses' } }
    /**
     * Find zero or one Licenses that matches the filter.
     * @param {LicensesFindUniqueArgs} args - Arguments to find a Licenses
     * @example
     * // Get one Licenses
     * const licenses = await prisma.licenses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LicensesFindUniqueArgs>(args: SelectSubset<T, LicensesFindUniqueArgs<ExtArgs>>): Prisma__LicensesClient<$Result.GetResult<Prisma.$LicensesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Licenses that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LicensesFindUniqueOrThrowArgs} args - Arguments to find a Licenses
     * @example
     * // Get one Licenses
     * const licenses = await prisma.licenses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LicensesFindUniqueOrThrowArgs>(args: SelectSubset<T, LicensesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LicensesClient<$Result.GetResult<Prisma.$LicensesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Licenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicensesFindFirstArgs} args - Arguments to find a Licenses
     * @example
     * // Get one Licenses
     * const licenses = await prisma.licenses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LicensesFindFirstArgs>(args?: SelectSubset<T, LicensesFindFirstArgs<ExtArgs>>): Prisma__LicensesClient<$Result.GetResult<Prisma.$LicensesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Licenses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicensesFindFirstOrThrowArgs} args - Arguments to find a Licenses
     * @example
     * // Get one Licenses
     * const licenses = await prisma.licenses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LicensesFindFirstOrThrowArgs>(args?: SelectSubset<T, LicensesFindFirstOrThrowArgs<ExtArgs>>): Prisma__LicensesClient<$Result.GetResult<Prisma.$LicensesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Licenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicensesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Licenses
     * const licenses = await prisma.licenses.findMany()
     * 
     * // Get first 10 Licenses
     * const licenses = await prisma.licenses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const licensesWithIdOnly = await prisma.licenses.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LicensesFindManyArgs>(args?: SelectSubset<T, LicensesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicensesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Licenses.
     * @param {LicensesCreateArgs} args - Arguments to create a Licenses.
     * @example
     * // Create one Licenses
     * const Licenses = await prisma.licenses.create({
     *   data: {
     *     // ... data to create a Licenses
     *   }
     * })
     * 
     */
    create<T extends LicensesCreateArgs>(args: SelectSubset<T, LicensesCreateArgs<ExtArgs>>): Prisma__LicensesClient<$Result.GetResult<Prisma.$LicensesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Licenses.
     * @param {LicensesCreateManyArgs} args - Arguments to create many Licenses.
     * @example
     * // Create many Licenses
     * const licenses = await prisma.licenses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LicensesCreateManyArgs>(args?: SelectSubset<T, LicensesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Licenses.
     * @param {LicensesDeleteArgs} args - Arguments to delete one Licenses.
     * @example
     * // Delete one Licenses
     * const Licenses = await prisma.licenses.delete({
     *   where: {
     *     // ... filter to delete one Licenses
     *   }
     * })
     * 
     */
    delete<T extends LicensesDeleteArgs>(args: SelectSubset<T, LicensesDeleteArgs<ExtArgs>>): Prisma__LicensesClient<$Result.GetResult<Prisma.$LicensesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Licenses.
     * @param {LicensesUpdateArgs} args - Arguments to update one Licenses.
     * @example
     * // Update one Licenses
     * const licenses = await prisma.licenses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LicensesUpdateArgs>(args: SelectSubset<T, LicensesUpdateArgs<ExtArgs>>): Prisma__LicensesClient<$Result.GetResult<Prisma.$LicensesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Licenses.
     * @param {LicensesDeleteManyArgs} args - Arguments to filter Licenses to delete.
     * @example
     * // Delete a few Licenses
     * const { count } = await prisma.licenses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LicensesDeleteManyArgs>(args?: SelectSubset<T, LicensesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Licenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicensesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Licenses
     * const licenses = await prisma.licenses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LicensesUpdateManyArgs>(args: SelectSubset<T, LicensesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Licenses.
     * @param {LicensesUpsertArgs} args - Arguments to update or create a Licenses.
     * @example
     * // Update or create a Licenses
     * const licenses = await prisma.licenses.upsert({
     *   create: {
     *     // ... data to create a Licenses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Licenses we want to update
     *   }
     * })
     */
    upsert<T extends LicensesUpsertArgs>(args: SelectSubset<T, LicensesUpsertArgs<ExtArgs>>): Prisma__LicensesClient<$Result.GetResult<Prisma.$LicensesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Licenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicensesCountArgs} args - Arguments to filter Licenses to count.
     * @example
     * // Count the number of Licenses
     * const count = await prisma.licenses.count({
     *   where: {
     *     // ... the filter for the Licenses we want to count
     *   }
     * })
    **/
    count<T extends LicensesCountArgs>(
      args?: Subset<T, LicensesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LicensesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Licenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicensesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LicensesAggregateArgs>(args: Subset<T, LicensesAggregateArgs>): Prisma.PrismaPromise<GetLicensesAggregateType<T>>

    /**
     * Group by Licenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicensesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LicensesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LicensesGroupByArgs['orderBy'] }
        : { orderBy?: LicensesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LicensesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLicensesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Licenses model
   */
  readonly fields: LicensesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Licenses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LicensesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Media<T extends Licenses$MediaArgs<ExtArgs> = {}>(args?: Subset<T, Licenses$MediaArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    LicensesLang<T extends Licenses$LicensesLangArgs<ExtArgs> = {}>(args?: Subset<T, Licenses$LicensesLangArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicensesLangPayload<ExtArgs>, T, "findMany"> | Null>
    Relations<T extends Licenses$RelationsArgs<ExtArgs> = {}>(args?: Subset<T, Licenses$RelationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Licenses model
   */ 
  interface LicensesFieldRefs {
    readonly id: FieldRef<"Licenses", 'BigInt'>
    readonly code: FieldRef<"Licenses", 'String'>
    readonly media: FieldRef<"Licenses", 'BigInt'>
    readonly enabled: FieldRef<"Licenses", 'Boolean'>
    readonly other: FieldRef<"Licenses", 'String'>
    readonly createdAt: FieldRef<"Licenses", 'DateTime'>
    readonly updatedAt: FieldRef<"Licenses", 'DateTime'>
    readonly deletedAt: FieldRef<"Licenses", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Licenses findUnique
   */
  export type LicensesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Licenses
     */
    select?: LicensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicensesInclude<ExtArgs> | null
    /**
     * Filter, which Licenses to fetch.
     */
    where: LicensesWhereUniqueInput
  }

  /**
   * Licenses findUniqueOrThrow
   */
  export type LicensesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Licenses
     */
    select?: LicensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicensesInclude<ExtArgs> | null
    /**
     * Filter, which Licenses to fetch.
     */
    where: LicensesWhereUniqueInput
  }

  /**
   * Licenses findFirst
   */
  export type LicensesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Licenses
     */
    select?: LicensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicensesInclude<ExtArgs> | null
    /**
     * Filter, which Licenses to fetch.
     */
    where?: LicensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicensesOrderByWithRelationInput | LicensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Licenses.
     */
    cursor?: LicensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Licenses.
     */
    distinct?: LicensesScalarFieldEnum | LicensesScalarFieldEnum[]
  }

  /**
   * Licenses findFirstOrThrow
   */
  export type LicensesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Licenses
     */
    select?: LicensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicensesInclude<ExtArgs> | null
    /**
     * Filter, which Licenses to fetch.
     */
    where?: LicensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicensesOrderByWithRelationInput | LicensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Licenses.
     */
    cursor?: LicensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Licenses.
     */
    distinct?: LicensesScalarFieldEnum | LicensesScalarFieldEnum[]
  }

  /**
   * Licenses findMany
   */
  export type LicensesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Licenses
     */
    select?: LicensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicensesInclude<ExtArgs> | null
    /**
     * Filter, which Licenses to fetch.
     */
    where?: LicensesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicensesOrderByWithRelationInput | LicensesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Licenses.
     */
    cursor?: LicensesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    distinct?: LicensesScalarFieldEnum | LicensesScalarFieldEnum[]
  }

  /**
   * Licenses create
   */
  export type LicensesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Licenses
     */
    select?: LicensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicensesInclude<ExtArgs> | null
    /**
     * The data needed to create a Licenses.
     */
    data: XOR<LicensesCreateInput, LicensesUncheckedCreateInput>
  }

  /**
   * Licenses createMany
   */
  export type LicensesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Licenses.
     */
    data: LicensesCreateManyInput | LicensesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Licenses update
   */
  export type LicensesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Licenses
     */
    select?: LicensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicensesInclude<ExtArgs> | null
    /**
     * The data needed to update a Licenses.
     */
    data: XOR<LicensesUpdateInput, LicensesUncheckedUpdateInput>
    /**
     * Choose, which Licenses to update.
     */
    where: LicensesWhereUniqueInput
  }

  /**
   * Licenses updateMany
   */
  export type LicensesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Licenses.
     */
    data: XOR<LicensesUpdateManyMutationInput, LicensesUncheckedUpdateManyInput>
    /**
     * Filter which Licenses to update
     */
    where?: LicensesWhereInput
  }

  /**
   * Licenses upsert
   */
  export type LicensesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Licenses
     */
    select?: LicensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicensesInclude<ExtArgs> | null
    /**
     * The filter to search for the Licenses to update in case it exists.
     */
    where: LicensesWhereUniqueInput
    /**
     * In case the Licenses found by the `where` argument doesn't exist, create a new Licenses with this data.
     */
    create: XOR<LicensesCreateInput, LicensesUncheckedCreateInput>
    /**
     * In case the Licenses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LicensesUpdateInput, LicensesUncheckedUpdateInput>
  }

  /**
   * Licenses delete
   */
  export type LicensesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Licenses
     */
    select?: LicensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicensesInclude<ExtArgs> | null
    /**
     * Filter which Licenses to delete.
     */
    where: LicensesWhereUniqueInput
  }

  /**
   * Licenses deleteMany
   */
  export type LicensesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Licenses to delete
     */
    where?: LicensesWhereInput
  }

  /**
   * Licenses.Media
   */
  export type Licenses$MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Licenses.LicensesLang
   */
  export type Licenses$LicensesLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicensesLang
     */
    select?: LicensesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicensesLangInclude<ExtArgs> | null
    where?: LicensesLangWhereInput
    orderBy?: LicensesLangOrderByWithRelationInput | LicensesLangOrderByWithRelationInput[]
    cursor?: LicensesLangWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LicensesLangScalarFieldEnum | LicensesLangScalarFieldEnum[]
  }

  /**
   * Licenses.Relations
   */
  export type Licenses$RelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relations
     */
    select?: RelationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsInclude<ExtArgs> | null
    where?: RelationsWhereInput
    orderBy?: RelationsOrderByWithRelationInput | RelationsOrderByWithRelationInput[]
    cursor?: RelationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelationsScalarFieldEnum | RelationsScalarFieldEnum[]
  }

  /**
   * Licenses without action
   */
  export type LicensesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Licenses
     */
    select?: LicensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicensesInclude<ExtArgs> | null
  }


  /**
   * Model LicensesLang
   */

  export type AggregateLicensesLang = {
    _count: LicensesLangCountAggregateOutputType | null
    _avg: LicensesLangAvgAggregateOutputType | null
    _sum: LicensesLangSumAggregateOutputType | null
    _min: LicensesLangMinAggregateOutputType | null
    _max: LicensesLangMaxAggregateOutputType | null
  }

  export type LicensesLangAvgAggregateOutputType = {
    id: number | null
    liId: number | null
    lang: number | null
    audio: number | null
  }

  export type LicensesLangSumAggregateOutputType = {
    id: bigint | null
    liId: bigint | null
    lang: bigint | null
    audio: bigint | null
  }

  export type LicensesLangMinAggregateOutputType = {
    id: bigint | null
    liId: bigint | null
    lang: bigint | null
    name: string | null
    desc: string | null
    audio: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type LicensesLangMaxAggregateOutputType = {
    id: bigint | null
    liId: bigint | null
    lang: bigint | null
    name: string | null
    desc: string | null
    audio: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type LicensesLangCountAggregateOutputType = {
    id: number
    liId: number
    lang: number
    name: number
    desc: number
    audio: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type LicensesLangAvgAggregateInputType = {
    id?: true
    liId?: true
    lang?: true
    audio?: true
  }

  export type LicensesLangSumAggregateInputType = {
    id?: true
    liId?: true
    lang?: true
    audio?: true
  }

  export type LicensesLangMinAggregateInputType = {
    id?: true
    liId?: true
    lang?: true
    name?: true
    desc?: true
    audio?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type LicensesLangMaxAggregateInputType = {
    id?: true
    liId?: true
    lang?: true
    name?: true
    desc?: true
    audio?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type LicensesLangCountAggregateInputType = {
    id?: true
    liId?: true
    lang?: true
    name?: true
    desc?: true
    audio?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type LicensesLangAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LicensesLang to aggregate.
     */
    where?: LicensesLangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LicensesLangs to fetch.
     */
    orderBy?: LicensesLangOrderByWithRelationInput | LicensesLangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LicensesLangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LicensesLangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LicensesLangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LicensesLangs
    **/
    _count?: true | LicensesLangCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LicensesLangAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LicensesLangSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LicensesLangMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LicensesLangMaxAggregateInputType
  }

  export type GetLicensesLangAggregateType<T extends LicensesLangAggregateArgs> = {
        [P in keyof T & keyof AggregateLicensesLang]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLicensesLang[P]>
      : GetScalarType<T[P], AggregateLicensesLang[P]>
  }




  export type LicensesLangGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LicensesLangWhereInput
    orderBy?: LicensesLangOrderByWithAggregationInput | LicensesLangOrderByWithAggregationInput[]
    by: LicensesLangScalarFieldEnum[] | LicensesLangScalarFieldEnum
    having?: LicensesLangScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LicensesLangCountAggregateInputType | true
    _avg?: LicensesLangAvgAggregateInputType
    _sum?: LicensesLangSumAggregateInputType
    _min?: LicensesLangMinAggregateInputType
    _max?: LicensesLangMaxAggregateInputType
  }

  export type LicensesLangGroupByOutputType = {
    id: bigint
    liId: bigint
    lang: bigint
    name: string
    desc: string | null
    audio: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: LicensesLangCountAggregateOutputType | null
    _avg: LicensesLangAvgAggregateOutputType | null
    _sum: LicensesLangSumAggregateOutputType | null
    _min: LicensesLangMinAggregateOutputType | null
    _max: LicensesLangMaxAggregateOutputType | null
  }

  type GetLicensesLangGroupByPayload<T extends LicensesLangGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LicensesLangGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LicensesLangGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LicensesLangGroupByOutputType[P]>
            : GetScalarType<T[P], LicensesLangGroupByOutputType[P]>
        }
      >
    >


  export type LicensesLangSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    liId?: boolean
    lang?: boolean
    name?: boolean
    desc?: boolean
    audio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    Licenses?: boolean | LicensesDefaultArgs<ExtArgs>
    Languages?: boolean | LanguagesDefaultArgs<ExtArgs>
    Audio?: boolean | LicensesLang$AudioArgs<ExtArgs>
  }, ExtArgs["result"]["licensesLang"]>


  export type LicensesLangSelectScalar = {
    id?: boolean
    liId?: boolean
    lang?: boolean
    name?: boolean
    desc?: boolean
    audio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type LicensesLangInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Licenses?: boolean | LicensesDefaultArgs<ExtArgs>
    Languages?: boolean | LanguagesDefaultArgs<ExtArgs>
    Audio?: boolean | LicensesLang$AudioArgs<ExtArgs>
  }

  export type $LicensesLangPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LicensesLang"
    objects: {
      Licenses: Prisma.$LicensesPayload<ExtArgs>
      Languages: Prisma.$LanguagesPayload<ExtArgs>
      Audio: Prisma.$AudioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      liId: bigint
      lang: bigint
      name: string
      desc: string | null
      audio: bigint | null
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["licensesLang"]>
    composites: {}
  }

  type LicensesLangGetPayload<S extends boolean | null | undefined | LicensesLangDefaultArgs> = $Result.GetResult<Prisma.$LicensesLangPayload, S>

  type LicensesLangCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LicensesLangFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LicensesLangCountAggregateInputType | true
    }

  export interface LicensesLangDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LicensesLang'], meta: { name: 'LicensesLang' } }
    /**
     * Find zero or one LicensesLang that matches the filter.
     * @param {LicensesLangFindUniqueArgs} args - Arguments to find a LicensesLang
     * @example
     * // Get one LicensesLang
     * const licensesLang = await prisma.licensesLang.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LicensesLangFindUniqueArgs>(args: SelectSubset<T, LicensesLangFindUniqueArgs<ExtArgs>>): Prisma__LicensesLangClient<$Result.GetResult<Prisma.$LicensesLangPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LicensesLang that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LicensesLangFindUniqueOrThrowArgs} args - Arguments to find a LicensesLang
     * @example
     * // Get one LicensesLang
     * const licensesLang = await prisma.licensesLang.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LicensesLangFindUniqueOrThrowArgs>(args: SelectSubset<T, LicensesLangFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LicensesLangClient<$Result.GetResult<Prisma.$LicensesLangPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LicensesLang that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicensesLangFindFirstArgs} args - Arguments to find a LicensesLang
     * @example
     * // Get one LicensesLang
     * const licensesLang = await prisma.licensesLang.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LicensesLangFindFirstArgs>(args?: SelectSubset<T, LicensesLangFindFirstArgs<ExtArgs>>): Prisma__LicensesLangClient<$Result.GetResult<Prisma.$LicensesLangPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LicensesLang that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicensesLangFindFirstOrThrowArgs} args - Arguments to find a LicensesLang
     * @example
     * // Get one LicensesLang
     * const licensesLang = await prisma.licensesLang.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LicensesLangFindFirstOrThrowArgs>(args?: SelectSubset<T, LicensesLangFindFirstOrThrowArgs<ExtArgs>>): Prisma__LicensesLangClient<$Result.GetResult<Prisma.$LicensesLangPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LicensesLangs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicensesLangFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LicensesLangs
     * const licensesLangs = await prisma.licensesLang.findMany()
     * 
     * // Get first 10 LicensesLangs
     * const licensesLangs = await prisma.licensesLang.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const licensesLangWithIdOnly = await prisma.licensesLang.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LicensesLangFindManyArgs>(args?: SelectSubset<T, LicensesLangFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicensesLangPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LicensesLang.
     * @param {LicensesLangCreateArgs} args - Arguments to create a LicensesLang.
     * @example
     * // Create one LicensesLang
     * const LicensesLang = await prisma.licensesLang.create({
     *   data: {
     *     // ... data to create a LicensesLang
     *   }
     * })
     * 
     */
    create<T extends LicensesLangCreateArgs>(args: SelectSubset<T, LicensesLangCreateArgs<ExtArgs>>): Prisma__LicensesLangClient<$Result.GetResult<Prisma.$LicensesLangPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LicensesLangs.
     * @param {LicensesLangCreateManyArgs} args - Arguments to create many LicensesLangs.
     * @example
     * // Create many LicensesLangs
     * const licensesLang = await prisma.licensesLang.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LicensesLangCreateManyArgs>(args?: SelectSubset<T, LicensesLangCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LicensesLang.
     * @param {LicensesLangDeleteArgs} args - Arguments to delete one LicensesLang.
     * @example
     * // Delete one LicensesLang
     * const LicensesLang = await prisma.licensesLang.delete({
     *   where: {
     *     // ... filter to delete one LicensesLang
     *   }
     * })
     * 
     */
    delete<T extends LicensesLangDeleteArgs>(args: SelectSubset<T, LicensesLangDeleteArgs<ExtArgs>>): Prisma__LicensesLangClient<$Result.GetResult<Prisma.$LicensesLangPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LicensesLang.
     * @param {LicensesLangUpdateArgs} args - Arguments to update one LicensesLang.
     * @example
     * // Update one LicensesLang
     * const licensesLang = await prisma.licensesLang.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LicensesLangUpdateArgs>(args: SelectSubset<T, LicensesLangUpdateArgs<ExtArgs>>): Prisma__LicensesLangClient<$Result.GetResult<Prisma.$LicensesLangPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LicensesLangs.
     * @param {LicensesLangDeleteManyArgs} args - Arguments to filter LicensesLangs to delete.
     * @example
     * // Delete a few LicensesLangs
     * const { count } = await prisma.licensesLang.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LicensesLangDeleteManyArgs>(args?: SelectSubset<T, LicensesLangDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LicensesLangs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicensesLangUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LicensesLangs
     * const licensesLang = await prisma.licensesLang.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LicensesLangUpdateManyArgs>(args: SelectSubset<T, LicensesLangUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LicensesLang.
     * @param {LicensesLangUpsertArgs} args - Arguments to update or create a LicensesLang.
     * @example
     * // Update or create a LicensesLang
     * const licensesLang = await prisma.licensesLang.upsert({
     *   create: {
     *     // ... data to create a LicensesLang
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LicensesLang we want to update
     *   }
     * })
     */
    upsert<T extends LicensesLangUpsertArgs>(args: SelectSubset<T, LicensesLangUpsertArgs<ExtArgs>>): Prisma__LicensesLangClient<$Result.GetResult<Prisma.$LicensesLangPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LicensesLangs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicensesLangCountArgs} args - Arguments to filter LicensesLangs to count.
     * @example
     * // Count the number of LicensesLangs
     * const count = await prisma.licensesLang.count({
     *   where: {
     *     // ... the filter for the LicensesLangs we want to count
     *   }
     * })
    **/
    count<T extends LicensesLangCountArgs>(
      args?: Subset<T, LicensesLangCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LicensesLangCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LicensesLang.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicensesLangAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LicensesLangAggregateArgs>(args: Subset<T, LicensesLangAggregateArgs>): Prisma.PrismaPromise<GetLicensesLangAggregateType<T>>

    /**
     * Group by LicensesLang.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicensesLangGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LicensesLangGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LicensesLangGroupByArgs['orderBy'] }
        : { orderBy?: LicensesLangGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LicensesLangGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLicensesLangGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LicensesLang model
   */
  readonly fields: LicensesLangFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LicensesLang.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LicensesLangClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Licenses<T extends LicensesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LicensesDefaultArgs<ExtArgs>>): Prisma__LicensesClient<$Result.GetResult<Prisma.$LicensesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Languages<T extends LanguagesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguagesDefaultArgs<ExtArgs>>): Prisma__LanguagesClient<$Result.GetResult<Prisma.$LanguagesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Audio<T extends LicensesLang$AudioArgs<ExtArgs> = {}>(args?: Subset<T, LicensesLang$AudioArgs<ExtArgs>>): Prisma__AudioClient<$Result.GetResult<Prisma.$AudioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LicensesLang model
   */ 
  interface LicensesLangFieldRefs {
    readonly id: FieldRef<"LicensesLang", 'BigInt'>
    readonly liId: FieldRef<"LicensesLang", 'BigInt'>
    readonly lang: FieldRef<"LicensesLang", 'BigInt'>
    readonly name: FieldRef<"LicensesLang", 'String'>
    readonly desc: FieldRef<"LicensesLang", 'String'>
    readonly audio: FieldRef<"LicensesLang", 'BigInt'>
    readonly createdAt: FieldRef<"LicensesLang", 'DateTime'>
    readonly updatedAt: FieldRef<"LicensesLang", 'DateTime'>
    readonly deletedAt: FieldRef<"LicensesLang", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LicensesLang findUnique
   */
  export type LicensesLangFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicensesLang
     */
    select?: LicensesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicensesLangInclude<ExtArgs> | null
    /**
     * Filter, which LicensesLang to fetch.
     */
    where: LicensesLangWhereUniqueInput
  }

  /**
   * LicensesLang findUniqueOrThrow
   */
  export type LicensesLangFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicensesLang
     */
    select?: LicensesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicensesLangInclude<ExtArgs> | null
    /**
     * Filter, which LicensesLang to fetch.
     */
    where: LicensesLangWhereUniqueInput
  }

  /**
   * LicensesLang findFirst
   */
  export type LicensesLangFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicensesLang
     */
    select?: LicensesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicensesLangInclude<ExtArgs> | null
    /**
     * Filter, which LicensesLang to fetch.
     */
    where?: LicensesLangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LicensesLangs to fetch.
     */
    orderBy?: LicensesLangOrderByWithRelationInput | LicensesLangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LicensesLangs.
     */
    cursor?: LicensesLangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LicensesLangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LicensesLangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LicensesLangs.
     */
    distinct?: LicensesLangScalarFieldEnum | LicensesLangScalarFieldEnum[]
  }

  /**
   * LicensesLang findFirstOrThrow
   */
  export type LicensesLangFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicensesLang
     */
    select?: LicensesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicensesLangInclude<ExtArgs> | null
    /**
     * Filter, which LicensesLang to fetch.
     */
    where?: LicensesLangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LicensesLangs to fetch.
     */
    orderBy?: LicensesLangOrderByWithRelationInput | LicensesLangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LicensesLangs.
     */
    cursor?: LicensesLangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LicensesLangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LicensesLangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LicensesLangs.
     */
    distinct?: LicensesLangScalarFieldEnum | LicensesLangScalarFieldEnum[]
  }

  /**
   * LicensesLang findMany
   */
  export type LicensesLangFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicensesLang
     */
    select?: LicensesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicensesLangInclude<ExtArgs> | null
    /**
     * Filter, which LicensesLangs to fetch.
     */
    where?: LicensesLangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LicensesLangs to fetch.
     */
    orderBy?: LicensesLangOrderByWithRelationInput | LicensesLangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LicensesLangs.
     */
    cursor?: LicensesLangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LicensesLangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LicensesLangs.
     */
    skip?: number
    distinct?: LicensesLangScalarFieldEnum | LicensesLangScalarFieldEnum[]
  }

  /**
   * LicensesLang create
   */
  export type LicensesLangCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicensesLang
     */
    select?: LicensesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicensesLangInclude<ExtArgs> | null
    /**
     * The data needed to create a LicensesLang.
     */
    data: XOR<LicensesLangCreateInput, LicensesLangUncheckedCreateInput>
  }

  /**
   * LicensesLang createMany
   */
  export type LicensesLangCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LicensesLangs.
     */
    data: LicensesLangCreateManyInput | LicensesLangCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LicensesLang update
   */
  export type LicensesLangUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicensesLang
     */
    select?: LicensesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicensesLangInclude<ExtArgs> | null
    /**
     * The data needed to update a LicensesLang.
     */
    data: XOR<LicensesLangUpdateInput, LicensesLangUncheckedUpdateInput>
    /**
     * Choose, which LicensesLang to update.
     */
    where: LicensesLangWhereUniqueInput
  }

  /**
   * LicensesLang updateMany
   */
  export type LicensesLangUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LicensesLangs.
     */
    data: XOR<LicensesLangUpdateManyMutationInput, LicensesLangUncheckedUpdateManyInput>
    /**
     * Filter which LicensesLangs to update
     */
    where?: LicensesLangWhereInput
  }

  /**
   * LicensesLang upsert
   */
  export type LicensesLangUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicensesLang
     */
    select?: LicensesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicensesLangInclude<ExtArgs> | null
    /**
     * The filter to search for the LicensesLang to update in case it exists.
     */
    where: LicensesLangWhereUniqueInput
    /**
     * In case the LicensesLang found by the `where` argument doesn't exist, create a new LicensesLang with this data.
     */
    create: XOR<LicensesLangCreateInput, LicensesLangUncheckedCreateInput>
    /**
     * In case the LicensesLang was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LicensesLangUpdateInput, LicensesLangUncheckedUpdateInput>
  }

  /**
   * LicensesLang delete
   */
  export type LicensesLangDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicensesLang
     */
    select?: LicensesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicensesLangInclude<ExtArgs> | null
    /**
     * Filter which LicensesLang to delete.
     */
    where: LicensesLangWhereUniqueInput
  }

  /**
   * LicensesLang deleteMany
   */
  export type LicensesLangDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LicensesLangs to delete
     */
    where?: LicensesLangWhereInput
  }

  /**
   * LicensesLang.Audio
   */
  export type LicensesLang$AudioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audio
     */
    select?: AudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioInclude<ExtArgs> | null
    where?: AudioWhereInput
  }

  /**
   * LicensesLang without action
   */
  export type LicensesLangDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LicensesLang
     */
    select?: LicensesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicensesLangInclude<ExtArgs> | null
  }


  /**
   * Model Media
   */

  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaAvgAggregateOutputType = {
    id: number | null
  }

  export type MediaSumAggregateOutputType = {
    id: bigint | null
  }

  export type MediaMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    extension: string | null
    url: string | null
    uploadedName: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type MediaMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    extension: string | null
    url: string | null
    uploadedName: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    name: number
    extension: number
    url: number
    uploadedName: number
    enabled: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type MediaAvgAggregateInputType = {
    id?: true
  }

  export type MediaSumAggregateInputType = {
    id?: true
  }

  export type MediaMinAggregateInputType = {
    id?: true
    name?: true
    extension?: true
    url?: true
    uploadedName?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    name?: true
    extension?: true
    url?: true
    uploadedName?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    name?: true
    extension?: true
    url?: true
    uploadedName?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type MediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to aggregate.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithAggregationInput | MediaOrderByWithAggregationInput[]
    by: MediaScalarFieldEnum[] | MediaScalarFieldEnum
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _avg?: MediaAvgAggregateInputType
    _sum?: MediaSumAggregateInputType
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }

  export type MediaGroupByOutputType = {
    id: bigint
    name: string
    extension: string
    url: string
    uploadedName: string
    enabled: boolean
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type MediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    extension?: boolean
    url?: boolean
    uploadedName?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    Groups?: boolean | Media$GroupsArgs<ExtArgs>
    Licenses?: boolean | Media$LicensesArgs<ExtArgs>
    RelationsChoices?: boolean | Media$RelationsChoicesArgs<ExtArgs>
    RelationsQuestions?: boolean | Media$RelationsQuestionsArgs<ExtArgs>
    Quizzes?: boolean | Media$QuizzesArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>


  export type MediaSelectScalar = {
    id?: boolean
    name?: boolean
    extension?: boolean
    url?: boolean
    uploadedName?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type MediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Groups?: boolean | Media$GroupsArgs<ExtArgs>
    Licenses?: boolean | Media$LicensesArgs<ExtArgs>
    RelationsChoices?: boolean | Media$RelationsChoicesArgs<ExtArgs>
    RelationsQuestions?: boolean | Media$RelationsQuestionsArgs<ExtArgs>
    Quizzes?: boolean | Media$QuizzesArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Media"
    objects: {
      Groups: Prisma.$GroupsPayload<ExtArgs>[]
      Licenses: Prisma.$LicensesPayload<ExtArgs>[]
      RelationsChoices: Prisma.$RelationsChoicesPayload<ExtArgs>[]
      RelationsQuestions: Prisma.$RelationsQuestionsPayload<ExtArgs>[]
      Quizzes: Prisma.$QuizzesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      extension: string
      url: string
      uploadedName: string
      enabled: boolean
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["media"]>
    composites: {}
  }

  type MediaGetPayload<S extends boolean | null | undefined | MediaDefaultArgs> = $Result.GetResult<Prisma.$MediaPayload, S>

  type MediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MediaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MediaCountAggregateInputType | true
    }

  export interface MediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Media'], meta: { name: 'Media' } }
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFindUniqueArgs>(args: SelectSubset<T, MediaFindUniqueArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Media that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MediaFindUniqueOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFindFirstArgs>(args?: SelectSubset<T, MediaFindFirstArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFindManyArgs>(args?: SelectSubset<T, MediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
     */
    create<T extends MediaCreateArgs>(args: SelectSubset<T, MediaCreateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Media.
     * @param {MediaCreateManyArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaCreateManyArgs>(args?: SelectSubset<T, MediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
     */
    delete<T extends MediaDeleteArgs>(args: SelectSubset<T, MediaDeleteArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaUpdateArgs>(args: SelectSubset<T, MediaUpdateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaDeleteManyArgs>(args?: SelectSubset<T, MediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaUpdateManyArgs>(args: SelectSubset<T, MediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
     */
    upsert<T extends MediaUpsertArgs>(args: SelectSubset<T, MediaUpsertArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): Prisma.PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Media model
   */
  readonly fields: MediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Groups<T extends Media$GroupsArgs<ExtArgs> = {}>(args?: Subset<T, Media$GroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "findMany"> | Null>
    Licenses<T extends Media$LicensesArgs<ExtArgs> = {}>(args?: Subset<T, Media$LicensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicensesPayload<ExtArgs>, T, "findMany"> | Null>
    RelationsChoices<T extends Media$RelationsChoicesArgs<ExtArgs> = {}>(args?: Subset<T, Media$RelationsChoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationsChoicesPayload<ExtArgs>, T, "findMany"> | Null>
    RelationsQuestions<T extends Media$RelationsQuestionsArgs<ExtArgs> = {}>(args?: Subset<T, Media$RelationsQuestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationsQuestionsPayload<ExtArgs>, T, "findMany"> | Null>
    Quizzes<T extends Media$QuizzesArgs<ExtArgs> = {}>(args?: Subset<T, Media$QuizzesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizzesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Media model
   */ 
  interface MediaFieldRefs {
    readonly id: FieldRef<"Media", 'BigInt'>
    readonly name: FieldRef<"Media", 'String'>
    readonly extension: FieldRef<"Media", 'String'>
    readonly url: FieldRef<"Media", 'String'>
    readonly uploadedName: FieldRef<"Media", 'String'>
    readonly enabled: FieldRef<"Media", 'Boolean'>
    readonly createdAt: FieldRef<"Media", 'DateTime'>
    readonly updatedAt: FieldRef<"Media", 'DateTime'>
    readonly deletedAt: FieldRef<"Media", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findUniqueOrThrow
   */
  export type MediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findFirstOrThrow
   */
  export type MediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findMany
   */
  export type MediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media create
   */
  export type MediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to create a Media.
     */
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
  }

  /**
   * Media createMany
   */
  export type MediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media update
   */
  export type MediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to update a Media.
     */
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
  }

  /**
   * Media upsert
   */
  export type MediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The filter to search for the Media to update in case it exists.
     */
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
     */
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
  }

  /**
   * Media delete
   */
  export type MediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter which Media to delete.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to delete
     */
    where?: MediaWhereInput
  }

  /**
   * Media.Groups
   */
  export type Media$GroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Groups
     */
    select?: GroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GroupsInclude<ExtArgs> | null
    where?: GroupsWhereInput
    orderBy?: GroupsOrderByWithRelationInput | GroupsOrderByWithRelationInput[]
    cursor?: GroupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GroupsScalarFieldEnum | GroupsScalarFieldEnum[]
  }

  /**
   * Media.Licenses
   */
  export type Media$LicensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Licenses
     */
    select?: LicensesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicensesInclude<ExtArgs> | null
    where?: LicensesWhereInput
    orderBy?: LicensesOrderByWithRelationInput | LicensesOrderByWithRelationInput[]
    cursor?: LicensesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LicensesScalarFieldEnum | LicensesScalarFieldEnum[]
  }

  /**
   * Media.RelationsChoices
   */
  export type Media$RelationsChoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsChoices
     */
    select?: RelationsChoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsChoicesInclude<ExtArgs> | null
    where?: RelationsChoicesWhereInput
    orderBy?: RelationsChoicesOrderByWithRelationInput | RelationsChoicesOrderByWithRelationInput[]
    cursor?: RelationsChoicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelationsChoicesScalarFieldEnum | RelationsChoicesScalarFieldEnum[]
  }

  /**
   * Media.RelationsQuestions
   */
  export type Media$RelationsQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsQuestions
     */
    select?: RelationsQuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsQuestionsInclude<ExtArgs> | null
    where?: RelationsQuestionsWhereInput
    orderBy?: RelationsQuestionsOrderByWithRelationInput | RelationsQuestionsOrderByWithRelationInput[]
    cursor?: RelationsQuestionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelationsQuestionsScalarFieldEnum | RelationsQuestionsScalarFieldEnum[]
  }

  /**
   * Media.Quizzes
   */
  export type Media$QuizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quizzes
     */
    select?: QuizzesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizzesInclude<ExtArgs> | null
    where?: QuizzesWhereInput
    orderBy?: QuizzesOrderByWithRelationInput | QuizzesOrderByWithRelationInput[]
    cursor?: QuizzesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizzesScalarFieldEnum | QuizzesScalarFieldEnum[]
  }

  /**
   * Media without action
   */
  export type MediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
  }


  /**
   * Model Migrations
   */

  export type AggregateMigrations = {
    _count: MigrationsCountAggregateOutputType | null
    _avg: MigrationsAvgAggregateOutputType | null
    _sum: MigrationsSumAggregateOutputType | null
    _min: MigrationsMinAggregateOutputType | null
    _max: MigrationsMaxAggregateOutputType | null
  }

  export type MigrationsAvgAggregateOutputType = {
    id: number | null
    batch: number | null
  }

  export type MigrationsSumAggregateOutputType = {
    id: number | null
    batch: number | null
  }

  export type MigrationsMinAggregateOutputType = {
    id: number | null
    migration: string | null
    batch: number | null
  }

  export type MigrationsMaxAggregateOutputType = {
    id: number | null
    migration: string | null
    batch: number | null
  }

  export type MigrationsCountAggregateOutputType = {
    id: number
    migration: number
    batch: number
    _all: number
  }


  export type MigrationsAvgAggregateInputType = {
    id?: true
    batch?: true
  }

  export type MigrationsSumAggregateInputType = {
    id?: true
    batch?: true
  }

  export type MigrationsMinAggregateInputType = {
    id?: true
    migration?: true
    batch?: true
  }

  export type MigrationsMaxAggregateInputType = {
    id?: true
    migration?: true
    batch?: true
  }

  export type MigrationsCountAggregateInputType = {
    id?: true
    migration?: true
    batch?: true
    _all?: true
  }

  export type MigrationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Migrations to aggregate.
     */
    where?: MigrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Migrations to fetch.
     */
    orderBy?: MigrationsOrderByWithRelationInput | MigrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MigrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Migrations
    **/
    _count?: true | MigrationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MigrationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MigrationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MigrationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MigrationsMaxAggregateInputType
  }

  export type GetMigrationsAggregateType<T extends MigrationsAggregateArgs> = {
        [P in keyof T & keyof AggregateMigrations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMigrations[P]>
      : GetScalarType<T[P], AggregateMigrations[P]>
  }




  export type MigrationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MigrationsWhereInput
    orderBy?: MigrationsOrderByWithAggregationInput | MigrationsOrderByWithAggregationInput[]
    by: MigrationsScalarFieldEnum[] | MigrationsScalarFieldEnum
    having?: MigrationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MigrationsCountAggregateInputType | true
    _avg?: MigrationsAvgAggregateInputType
    _sum?: MigrationsSumAggregateInputType
    _min?: MigrationsMinAggregateInputType
    _max?: MigrationsMaxAggregateInputType
  }

  export type MigrationsGroupByOutputType = {
    id: number
    migration: string
    batch: number
    _count: MigrationsCountAggregateOutputType | null
    _avg: MigrationsAvgAggregateOutputType | null
    _sum: MigrationsSumAggregateOutputType | null
    _min: MigrationsMinAggregateOutputType | null
    _max: MigrationsMaxAggregateOutputType | null
  }

  type GetMigrationsGroupByPayload<T extends MigrationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MigrationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MigrationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MigrationsGroupByOutputType[P]>
            : GetScalarType<T[P], MigrationsGroupByOutputType[P]>
        }
      >
    >


  export type MigrationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    migration?: boolean
    batch?: boolean
  }, ExtArgs["result"]["migrations"]>


  export type MigrationsSelectScalar = {
    id?: boolean
    migration?: boolean
    batch?: boolean
  }


  export type $MigrationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Migrations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      migration: string
      batch: number
    }, ExtArgs["result"]["migrations"]>
    composites: {}
  }

  type MigrationsGetPayload<S extends boolean | null | undefined | MigrationsDefaultArgs> = $Result.GetResult<Prisma.$MigrationsPayload, S>

  type MigrationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MigrationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MigrationsCountAggregateInputType | true
    }

  export interface MigrationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Migrations'], meta: { name: 'Migrations' } }
    /**
     * Find zero or one Migrations that matches the filter.
     * @param {MigrationsFindUniqueArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MigrationsFindUniqueArgs>(args: SelectSubset<T, MigrationsFindUniqueArgs<ExtArgs>>): Prisma__MigrationsClient<$Result.GetResult<Prisma.$MigrationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Migrations that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MigrationsFindUniqueOrThrowArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MigrationsFindUniqueOrThrowArgs>(args: SelectSubset<T, MigrationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MigrationsClient<$Result.GetResult<Prisma.$MigrationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationsFindFirstArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MigrationsFindFirstArgs>(args?: SelectSubset<T, MigrationsFindFirstArgs<ExtArgs>>): Prisma__MigrationsClient<$Result.GetResult<Prisma.$MigrationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Migrations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationsFindFirstOrThrowArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MigrationsFindFirstOrThrowArgs>(args?: SelectSubset<T, MigrationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__MigrationsClient<$Result.GetResult<Prisma.$MigrationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Migrations
     * const migrations = await prisma.migrations.findMany()
     * 
     * // Get first 10 Migrations
     * const migrations = await prisma.migrations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const migrationsWithIdOnly = await prisma.migrations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MigrationsFindManyArgs>(args?: SelectSubset<T, MigrationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MigrationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Migrations.
     * @param {MigrationsCreateArgs} args - Arguments to create a Migrations.
     * @example
     * // Create one Migrations
     * const Migrations = await prisma.migrations.create({
     *   data: {
     *     // ... data to create a Migrations
     *   }
     * })
     * 
     */
    create<T extends MigrationsCreateArgs>(args: SelectSubset<T, MigrationsCreateArgs<ExtArgs>>): Prisma__MigrationsClient<$Result.GetResult<Prisma.$MigrationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Migrations.
     * @param {MigrationsCreateManyArgs} args - Arguments to create many Migrations.
     * @example
     * // Create many Migrations
     * const migrations = await prisma.migrations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MigrationsCreateManyArgs>(args?: SelectSubset<T, MigrationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Migrations.
     * @param {MigrationsDeleteArgs} args - Arguments to delete one Migrations.
     * @example
     * // Delete one Migrations
     * const Migrations = await prisma.migrations.delete({
     *   where: {
     *     // ... filter to delete one Migrations
     *   }
     * })
     * 
     */
    delete<T extends MigrationsDeleteArgs>(args: SelectSubset<T, MigrationsDeleteArgs<ExtArgs>>): Prisma__MigrationsClient<$Result.GetResult<Prisma.$MigrationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Migrations.
     * @param {MigrationsUpdateArgs} args - Arguments to update one Migrations.
     * @example
     * // Update one Migrations
     * const migrations = await prisma.migrations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MigrationsUpdateArgs>(args: SelectSubset<T, MigrationsUpdateArgs<ExtArgs>>): Prisma__MigrationsClient<$Result.GetResult<Prisma.$MigrationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Migrations.
     * @param {MigrationsDeleteManyArgs} args - Arguments to filter Migrations to delete.
     * @example
     * // Delete a few Migrations
     * const { count } = await prisma.migrations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MigrationsDeleteManyArgs>(args?: SelectSubset<T, MigrationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Migrations
     * const migrations = await prisma.migrations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MigrationsUpdateManyArgs>(args: SelectSubset<T, MigrationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Migrations.
     * @param {MigrationsUpsertArgs} args - Arguments to update or create a Migrations.
     * @example
     * // Update or create a Migrations
     * const migrations = await prisma.migrations.upsert({
     *   create: {
     *     // ... data to create a Migrations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Migrations we want to update
     *   }
     * })
     */
    upsert<T extends MigrationsUpsertArgs>(args: SelectSubset<T, MigrationsUpsertArgs<ExtArgs>>): Prisma__MigrationsClient<$Result.GetResult<Prisma.$MigrationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationsCountArgs} args - Arguments to filter Migrations to count.
     * @example
     * // Count the number of Migrations
     * const count = await prisma.migrations.count({
     *   where: {
     *     // ... the filter for the Migrations we want to count
     *   }
     * })
    **/
    count<T extends MigrationsCountArgs>(
      args?: Subset<T, MigrationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MigrationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MigrationsAggregateArgs>(args: Subset<T, MigrationsAggregateArgs>): Prisma.PrismaPromise<GetMigrationsAggregateType<T>>

    /**
     * Group by Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MigrationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MigrationsGroupByArgs['orderBy'] }
        : { orderBy?: MigrationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MigrationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMigrationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Migrations model
   */
  readonly fields: MigrationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Migrations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MigrationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Migrations model
   */ 
  interface MigrationsFieldRefs {
    readonly id: FieldRef<"Migrations", 'Int'>
    readonly migration: FieldRef<"Migrations", 'String'>
    readonly batch: FieldRef<"Migrations", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Migrations findUnique
   */
  export type MigrationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Migrations
     */
    select?: MigrationsSelect<ExtArgs> | null
    /**
     * Filter, which Migrations to fetch.
     */
    where: MigrationsWhereUniqueInput
  }

  /**
   * Migrations findUniqueOrThrow
   */
  export type MigrationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Migrations
     */
    select?: MigrationsSelect<ExtArgs> | null
    /**
     * Filter, which Migrations to fetch.
     */
    where: MigrationsWhereUniqueInput
  }

  /**
   * Migrations findFirst
   */
  export type MigrationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Migrations
     */
    select?: MigrationsSelect<ExtArgs> | null
    /**
     * Filter, which Migrations to fetch.
     */
    where?: MigrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Migrations to fetch.
     */
    orderBy?: MigrationsOrderByWithRelationInput | MigrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Migrations.
     */
    cursor?: MigrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Migrations.
     */
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }

  /**
   * Migrations findFirstOrThrow
   */
  export type MigrationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Migrations
     */
    select?: MigrationsSelect<ExtArgs> | null
    /**
     * Filter, which Migrations to fetch.
     */
    where?: MigrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Migrations to fetch.
     */
    orderBy?: MigrationsOrderByWithRelationInput | MigrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Migrations.
     */
    cursor?: MigrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Migrations.
     */
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }

  /**
   * Migrations findMany
   */
  export type MigrationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Migrations
     */
    select?: MigrationsSelect<ExtArgs> | null
    /**
     * Filter, which Migrations to fetch.
     */
    where?: MigrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Migrations to fetch.
     */
    orderBy?: MigrationsOrderByWithRelationInput | MigrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Migrations.
     */
    cursor?: MigrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Migrations.
     */
    skip?: number
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }

  /**
   * Migrations create
   */
  export type MigrationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Migrations
     */
    select?: MigrationsSelect<ExtArgs> | null
    /**
     * The data needed to create a Migrations.
     */
    data: XOR<MigrationsCreateInput, MigrationsUncheckedCreateInput>
  }

  /**
   * Migrations createMany
   */
  export type MigrationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Migrations.
     */
    data: MigrationsCreateManyInput | MigrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Migrations update
   */
  export type MigrationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Migrations
     */
    select?: MigrationsSelect<ExtArgs> | null
    /**
     * The data needed to update a Migrations.
     */
    data: XOR<MigrationsUpdateInput, MigrationsUncheckedUpdateInput>
    /**
     * Choose, which Migrations to update.
     */
    where: MigrationsWhereUniqueInput
  }

  /**
   * Migrations updateMany
   */
  export type MigrationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Migrations.
     */
    data: XOR<MigrationsUpdateManyMutationInput, MigrationsUncheckedUpdateManyInput>
    /**
     * Filter which Migrations to update
     */
    where?: MigrationsWhereInput
  }

  /**
   * Migrations upsert
   */
  export type MigrationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Migrations
     */
    select?: MigrationsSelect<ExtArgs> | null
    /**
     * The filter to search for the Migrations to update in case it exists.
     */
    where: MigrationsWhereUniqueInput
    /**
     * In case the Migrations found by the `where` argument doesn't exist, create a new Migrations with this data.
     */
    create: XOR<MigrationsCreateInput, MigrationsUncheckedCreateInput>
    /**
     * In case the Migrations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MigrationsUpdateInput, MigrationsUncheckedUpdateInput>
  }

  /**
   * Migrations delete
   */
  export type MigrationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Migrations
     */
    select?: MigrationsSelect<ExtArgs> | null
    /**
     * Filter which Migrations to delete.
     */
    where: MigrationsWhereUniqueInput
  }

  /**
   * Migrations deleteMany
   */
  export type MigrationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Migrations to delete
     */
    where?: MigrationsWhereInput
  }

  /**
   * Migrations without action
   */
  export type MigrationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Migrations
     */
    select?: MigrationsSelect<ExtArgs> | null
  }


  /**
   * Model PasswordResets
   */

  export type AggregatePasswordResets = {
    _count: PasswordResetsCountAggregateOutputType | null
    _min: PasswordResetsMinAggregateOutputType | null
    _max: PasswordResetsMaxAggregateOutputType | null
  }

  export type PasswordResetsMinAggregateOutputType = {
    email: string | null
    token: string | null
    createdAt: Date | null
  }

  export type PasswordResetsMaxAggregateOutputType = {
    email: string | null
    token: string | null
    createdAt: Date | null
  }

  export type PasswordResetsCountAggregateOutputType = {
    email: number
    token: number
    createdAt: number
    _all: number
  }


  export type PasswordResetsMinAggregateInputType = {
    email?: true
    token?: true
    createdAt?: true
  }

  export type PasswordResetsMaxAggregateInputType = {
    email?: true
    token?: true
    createdAt?: true
  }

  export type PasswordResetsCountAggregateInputType = {
    email?: true
    token?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordResetsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResets to aggregate.
     */
    where?: PasswordResetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetsOrderByWithRelationInput | PasswordResetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResets
    **/
    _count?: true | PasswordResetsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetsMaxAggregateInputType
  }

  export type GetPasswordResetsAggregateType<T extends PasswordResetsAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResets[P]>
      : GetScalarType<T[P], AggregatePasswordResets[P]>
  }




  export type PasswordResetsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetsWhereInput
    orderBy?: PasswordResetsOrderByWithAggregationInput | PasswordResetsOrderByWithAggregationInput[]
    by: PasswordResetsScalarFieldEnum[] | PasswordResetsScalarFieldEnum
    having?: PasswordResetsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetsCountAggregateInputType | true
    _min?: PasswordResetsMinAggregateInputType
    _max?: PasswordResetsMaxAggregateInputType
  }

  export type PasswordResetsGroupByOutputType = {
    email: string
    token: string
    createdAt: Date | null
    _count: PasswordResetsCountAggregateOutputType | null
    _min: PasswordResetsMinAggregateOutputType | null
    _max: PasswordResetsMaxAggregateOutputType | null
  }

  type GetPasswordResetsGroupByPayload<T extends PasswordResetsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetsGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetsGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    token?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["passwordResets"]>


  export type PasswordResetsSelectScalar = {
    email?: boolean
    token?: boolean
    createdAt?: boolean
  }


  export type $PasswordResetsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResets"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      email: string
      token: string
      createdAt: Date | null
    }, ExtArgs["result"]["passwordResets"]>
    composites: {}
  }

  type PasswordResetsGetPayload<S extends boolean | null | undefined | PasswordResetsDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetsPayload, S>

  type PasswordResetsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PasswordResetsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PasswordResetsCountAggregateInputType | true
    }

  export interface PasswordResetsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResets'], meta: { name: 'PasswordResets' } }
    /**
     * Find zero or one PasswordResets that matches the filter.
     * @param {PasswordResetsFindUniqueArgs} args - Arguments to find a PasswordResets
     * @example
     * // Get one PasswordResets
     * const passwordResets = await prisma.passwordResets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetsFindUniqueArgs>(args: SelectSubset<T, PasswordResetsFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetsClient<$Result.GetResult<Prisma.$PasswordResetsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PasswordResets that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PasswordResetsFindUniqueOrThrowArgs} args - Arguments to find a PasswordResets
     * @example
     * // Get one PasswordResets
     * const passwordResets = await prisma.passwordResets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetsFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetsClient<$Result.GetResult<Prisma.$PasswordResetsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PasswordResets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetsFindFirstArgs} args - Arguments to find a PasswordResets
     * @example
     * // Get one PasswordResets
     * const passwordResets = await prisma.passwordResets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetsFindFirstArgs>(args?: SelectSubset<T, PasswordResetsFindFirstArgs<ExtArgs>>): Prisma__PasswordResetsClient<$Result.GetResult<Prisma.$PasswordResetsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PasswordResets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetsFindFirstOrThrowArgs} args - Arguments to find a PasswordResets
     * @example
     * // Get one PasswordResets
     * const passwordResets = await prisma.passwordResets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetsFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetsClient<$Result.GetResult<Prisma.$PasswordResetsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PasswordResets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResets
     * const passwordResets = await prisma.passwordResets.findMany()
     * 
     * // Get first 10 PasswordResets
     * const passwordResets = await prisma.passwordResets.findMany({ take: 10 })
     * 
     * // Only select the `email`
     * const passwordResetsWithEmailOnly = await prisma.passwordResets.findMany({ select: { email: true } })
     * 
     */
    findMany<T extends PasswordResetsFindManyArgs>(args?: SelectSubset<T, PasswordResetsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PasswordResets.
     * @param {PasswordResetsCreateArgs} args - Arguments to create a PasswordResets.
     * @example
     * // Create one PasswordResets
     * const PasswordResets = await prisma.passwordResets.create({
     *   data: {
     *     // ... data to create a PasswordResets
     *   }
     * })
     * 
     */
    create<T extends PasswordResetsCreateArgs>(args: SelectSubset<T, PasswordResetsCreateArgs<ExtArgs>>): Prisma__PasswordResetsClient<$Result.GetResult<Prisma.$PasswordResetsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PasswordResets.
     * @param {PasswordResetsCreateManyArgs} args - Arguments to create many PasswordResets.
     * @example
     * // Create many PasswordResets
     * const passwordResets = await prisma.passwordResets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetsCreateManyArgs>(args?: SelectSubset<T, PasswordResetsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PasswordResets.
     * @param {PasswordResetsDeleteArgs} args - Arguments to delete one PasswordResets.
     * @example
     * // Delete one PasswordResets
     * const PasswordResets = await prisma.passwordResets.delete({
     *   where: {
     *     // ... filter to delete one PasswordResets
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetsDeleteArgs>(args: SelectSubset<T, PasswordResetsDeleteArgs<ExtArgs>>): Prisma__PasswordResetsClient<$Result.GetResult<Prisma.$PasswordResetsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PasswordResets.
     * @param {PasswordResetsUpdateArgs} args - Arguments to update one PasswordResets.
     * @example
     * // Update one PasswordResets
     * const passwordResets = await prisma.passwordResets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetsUpdateArgs>(args: SelectSubset<T, PasswordResetsUpdateArgs<ExtArgs>>): Prisma__PasswordResetsClient<$Result.GetResult<Prisma.$PasswordResetsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PasswordResets.
     * @param {PasswordResetsDeleteManyArgs} args - Arguments to filter PasswordResets to delete.
     * @example
     * // Delete a few PasswordResets
     * const { count } = await prisma.passwordResets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetsDeleteManyArgs>(args?: SelectSubset<T, PasswordResetsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResets
     * const passwordResets = await prisma.passwordResets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetsUpdateManyArgs>(args: SelectSubset<T, PasswordResetsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PasswordResets.
     * @param {PasswordResetsUpsertArgs} args - Arguments to update or create a PasswordResets.
     * @example
     * // Update or create a PasswordResets
     * const passwordResets = await prisma.passwordResets.upsert({
     *   create: {
     *     // ... data to create a PasswordResets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResets we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetsUpsertArgs>(args: SelectSubset<T, PasswordResetsUpsertArgs<ExtArgs>>): Prisma__PasswordResetsClient<$Result.GetResult<Prisma.$PasswordResetsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PasswordResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetsCountArgs} args - Arguments to filter PasswordResets to count.
     * @example
     * // Count the number of PasswordResets
     * const count = await prisma.passwordResets.count({
     *   where: {
     *     // ... the filter for the PasswordResets we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetsCountArgs>(
      args?: Subset<T, PasswordResetsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetsAggregateArgs>(args: Subset<T, PasswordResetsAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetsAggregateType<T>>

    /**
     * Group by PasswordResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetsGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResets model
   */
  readonly fields: PasswordResetsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResets model
   */ 
  interface PasswordResetsFieldRefs {
    readonly email: FieldRef<"PasswordResets", 'String'>
    readonly token: FieldRef<"PasswordResets", 'String'>
    readonly createdAt: FieldRef<"PasswordResets", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResets findUnique
   */
  export type PasswordResetsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResets
     */
    select?: PasswordResetsSelect<ExtArgs> | null
    /**
     * Filter, which PasswordResets to fetch.
     */
    where: PasswordResetsWhereUniqueInput
  }

  /**
   * PasswordResets findUniqueOrThrow
   */
  export type PasswordResetsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResets
     */
    select?: PasswordResetsSelect<ExtArgs> | null
    /**
     * Filter, which PasswordResets to fetch.
     */
    where: PasswordResetsWhereUniqueInput
  }

  /**
   * PasswordResets findFirst
   */
  export type PasswordResetsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResets
     */
    select?: PasswordResetsSelect<ExtArgs> | null
    /**
     * Filter, which PasswordResets to fetch.
     */
    where?: PasswordResetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetsOrderByWithRelationInput | PasswordResetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResets.
     */
    cursor?: PasswordResetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResets.
     */
    distinct?: PasswordResetsScalarFieldEnum | PasswordResetsScalarFieldEnum[]
  }

  /**
   * PasswordResets findFirstOrThrow
   */
  export type PasswordResetsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResets
     */
    select?: PasswordResetsSelect<ExtArgs> | null
    /**
     * Filter, which PasswordResets to fetch.
     */
    where?: PasswordResetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetsOrderByWithRelationInput | PasswordResetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResets.
     */
    cursor?: PasswordResetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResets.
     */
    distinct?: PasswordResetsScalarFieldEnum | PasswordResetsScalarFieldEnum[]
  }

  /**
   * PasswordResets findMany
   */
  export type PasswordResetsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResets
     */
    select?: PasswordResetsSelect<ExtArgs> | null
    /**
     * Filter, which PasswordResets to fetch.
     */
    where?: PasswordResetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetsOrderByWithRelationInput | PasswordResetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResets.
     */
    cursor?: PasswordResetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    distinct?: PasswordResetsScalarFieldEnum | PasswordResetsScalarFieldEnum[]
  }

  /**
   * PasswordResets create
   */
  export type PasswordResetsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResets
     */
    select?: PasswordResetsSelect<ExtArgs> | null
    /**
     * The data needed to create a PasswordResets.
     */
    data: XOR<PasswordResetsCreateInput, PasswordResetsUncheckedCreateInput>
  }

  /**
   * PasswordResets createMany
   */
  export type PasswordResetsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResets.
     */
    data: PasswordResetsCreateManyInput | PasswordResetsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResets update
   */
  export type PasswordResetsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResets
     */
    select?: PasswordResetsSelect<ExtArgs> | null
    /**
     * The data needed to update a PasswordResets.
     */
    data: XOR<PasswordResetsUpdateInput, PasswordResetsUncheckedUpdateInput>
    /**
     * Choose, which PasswordResets to update.
     */
    where: PasswordResetsWhereUniqueInput
  }

  /**
   * PasswordResets updateMany
   */
  export type PasswordResetsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResets.
     */
    data: XOR<PasswordResetsUpdateManyMutationInput, PasswordResetsUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResets to update
     */
    where?: PasswordResetsWhereInput
  }

  /**
   * PasswordResets upsert
   */
  export type PasswordResetsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResets
     */
    select?: PasswordResetsSelect<ExtArgs> | null
    /**
     * The filter to search for the PasswordResets to update in case it exists.
     */
    where: PasswordResetsWhereUniqueInput
    /**
     * In case the PasswordResets found by the `where` argument doesn't exist, create a new PasswordResets with this data.
     */
    create: XOR<PasswordResetsCreateInput, PasswordResetsUncheckedCreateInput>
    /**
     * In case the PasswordResets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetsUpdateInput, PasswordResetsUncheckedUpdateInput>
  }

  /**
   * PasswordResets delete
   */
  export type PasswordResetsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResets
     */
    select?: PasswordResetsSelect<ExtArgs> | null
    /**
     * Filter which PasswordResets to delete.
     */
    where: PasswordResetsWhereUniqueInput
  }

  /**
   * PasswordResets deleteMany
   */
  export type PasswordResetsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResets to delete
     */
    where?: PasswordResetsWhereInput
  }

  /**
   * PasswordResets without action
   */
  export type PasswordResetsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResets
     */
    select?: PasswordResetsSelect<ExtArgs> | null
  }


  /**
   * Model Questions
   */

  export type AggregateQuestions = {
    _count: QuestionsCountAggregateOutputType | null
    _avg: QuestionsAvgAggregateOutputType | null
    _sum: QuestionsSumAggregateOutputType | null
    _min: QuestionsMinAggregateOutputType | null
    _max: QuestionsMaxAggregateOutputType | null
  }

  export type QuestionsAvgAggregateOutputType = {
    id: number | null
  }

  export type QuestionsSumAggregateOutputType = {
    id: bigint | null
  }

  export type QuestionsMinAggregateOutputType = {
    id: bigint | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type QuestionsMaxAggregateOutputType = {
    id: bigint | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type QuestionsCountAggregateOutputType = {
    id: number
    enabled: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type QuestionsAvgAggregateInputType = {
    id?: true
  }

  export type QuestionsSumAggregateInputType = {
    id?: true
  }

  export type QuestionsMinAggregateInputType = {
    id?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type QuestionsMaxAggregateInputType = {
    id?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type QuestionsCountAggregateInputType = {
    id?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type QuestionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Questions to aggregate.
     */
    where?: QuestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionsOrderByWithRelationInput | QuestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Questions
    **/
    _count?: true | QuestionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionsMaxAggregateInputType
  }

  export type GetQuestionsAggregateType<T extends QuestionsAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestions[P]>
      : GetScalarType<T[P], AggregateQuestions[P]>
  }




  export type QuestionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionsWhereInput
    orderBy?: QuestionsOrderByWithAggregationInput | QuestionsOrderByWithAggregationInput[]
    by: QuestionsScalarFieldEnum[] | QuestionsScalarFieldEnum
    having?: QuestionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionsCountAggregateInputType | true
    _avg?: QuestionsAvgAggregateInputType
    _sum?: QuestionsSumAggregateInputType
    _min?: QuestionsMinAggregateInputType
    _max?: QuestionsMaxAggregateInputType
  }

  export type QuestionsGroupByOutputType = {
    id: bigint
    enabled: boolean
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: QuestionsCountAggregateOutputType | null
    _avg: QuestionsAvgAggregateOutputType | null
    _sum: QuestionsSumAggregateOutputType | null
    _min: QuestionsMinAggregateOutputType | null
    _max: QuestionsMaxAggregateOutputType | null
  }

  type GetQuestionsGroupByPayload<T extends QuestionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionsGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionsGroupByOutputType[P]>
        }
      >
    >


  export type QuestionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    QuestionsLang?: boolean | Questions$QuestionsLangArgs<ExtArgs>
    RelationsQuestions?: boolean | Questions$RelationsQuestionsArgs<ExtArgs>
    _count?: boolean | QuestionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questions"]>


  export type QuestionsSelectScalar = {
    id?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type QuestionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    QuestionsLang?: boolean | Questions$QuestionsLangArgs<ExtArgs>
    RelationsQuestions?: boolean | Questions$RelationsQuestionsArgs<ExtArgs>
    _count?: boolean | QuestionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $QuestionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Questions"
    objects: {
      QuestionsLang: Prisma.$QuestionsLangPayload<ExtArgs>[]
      RelationsQuestions: Prisma.$RelationsQuestionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      enabled: boolean
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["questions"]>
    composites: {}
  }

  type QuestionsGetPayload<S extends boolean | null | undefined | QuestionsDefaultArgs> = $Result.GetResult<Prisma.$QuestionsPayload, S>

  type QuestionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionsCountAggregateInputType | true
    }

  export interface QuestionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Questions'], meta: { name: 'Questions' } }
    /**
     * Find zero or one Questions that matches the filter.
     * @param {QuestionsFindUniqueArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionsFindUniqueArgs>(args: SelectSubset<T, QuestionsFindUniqueArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Questions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuestionsFindUniqueOrThrowArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionsFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsFindFirstArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionsFindFirstArgs>(args?: SelectSubset<T, QuestionsFindFirstArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Questions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsFindFirstOrThrowArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionsFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.questions.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.questions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionsWithIdOnly = await prisma.questions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionsFindManyArgs>(args?: SelectSubset<T, QuestionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Questions.
     * @param {QuestionsCreateArgs} args - Arguments to create a Questions.
     * @example
     * // Create one Questions
     * const Questions = await prisma.questions.create({
     *   data: {
     *     // ... data to create a Questions
     *   }
     * })
     * 
     */
    create<T extends QuestionsCreateArgs>(args: SelectSubset<T, QuestionsCreateArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Questions.
     * @param {QuestionsCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const questions = await prisma.questions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionsCreateManyArgs>(args?: SelectSubset<T, QuestionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Questions.
     * @param {QuestionsDeleteArgs} args - Arguments to delete one Questions.
     * @example
     * // Delete one Questions
     * const Questions = await prisma.questions.delete({
     *   where: {
     *     // ... filter to delete one Questions
     *   }
     * })
     * 
     */
    delete<T extends QuestionsDeleteArgs>(args: SelectSubset<T, QuestionsDeleteArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Questions.
     * @param {QuestionsUpdateArgs} args - Arguments to update one Questions.
     * @example
     * // Update one Questions
     * const questions = await prisma.questions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionsUpdateArgs>(args: SelectSubset<T, QuestionsUpdateArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Questions.
     * @param {QuestionsDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.questions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionsDeleteManyArgs>(args?: SelectSubset<T, QuestionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const questions = await prisma.questions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionsUpdateManyArgs>(args: SelectSubset<T, QuestionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Questions.
     * @param {QuestionsUpsertArgs} args - Arguments to update or create a Questions.
     * @example
     * // Update or create a Questions
     * const questions = await prisma.questions.upsert({
     *   create: {
     *     // ... data to create a Questions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Questions we want to update
     *   }
     * })
     */
    upsert<T extends QuestionsUpsertArgs>(args: SelectSubset<T, QuestionsUpsertArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.questions.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends QuestionsCountArgs>(
      args?: Subset<T, QuestionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionsAggregateArgs>(args: Subset<T, QuestionsAggregateArgs>): Prisma.PrismaPromise<GetQuestionsAggregateType<T>>

    /**
     * Group by Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionsGroupByArgs['orderBy'] }
        : { orderBy?: QuestionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Questions model
   */
  readonly fields: QuestionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Questions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    QuestionsLang<T extends Questions$QuestionsLangArgs<ExtArgs> = {}>(args?: Subset<T, Questions$QuestionsLangArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionsLangPayload<ExtArgs>, T, "findMany"> | Null>
    RelationsQuestions<T extends Questions$RelationsQuestionsArgs<ExtArgs> = {}>(args?: Subset<T, Questions$RelationsQuestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationsQuestionsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Questions model
   */ 
  interface QuestionsFieldRefs {
    readonly id: FieldRef<"Questions", 'BigInt'>
    readonly enabled: FieldRef<"Questions", 'Boolean'>
    readonly createdAt: FieldRef<"Questions", 'DateTime'>
    readonly updatedAt: FieldRef<"Questions", 'DateTime'>
    readonly deletedAt: FieldRef<"Questions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Questions findUnique
   */
  export type QuestionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where: QuestionsWhereUniqueInput
  }

  /**
   * Questions findUniqueOrThrow
   */
  export type QuestionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where: QuestionsWhereUniqueInput
  }

  /**
   * Questions findFirst
   */
  export type QuestionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionsOrderByWithRelationInput | QuestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * Questions findFirstOrThrow
   */
  export type QuestionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionsOrderByWithRelationInput | QuestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * Questions findMany
   */
  export type QuestionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionsOrderByWithRelationInput | QuestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Questions.
     */
    cursor?: QuestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * Questions create
   */
  export type QuestionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * The data needed to create a Questions.
     */
    data?: XOR<QuestionsCreateInput, QuestionsUncheckedCreateInput>
  }

  /**
   * Questions createMany
   */
  export type QuestionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Questions.
     */
    data: QuestionsCreateManyInput | QuestionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Questions update
   */
  export type QuestionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * The data needed to update a Questions.
     */
    data: XOR<QuestionsUpdateInput, QuestionsUncheckedUpdateInput>
    /**
     * Choose, which Questions to update.
     */
    where: QuestionsWhereUniqueInput
  }

  /**
   * Questions updateMany
   */
  export type QuestionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionsUpdateManyMutationInput, QuestionsUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionsWhereInput
  }

  /**
   * Questions upsert
   */
  export type QuestionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * The filter to search for the Questions to update in case it exists.
     */
    where: QuestionsWhereUniqueInput
    /**
     * In case the Questions found by the `where` argument doesn't exist, create a new Questions with this data.
     */
    create: XOR<QuestionsCreateInput, QuestionsUncheckedCreateInput>
    /**
     * In case the Questions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionsUpdateInput, QuestionsUncheckedUpdateInput>
  }

  /**
   * Questions delete
   */
  export type QuestionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
    /**
     * Filter which Questions to delete.
     */
    where: QuestionsWhereUniqueInput
  }

  /**
   * Questions deleteMany
   */
  export type QuestionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Questions to delete
     */
    where?: QuestionsWhereInput
  }

  /**
   * Questions.QuestionsLang
   */
  export type Questions$QuestionsLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsLang
     */
    select?: QuestionsLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsLangInclude<ExtArgs> | null
    where?: QuestionsLangWhereInput
    orderBy?: QuestionsLangOrderByWithRelationInput | QuestionsLangOrderByWithRelationInput[]
    cursor?: QuestionsLangWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionsLangScalarFieldEnum | QuestionsLangScalarFieldEnum[]
  }

  /**
   * Questions.RelationsQuestions
   */
  export type Questions$RelationsQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsQuestions
     */
    select?: RelationsQuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsQuestionsInclude<ExtArgs> | null
    where?: RelationsQuestionsWhereInput
    orderBy?: RelationsQuestionsOrderByWithRelationInput | RelationsQuestionsOrderByWithRelationInput[]
    cursor?: RelationsQuestionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelationsQuestionsScalarFieldEnum | RelationsQuestionsScalarFieldEnum[]
  }

  /**
   * Questions without action
   */
  export type QuestionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Questions
     */
    select?: QuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsInclude<ExtArgs> | null
  }


  /**
   * Model QuestionsLang
   */

  export type AggregateQuestionsLang = {
    _count: QuestionsLangCountAggregateOutputType | null
    _avg: QuestionsLangAvgAggregateOutputType | null
    _sum: QuestionsLangSumAggregateOutputType | null
    _min: QuestionsLangMinAggregateOutputType | null
    _max: QuestionsLangMaxAggregateOutputType | null
  }

  export type QuestionsLangAvgAggregateOutputType = {
    id: number | null
    qsId: number | null
    lang: number | null
    audio: number | null
  }

  export type QuestionsLangSumAggregateOutputType = {
    id: bigint | null
    qsId: bigint | null
    lang: bigint | null
    audio: bigint | null
  }

  export type QuestionsLangMinAggregateOutputType = {
    id: bigint | null
    qsId: bigint | null
    lang: bigint | null
    text: string | null
    hint: string | null
    audio: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type QuestionsLangMaxAggregateOutputType = {
    id: bigint | null
    qsId: bigint | null
    lang: bigint | null
    text: string | null
    hint: string | null
    audio: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type QuestionsLangCountAggregateOutputType = {
    id: number
    qsId: number
    lang: number
    text: number
    hint: number
    audio: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type QuestionsLangAvgAggregateInputType = {
    id?: true
    qsId?: true
    lang?: true
    audio?: true
  }

  export type QuestionsLangSumAggregateInputType = {
    id?: true
    qsId?: true
    lang?: true
    audio?: true
  }

  export type QuestionsLangMinAggregateInputType = {
    id?: true
    qsId?: true
    lang?: true
    text?: true
    hint?: true
    audio?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type QuestionsLangMaxAggregateInputType = {
    id?: true
    qsId?: true
    lang?: true
    text?: true
    hint?: true
    audio?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type QuestionsLangCountAggregateInputType = {
    id?: true
    qsId?: true
    lang?: true
    text?: true
    hint?: true
    audio?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type QuestionsLangAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionsLang to aggregate.
     */
    where?: QuestionsLangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsLangs to fetch.
     */
    orderBy?: QuestionsLangOrderByWithRelationInput | QuestionsLangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionsLangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsLangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsLangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionsLangs
    **/
    _count?: true | QuestionsLangCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionsLangAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionsLangSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionsLangMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionsLangMaxAggregateInputType
  }

  export type GetQuestionsLangAggregateType<T extends QuestionsLangAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionsLang]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionsLang[P]>
      : GetScalarType<T[P], AggregateQuestionsLang[P]>
  }




  export type QuestionsLangGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionsLangWhereInput
    orderBy?: QuestionsLangOrderByWithAggregationInput | QuestionsLangOrderByWithAggregationInput[]
    by: QuestionsLangScalarFieldEnum[] | QuestionsLangScalarFieldEnum
    having?: QuestionsLangScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionsLangCountAggregateInputType | true
    _avg?: QuestionsLangAvgAggregateInputType
    _sum?: QuestionsLangSumAggregateInputType
    _min?: QuestionsLangMinAggregateInputType
    _max?: QuestionsLangMaxAggregateInputType
  }

  export type QuestionsLangGroupByOutputType = {
    id: bigint
    qsId: bigint
    lang: bigint
    text: string
    hint: string | null
    audio: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: QuestionsLangCountAggregateOutputType | null
    _avg: QuestionsLangAvgAggregateOutputType | null
    _sum: QuestionsLangSumAggregateOutputType | null
    _min: QuestionsLangMinAggregateOutputType | null
    _max: QuestionsLangMaxAggregateOutputType | null
  }

  type GetQuestionsLangGroupByPayload<T extends QuestionsLangGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionsLangGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionsLangGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionsLangGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionsLangGroupByOutputType[P]>
        }
      >
    >


  export type QuestionsLangSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    qsId?: boolean
    lang?: boolean
    text?: boolean
    hint?: boolean
    audio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    Questions?: boolean | QuestionsDefaultArgs<ExtArgs>
    Languages?: boolean | LanguagesDefaultArgs<ExtArgs>
    Audio?: boolean | QuestionsLang$AudioArgs<ExtArgs>
  }, ExtArgs["result"]["questionsLang"]>


  export type QuestionsLangSelectScalar = {
    id?: boolean
    qsId?: boolean
    lang?: boolean
    text?: boolean
    hint?: boolean
    audio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type QuestionsLangInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Questions?: boolean | QuestionsDefaultArgs<ExtArgs>
    Languages?: boolean | LanguagesDefaultArgs<ExtArgs>
    Audio?: boolean | QuestionsLang$AudioArgs<ExtArgs>
  }

  export type $QuestionsLangPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestionsLang"
    objects: {
      Questions: Prisma.$QuestionsPayload<ExtArgs>
      Languages: Prisma.$LanguagesPayload<ExtArgs>
      Audio: Prisma.$AudioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      qsId: bigint
      lang: bigint
      text: string
      hint: string | null
      audio: bigint | null
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["questionsLang"]>
    composites: {}
  }

  type QuestionsLangGetPayload<S extends boolean | null | undefined | QuestionsLangDefaultArgs> = $Result.GetResult<Prisma.$QuestionsLangPayload, S>

  type QuestionsLangCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestionsLangFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionsLangCountAggregateInputType | true
    }

  export interface QuestionsLangDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionsLang'], meta: { name: 'QuestionsLang' } }
    /**
     * Find zero or one QuestionsLang that matches the filter.
     * @param {QuestionsLangFindUniqueArgs} args - Arguments to find a QuestionsLang
     * @example
     * // Get one QuestionsLang
     * const questionsLang = await prisma.questionsLang.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionsLangFindUniqueArgs>(args: SelectSubset<T, QuestionsLangFindUniqueArgs<ExtArgs>>): Prisma__QuestionsLangClient<$Result.GetResult<Prisma.$QuestionsLangPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QuestionsLang that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuestionsLangFindUniqueOrThrowArgs} args - Arguments to find a QuestionsLang
     * @example
     * // Get one QuestionsLang
     * const questionsLang = await prisma.questionsLang.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionsLangFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionsLangFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionsLangClient<$Result.GetResult<Prisma.$QuestionsLangPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QuestionsLang that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsLangFindFirstArgs} args - Arguments to find a QuestionsLang
     * @example
     * // Get one QuestionsLang
     * const questionsLang = await prisma.questionsLang.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionsLangFindFirstArgs>(args?: SelectSubset<T, QuestionsLangFindFirstArgs<ExtArgs>>): Prisma__QuestionsLangClient<$Result.GetResult<Prisma.$QuestionsLangPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QuestionsLang that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsLangFindFirstOrThrowArgs} args - Arguments to find a QuestionsLang
     * @example
     * // Get one QuestionsLang
     * const questionsLang = await prisma.questionsLang.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionsLangFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionsLangFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionsLangClient<$Result.GetResult<Prisma.$QuestionsLangPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QuestionsLangs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsLangFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionsLangs
     * const questionsLangs = await prisma.questionsLang.findMany()
     * 
     * // Get first 10 QuestionsLangs
     * const questionsLangs = await prisma.questionsLang.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionsLangWithIdOnly = await prisma.questionsLang.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionsLangFindManyArgs>(args?: SelectSubset<T, QuestionsLangFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionsLangPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QuestionsLang.
     * @param {QuestionsLangCreateArgs} args - Arguments to create a QuestionsLang.
     * @example
     * // Create one QuestionsLang
     * const QuestionsLang = await prisma.questionsLang.create({
     *   data: {
     *     // ... data to create a QuestionsLang
     *   }
     * })
     * 
     */
    create<T extends QuestionsLangCreateArgs>(args: SelectSubset<T, QuestionsLangCreateArgs<ExtArgs>>): Prisma__QuestionsLangClient<$Result.GetResult<Prisma.$QuestionsLangPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QuestionsLangs.
     * @param {QuestionsLangCreateManyArgs} args - Arguments to create many QuestionsLangs.
     * @example
     * // Create many QuestionsLangs
     * const questionsLang = await prisma.questionsLang.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionsLangCreateManyArgs>(args?: SelectSubset<T, QuestionsLangCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuestionsLang.
     * @param {QuestionsLangDeleteArgs} args - Arguments to delete one QuestionsLang.
     * @example
     * // Delete one QuestionsLang
     * const QuestionsLang = await prisma.questionsLang.delete({
     *   where: {
     *     // ... filter to delete one QuestionsLang
     *   }
     * })
     * 
     */
    delete<T extends QuestionsLangDeleteArgs>(args: SelectSubset<T, QuestionsLangDeleteArgs<ExtArgs>>): Prisma__QuestionsLangClient<$Result.GetResult<Prisma.$QuestionsLangPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QuestionsLang.
     * @param {QuestionsLangUpdateArgs} args - Arguments to update one QuestionsLang.
     * @example
     * // Update one QuestionsLang
     * const questionsLang = await prisma.questionsLang.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionsLangUpdateArgs>(args: SelectSubset<T, QuestionsLangUpdateArgs<ExtArgs>>): Prisma__QuestionsLangClient<$Result.GetResult<Prisma.$QuestionsLangPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QuestionsLangs.
     * @param {QuestionsLangDeleteManyArgs} args - Arguments to filter QuestionsLangs to delete.
     * @example
     * // Delete a few QuestionsLangs
     * const { count } = await prisma.questionsLang.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionsLangDeleteManyArgs>(args?: SelectSubset<T, QuestionsLangDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionsLangs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsLangUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionsLangs
     * const questionsLang = await prisma.questionsLang.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionsLangUpdateManyArgs>(args: SelectSubset<T, QuestionsLangUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionsLang.
     * @param {QuestionsLangUpsertArgs} args - Arguments to update or create a QuestionsLang.
     * @example
     * // Update or create a QuestionsLang
     * const questionsLang = await prisma.questionsLang.upsert({
     *   create: {
     *     // ... data to create a QuestionsLang
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionsLang we want to update
     *   }
     * })
     */
    upsert<T extends QuestionsLangUpsertArgs>(args: SelectSubset<T, QuestionsLangUpsertArgs<ExtArgs>>): Prisma__QuestionsLangClient<$Result.GetResult<Prisma.$QuestionsLangPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QuestionsLangs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsLangCountArgs} args - Arguments to filter QuestionsLangs to count.
     * @example
     * // Count the number of QuestionsLangs
     * const count = await prisma.questionsLang.count({
     *   where: {
     *     // ... the filter for the QuestionsLangs we want to count
     *   }
     * })
    **/
    count<T extends QuestionsLangCountArgs>(
      args?: Subset<T, QuestionsLangCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionsLangCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionsLang.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsLangAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionsLangAggregateArgs>(args: Subset<T, QuestionsLangAggregateArgs>): Prisma.PrismaPromise<GetQuestionsLangAggregateType<T>>

    /**
     * Group by QuestionsLang.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsLangGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionsLangGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionsLangGroupByArgs['orderBy'] }
        : { orderBy?: QuestionsLangGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionsLangGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionsLangGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestionsLang model
   */
  readonly fields: QuestionsLangFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionsLang.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionsLangClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Questions<T extends QuestionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionsDefaultArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Languages<T extends LanguagesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguagesDefaultArgs<ExtArgs>>): Prisma__LanguagesClient<$Result.GetResult<Prisma.$LanguagesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Audio<T extends QuestionsLang$AudioArgs<ExtArgs> = {}>(args?: Subset<T, QuestionsLang$AudioArgs<ExtArgs>>): Prisma__AudioClient<$Result.GetResult<Prisma.$AudioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestionsLang model
   */ 
  interface QuestionsLangFieldRefs {
    readonly id: FieldRef<"QuestionsLang", 'BigInt'>
    readonly qsId: FieldRef<"QuestionsLang", 'BigInt'>
    readonly lang: FieldRef<"QuestionsLang", 'BigInt'>
    readonly text: FieldRef<"QuestionsLang", 'String'>
    readonly hint: FieldRef<"QuestionsLang", 'String'>
    readonly audio: FieldRef<"QuestionsLang", 'BigInt'>
    readonly createdAt: FieldRef<"QuestionsLang", 'DateTime'>
    readonly updatedAt: FieldRef<"QuestionsLang", 'DateTime'>
    readonly deletedAt: FieldRef<"QuestionsLang", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuestionsLang findUnique
   */
  export type QuestionsLangFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsLang
     */
    select?: QuestionsLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsLangInclude<ExtArgs> | null
    /**
     * Filter, which QuestionsLang to fetch.
     */
    where: QuestionsLangWhereUniqueInput
  }

  /**
   * QuestionsLang findUniqueOrThrow
   */
  export type QuestionsLangFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsLang
     */
    select?: QuestionsLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsLangInclude<ExtArgs> | null
    /**
     * Filter, which QuestionsLang to fetch.
     */
    where: QuestionsLangWhereUniqueInput
  }

  /**
   * QuestionsLang findFirst
   */
  export type QuestionsLangFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsLang
     */
    select?: QuestionsLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsLangInclude<ExtArgs> | null
    /**
     * Filter, which QuestionsLang to fetch.
     */
    where?: QuestionsLangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsLangs to fetch.
     */
    orderBy?: QuestionsLangOrderByWithRelationInput | QuestionsLangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionsLangs.
     */
    cursor?: QuestionsLangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsLangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsLangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionsLangs.
     */
    distinct?: QuestionsLangScalarFieldEnum | QuestionsLangScalarFieldEnum[]
  }

  /**
   * QuestionsLang findFirstOrThrow
   */
  export type QuestionsLangFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsLang
     */
    select?: QuestionsLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsLangInclude<ExtArgs> | null
    /**
     * Filter, which QuestionsLang to fetch.
     */
    where?: QuestionsLangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsLangs to fetch.
     */
    orderBy?: QuestionsLangOrderByWithRelationInput | QuestionsLangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionsLangs.
     */
    cursor?: QuestionsLangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsLangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsLangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionsLangs.
     */
    distinct?: QuestionsLangScalarFieldEnum | QuestionsLangScalarFieldEnum[]
  }

  /**
   * QuestionsLang findMany
   */
  export type QuestionsLangFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsLang
     */
    select?: QuestionsLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsLangInclude<ExtArgs> | null
    /**
     * Filter, which QuestionsLangs to fetch.
     */
    where?: QuestionsLangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionsLangs to fetch.
     */
    orderBy?: QuestionsLangOrderByWithRelationInput | QuestionsLangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionsLangs.
     */
    cursor?: QuestionsLangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionsLangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionsLangs.
     */
    skip?: number
    distinct?: QuestionsLangScalarFieldEnum | QuestionsLangScalarFieldEnum[]
  }

  /**
   * QuestionsLang create
   */
  export type QuestionsLangCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsLang
     */
    select?: QuestionsLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsLangInclude<ExtArgs> | null
    /**
     * The data needed to create a QuestionsLang.
     */
    data: XOR<QuestionsLangCreateInput, QuestionsLangUncheckedCreateInput>
  }

  /**
   * QuestionsLang createMany
   */
  export type QuestionsLangCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestionsLangs.
     */
    data: QuestionsLangCreateManyInput | QuestionsLangCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionsLang update
   */
  export type QuestionsLangUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsLang
     */
    select?: QuestionsLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsLangInclude<ExtArgs> | null
    /**
     * The data needed to update a QuestionsLang.
     */
    data: XOR<QuestionsLangUpdateInput, QuestionsLangUncheckedUpdateInput>
    /**
     * Choose, which QuestionsLang to update.
     */
    where: QuestionsLangWhereUniqueInput
  }

  /**
   * QuestionsLang updateMany
   */
  export type QuestionsLangUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestionsLangs.
     */
    data: XOR<QuestionsLangUpdateManyMutationInput, QuestionsLangUncheckedUpdateManyInput>
    /**
     * Filter which QuestionsLangs to update
     */
    where?: QuestionsLangWhereInput
  }

  /**
   * QuestionsLang upsert
   */
  export type QuestionsLangUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsLang
     */
    select?: QuestionsLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsLangInclude<ExtArgs> | null
    /**
     * The filter to search for the QuestionsLang to update in case it exists.
     */
    where: QuestionsLangWhereUniqueInput
    /**
     * In case the QuestionsLang found by the `where` argument doesn't exist, create a new QuestionsLang with this data.
     */
    create: XOR<QuestionsLangCreateInput, QuestionsLangUncheckedCreateInput>
    /**
     * In case the QuestionsLang was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionsLangUpdateInput, QuestionsLangUncheckedUpdateInput>
  }

  /**
   * QuestionsLang delete
   */
  export type QuestionsLangDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsLang
     */
    select?: QuestionsLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsLangInclude<ExtArgs> | null
    /**
     * Filter which QuestionsLang to delete.
     */
    where: QuestionsLangWhereUniqueInput
  }

  /**
   * QuestionsLang deleteMany
   */
  export type QuestionsLangDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionsLangs to delete
     */
    where?: QuestionsLangWhereInput
  }

  /**
   * QuestionsLang.Audio
   */
  export type QuestionsLang$AudioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audio
     */
    select?: AudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioInclude<ExtArgs> | null
    where?: AudioWhereInput
  }

  /**
   * QuestionsLang without action
   */
  export type QuestionsLangDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsLang
     */
    select?: QuestionsLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionsLangInclude<ExtArgs> | null
  }


  /**
   * Model Quizzes
   */

  export type AggregateQuizzes = {
    _count: QuizzesCountAggregateOutputType | null
    _avg: QuizzesAvgAggregateOutputType | null
    _sum: QuizzesSumAggregateOutputType | null
    _min: QuizzesMinAggregateOutputType | null
    _max: QuizzesMaxAggregateOutputType | null
  }

  export type QuizzesAvgAggregateOutputType = {
    id: number | null
    duration: number | null
    level: number | null
    media: number | null
  }

  export type QuizzesSumAggregateOutputType = {
    id: bigint | null
    duration: number | null
    level: number | null
    media: bigint | null
  }

  export type QuizzesMinAggregateOutputType = {
    id: bigint | null
    code: string | null
    duration: number | null
    level: number | null
    media: bigint | null
    enabled: boolean | null
    other: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type QuizzesMaxAggregateOutputType = {
    id: bigint | null
    code: string | null
    duration: number | null
    level: number | null
    media: bigint | null
    enabled: boolean | null
    other: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type QuizzesCountAggregateOutputType = {
    id: number
    code: number
    duration: number
    level: number
    media: number
    enabled: number
    other: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type QuizzesAvgAggregateInputType = {
    id?: true
    duration?: true
    level?: true
    media?: true
  }

  export type QuizzesSumAggregateInputType = {
    id?: true
    duration?: true
    level?: true
    media?: true
  }

  export type QuizzesMinAggregateInputType = {
    id?: true
    code?: true
    duration?: true
    level?: true
    media?: true
    enabled?: true
    other?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type QuizzesMaxAggregateInputType = {
    id?: true
    code?: true
    duration?: true
    level?: true
    media?: true
    enabled?: true
    other?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type QuizzesCountAggregateInputType = {
    id?: true
    code?: true
    duration?: true
    level?: true
    media?: true
    enabled?: true
    other?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type QuizzesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quizzes to aggregate.
     */
    where?: QuizzesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizzesOrderByWithRelationInput | QuizzesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizzesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quizzes
    **/
    _count?: true | QuizzesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizzesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizzesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizzesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizzesMaxAggregateInputType
  }

  export type GetQuizzesAggregateType<T extends QuizzesAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizzes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizzes[P]>
      : GetScalarType<T[P], AggregateQuizzes[P]>
  }




  export type QuizzesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizzesWhereInput
    orderBy?: QuizzesOrderByWithAggregationInput | QuizzesOrderByWithAggregationInput[]
    by: QuizzesScalarFieldEnum[] | QuizzesScalarFieldEnum
    having?: QuizzesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizzesCountAggregateInputType | true
    _avg?: QuizzesAvgAggregateInputType
    _sum?: QuizzesSumAggregateInputType
    _min?: QuizzesMinAggregateInputType
    _max?: QuizzesMaxAggregateInputType
  }

  export type QuizzesGroupByOutputType = {
    id: bigint
    code: string
    duration: number
    level: number
    media: bigint | null
    enabled: boolean
    other: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: QuizzesCountAggregateOutputType | null
    _avg: QuizzesAvgAggregateOutputType | null
    _sum: QuizzesSumAggregateOutputType | null
    _min: QuizzesMinAggregateOutputType | null
    _max: QuizzesMaxAggregateOutputType | null
  }

  type GetQuizzesGroupByPayload<T extends QuizzesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizzesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizzesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizzesGroupByOutputType[P]>
            : GetScalarType<T[P], QuizzesGroupByOutputType[P]>
        }
      >
    >


  export type QuizzesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    duration?: boolean
    level?: boolean
    media?: boolean
    enabled?: boolean
    other?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    Media?: boolean | Quizzes$MediaArgs<ExtArgs>
    QuizzesLang?: boolean | Quizzes$QuizzesLangArgs<ExtArgs>
    Relations?: boolean | Quizzes$RelationsArgs<ExtArgs>
    _count?: boolean | QuizzesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizzes"]>


  export type QuizzesSelectScalar = {
    id?: boolean
    code?: boolean
    duration?: boolean
    level?: boolean
    media?: boolean
    enabled?: boolean
    other?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type QuizzesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Media?: boolean | Quizzes$MediaArgs<ExtArgs>
    QuizzesLang?: boolean | Quizzes$QuizzesLangArgs<ExtArgs>
    Relations?: boolean | Quizzes$RelationsArgs<ExtArgs>
    _count?: boolean | QuizzesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $QuizzesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quizzes"
    objects: {
      Media: Prisma.$MediaPayload<ExtArgs> | null
      QuizzesLang: Prisma.$QuizzesLangPayload<ExtArgs>[]
      Relations: Prisma.$RelationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      code: string
      duration: number
      level: number
      media: bigint | null
      enabled: boolean
      other: string | null
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["quizzes"]>
    composites: {}
  }

  type QuizzesGetPayload<S extends boolean | null | undefined | QuizzesDefaultArgs> = $Result.GetResult<Prisma.$QuizzesPayload, S>

  type QuizzesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuizzesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuizzesCountAggregateInputType | true
    }

  export interface QuizzesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quizzes'], meta: { name: 'Quizzes' } }
    /**
     * Find zero or one Quizzes that matches the filter.
     * @param {QuizzesFindUniqueArgs} args - Arguments to find a Quizzes
     * @example
     * // Get one Quizzes
     * const quizzes = await prisma.quizzes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizzesFindUniqueArgs>(args: SelectSubset<T, QuizzesFindUniqueArgs<ExtArgs>>): Prisma__QuizzesClient<$Result.GetResult<Prisma.$QuizzesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Quizzes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuizzesFindUniqueOrThrowArgs} args - Arguments to find a Quizzes
     * @example
     * // Get one Quizzes
     * const quizzes = await prisma.quizzes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizzesFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizzesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizzesClient<$Result.GetResult<Prisma.$QuizzesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Quizzes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizzesFindFirstArgs} args - Arguments to find a Quizzes
     * @example
     * // Get one Quizzes
     * const quizzes = await prisma.quizzes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizzesFindFirstArgs>(args?: SelectSubset<T, QuizzesFindFirstArgs<ExtArgs>>): Prisma__QuizzesClient<$Result.GetResult<Prisma.$QuizzesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Quizzes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizzesFindFirstOrThrowArgs} args - Arguments to find a Quizzes
     * @example
     * // Get one Quizzes
     * const quizzes = await prisma.quizzes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizzesFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizzesFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizzesClient<$Result.GetResult<Prisma.$QuizzesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Quizzes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizzesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quizzes
     * const quizzes = await prisma.quizzes.findMany()
     * 
     * // Get first 10 Quizzes
     * const quizzes = await prisma.quizzes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizzesWithIdOnly = await prisma.quizzes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizzesFindManyArgs>(args?: SelectSubset<T, QuizzesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizzesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Quizzes.
     * @param {QuizzesCreateArgs} args - Arguments to create a Quizzes.
     * @example
     * // Create one Quizzes
     * const Quizzes = await prisma.quizzes.create({
     *   data: {
     *     // ... data to create a Quizzes
     *   }
     * })
     * 
     */
    create<T extends QuizzesCreateArgs>(args: SelectSubset<T, QuizzesCreateArgs<ExtArgs>>): Prisma__QuizzesClient<$Result.GetResult<Prisma.$QuizzesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Quizzes.
     * @param {QuizzesCreateManyArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quizzes = await prisma.quizzes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizzesCreateManyArgs>(args?: SelectSubset<T, QuizzesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Quizzes.
     * @param {QuizzesDeleteArgs} args - Arguments to delete one Quizzes.
     * @example
     * // Delete one Quizzes
     * const Quizzes = await prisma.quizzes.delete({
     *   where: {
     *     // ... filter to delete one Quizzes
     *   }
     * })
     * 
     */
    delete<T extends QuizzesDeleteArgs>(args: SelectSubset<T, QuizzesDeleteArgs<ExtArgs>>): Prisma__QuizzesClient<$Result.GetResult<Prisma.$QuizzesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Quizzes.
     * @param {QuizzesUpdateArgs} args - Arguments to update one Quizzes.
     * @example
     * // Update one Quizzes
     * const quizzes = await prisma.quizzes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizzesUpdateArgs>(args: SelectSubset<T, QuizzesUpdateArgs<ExtArgs>>): Prisma__QuizzesClient<$Result.GetResult<Prisma.$QuizzesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Quizzes.
     * @param {QuizzesDeleteManyArgs} args - Arguments to filter Quizzes to delete.
     * @example
     * // Delete a few Quizzes
     * const { count } = await prisma.quizzes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizzesDeleteManyArgs>(args?: SelectSubset<T, QuizzesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizzesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quizzes
     * const quizzes = await prisma.quizzes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizzesUpdateManyArgs>(args: SelectSubset<T, QuizzesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Quizzes.
     * @param {QuizzesUpsertArgs} args - Arguments to update or create a Quizzes.
     * @example
     * // Update or create a Quizzes
     * const quizzes = await prisma.quizzes.upsert({
     *   create: {
     *     // ... data to create a Quizzes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quizzes we want to update
     *   }
     * })
     */
    upsert<T extends QuizzesUpsertArgs>(args: SelectSubset<T, QuizzesUpsertArgs<ExtArgs>>): Prisma__QuizzesClient<$Result.GetResult<Prisma.$QuizzesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizzesCountArgs} args - Arguments to filter Quizzes to count.
     * @example
     * // Count the number of Quizzes
     * const count = await prisma.quizzes.count({
     *   where: {
     *     // ... the filter for the Quizzes we want to count
     *   }
     * })
    **/
    count<T extends QuizzesCountArgs>(
      args?: Subset<T, QuizzesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizzesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizzesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizzesAggregateArgs>(args: Subset<T, QuizzesAggregateArgs>): Prisma.PrismaPromise<GetQuizzesAggregateType<T>>

    /**
     * Group by Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizzesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizzesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizzesGroupByArgs['orderBy'] }
        : { orderBy?: QuizzesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizzesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizzesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quizzes model
   */
  readonly fields: QuizzesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quizzes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizzesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Media<T extends Quizzes$MediaArgs<ExtArgs> = {}>(args?: Subset<T, Quizzes$MediaArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    QuizzesLang<T extends Quizzes$QuizzesLangArgs<ExtArgs> = {}>(args?: Subset<T, Quizzes$QuizzesLangArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizzesLangPayload<ExtArgs>, T, "findMany"> | Null>
    Relations<T extends Quizzes$RelationsArgs<ExtArgs> = {}>(args?: Subset<T, Quizzes$RelationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quizzes model
   */ 
  interface QuizzesFieldRefs {
    readonly id: FieldRef<"Quizzes", 'BigInt'>
    readonly code: FieldRef<"Quizzes", 'String'>
    readonly duration: FieldRef<"Quizzes", 'Int'>
    readonly level: FieldRef<"Quizzes", 'Int'>
    readonly media: FieldRef<"Quizzes", 'BigInt'>
    readonly enabled: FieldRef<"Quizzes", 'Boolean'>
    readonly other: FieldRef<"Quizzes", 'String'>
    readonly createdAt: FieldRef<"Quizzes", 'DateTime'>
    readonly updatedAt: FieldRef<"Quizzes", 'DateTime'>
    readonly deletedAt: FieldRef<"Quizzes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Quizzes findUnique
   */
  export type QuizzesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quizzes
     */
    select?: QuizzesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizzesInclude<ExtArgs> | null
    /**
     * Filter, which Quizzes to fetch.
     */
    where: QuizzesWhereUniqueInput
  }

  /**
   * Quizzes findUniqueOrThrow
   */
  export type QuizzesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quizzes
     */
    select?: QuizzesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizzesInclude<ExtArgs> | null
    /**
     * Filter, which Quizzes to fetch.
     */
    where: QuizzesWhereUniqueInput
  }

  /**
   * Quizzes findFirst
   */
  export type QuizzesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quizzes
     */
    select?: QuizzesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizzesInclude<ExtArgs> | null
    /**
     * Filter, which Quizzes to fetch.
     */
    where?: QuizzesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizzesOrderByWithRelationInput | QuizzesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizzesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: QuizzesScalarFieldEnum | QuizzesScalarFieldEnum[]
  }

  /**
   * Quizzes findFirstOrThrow
   */
  export type QuizzesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quizzes
     */
    select?: QuizzesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizzesInclude<ExtArgs> | null
    /**
     * Filter, which Quizzes to fetch.
     */
    where?: QuizzesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizzesOrderByWithRelationInput | QuizzesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizzesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: QuizzesScalarFieldEnum | QuizzesScalarFieldEnum[]
  }

  /**
   * Quizzes findMany
   */
  export type QuizzesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quizzes
     */
    select?: QuizzesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizzesInclude<ExtArgs> | null
    /**
     * Filter, which Quizzes to fetch.
     */
    where?: QuizzesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizzesOrderByWithRelationInput | QuizzesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quizzes.
     */
    cursor?: QuizzesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    distinct?: QuizzesScalarFieldEnum | QuizzesScalarFieldEnum[]
  }

  /**
   * Quizzes create
   */
  export type QuizzesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quizzes
     */
    select?: QuizzesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizzesInclude<ExtArgs> | null
    /**
     * The data needed to create a Quizzes.
     */
    data: XOR<QuizzesCreateInput, QuizzesUncheckedCreateInput>
  }

  /**
   * Quizzes createMany
   */
  export type QuizzesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quizzes.
     */
    data: QuizzesCreateManyInput | QuizzesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quizzes update
   */
  export type QuizzesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quizzes
     */
    select?: QuizzesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizzesInclude<ExtArgs> | null
    /**
     * The data needed to update a Quizzes.
     */
    data: XOR<QuizzesUpdateInput, QuizzesUncheckedUpdateInput>
    /**
     * Choose, which Quizzes to update.
     */
    where: QuizzesWhereUniqueInput
  }

  /**
   * Quizzes updateMany
   */
  export type QuizzesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quizzes.
     */
    data: XOR<QuizzesUpdateManyMutationInput, QuizzesUncheckedUpdateManyInput>
    /**
     * Filter which Quizzes to update
     */
    where?: QuizzesWhereInput
  }

  /**
   * Quizzes upsert
   */
  export type QuizzesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quizzes
     */
    select?: QuizzesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizzesInclude<ExtArgs> | null
    /**
     * The filter to search for the Quizzes to update in case it exists.
     */
    where: QuizzesWhereUniqueInput
    /**
     * In case the Quizzes found by the `where` argument doesn't exist, create a new Quizzes with this data.
     */
    create: XOR<QuizzesCreateInput, QuizzesUncheckedCreateInput>
    /**
     * In case the Quizzes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizzesUpdateInput, QuizzesUncheckedUpdateInput>
  }

  /**
   * Quizzes delete
   */
  export type QuizzesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quizzes
     */
    select?: QuizzesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizzesInclude<ExtArgs> | null
    /**
     * Filter which Quizzes to delete.
     */
    where: QuizzesWhereUniqueInput
  }

  /**
   * Quizzes deleteMany
   */
  export type QuizzesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quizzes to delete
     */
    where?: QuizzesWhereInput
  }

  /**
   * Quizzes.Media
   */
  export type Quizzes$MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * Quizzes.QuizzesLang
   */
  export type Quizzes$QuizzesLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizzesLang
     */
    select?: QuizzesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizzesLangInclude<ExtArgs> | null
    where?: QuizzesLangWhereInput
    orderBy?: QuizzesLangOrderByWithRelationInput | QuizzesLangOrderByWithRelationInput[]
    cursor?: QuizzesLangWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizzesLangScalarFieldEnum | QuizzesLangScalarFieldEnum[]
  }

  /**
   * Quizzes.Relations
   */
  export type Quizzes$RelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relations
     */
    select?: RelationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsInclude<ExtArgs> | null
    where?: RelationsWhereInput
    orderBy?: RelationsOrderByWithRelationInput | RelationsOrderByWithRelationInput[]
    cursor?: RelationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelationsScalarFieldEnum | RelationsScalarFieldEnum[]
  }

  /**
   * Quizzes without action
   */
  export type QuizzesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quizzes
     */
    select?: QuizzesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizzesInclude<ExtArgs> | null
  }


  /**
   * Model QuizzesLang
   */

  export type AggregateQuizzesLang = {
    _count: QuizzesLangCountAggregateOutputType | null
    _avg: QuizzesLangAvgAggregateOutputType | null
    _sum: QuizzesLangSumAggregateOutputType | null
    _min: QuizzesLangMinAggregateOutputType | null
    _max: QuizzesLangMaxAggregateOutputType | null
  }

  export type QuizzesLangAvgAggregateOutputType = {
    id: number | null
    qzId: number | null
    lang: number | null
    audio: number | null
  }

  export type QuizzesLangSumAggregateOutputType = {
    id: bigint | null
    qzId: bigint | null
    lang: bigint | null
    audio: bigint | null
  }

  export type QuizzesLangMinAggregateOutputType = {
    id: bigint | null
    qzId: bigint | null
    lang: bigint | null
    name: string | null
    desc: string | null
    audio: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type QuizzesLangMaxAggregateOutputType = {
    id: bigint | null
    qzId: bigint | null
    lang: bigint | null
    name: string | null
    desc: string | null
    audio: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type QuizzesLangCountAggregateOutputType = {
    id: number
    qzId: number
    lang: number
    name: number
    desc: number
    audio: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type QuizzesLangAvgAggregateInputType = {
    id?: true
    qzId?: true
    lang?: true
    audio?: true
  }

  export type QuizzesLangSumAggregateInputType = {
    id?: true
    qzId?: true
    lang?: true
    audio?: true
  }

  export type QuizzesLangMinAggregateInputType = {
    id?: true
    qzId?: true
    lang?: true
    name?: true
    desc?: true
    audio?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type QuizzesLangMaxAggregateInputType = {
    id?: true
    qzId?: true
    lang?: true
    name?: true
    desc?: true
    audio?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type QuizzesLangCountAggregateInputType = {
    id?: true
    qzId?: true
    lang?: true
    name?: true
    desc?: true
    audio?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type QuizzesLangAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizzesLang to aggregate.
     */
    where?: QuizzesLangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizzesLangs to fetch.
     */
    orderBy?: QuizzesLangOrderByWithRelationInput | QuizzesLangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizzesLangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizzesLangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizzesLangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizzesLangs
    **/
    _count?: true | QuizzesLangCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizzesLangAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizzesLangSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizzesLangMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizzesLangMaxAggregateInputType
  }

  export type GetQuizzesLangAggregateType<T extends QuizzesLangAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizzesLang]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizzesLang[P]>
      : GetScalarType<T[P], AggregateQuizzesLang[P]>
  }




  export type QuizzesLangGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizzesLangWhereInput
    orderBy?: QuizzesLangOrderByWithAggregationInput | QuizzesLangOrderByWithAggregationInput[]
    by: QuizzesLangScalarFieldEnum[] | QuizzesLangScalarFieldEnum
    having?: QuizzesLangScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizzesLangCountAggregateInputType | true
    _avg?: QuizzesLangAvgAggregateInputType
    _sum?: QuizzesLangSumAggregateInputType
    _min?: QuizzesLangMinAggregateInputType
    _max?: QuizzesLangMaxAggregateInputType
  }

  export type QuizzesLangGroupByOutputType = {
    id: bigint
    qzId: bigint
    lang: bigint
    name: string
    desc: string | null
    audio: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: QuizzesLangCountAggregateOutputType | null
    _avg: QuizzesLangAvgAggregateOutputType | null
    _sum: QuizzesLangSumAggregateOutputType | null
    _min: QuizzesLangMinAggregateOutputType | null
    _max: QuizzesLangMaxAggregateOutputType | null
  }

  type GetQuizzesLangGroupByPayload<T extends QuizzesLangGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizzesLangGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizzesLangGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizzesLangGroupByOutputType[P]>
            : GetScalarType<T[P], QuizzesLangGroupByOutputType[P]>
        }
      >
    >


  export type QuizzesLangSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    qzId?: boolean
    lang?: boolean
    name?: boolean
    desc?: boolean
    audio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    Quizzes?: boolean | QuizzesDefaultArgs<ExtArgs>
    Languages?: boolean | LanguagesDefaultArgs<ExtArgs>
    Audio?: boolean | QuizzesLang$AudioArgs<ExtArgs>
  }, ExtArgs["result"]["quizzesLang"]>


  export type QuizzesLangSelectScalar = {
    id?: boolean
    qzId?: boolean
    lang?: boolean
    name?: boolean
    desc?: boolean
    audio?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type QuizzesLangInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Quizzes?: boolean | QuizzesDefaultArgs<ExtArgs>
    Languages?: boolean | LanguagesDefaultArgs<ExtArgs>
    Audio?: boolean | QuizzesLang$AudioArgs<ExtArgs>
  }

  export type $QuizzesLangPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizzesLang"
    objects: {
      Quizzes: Prisma.$QuizzesPayload<ExtArgs>
      Languages: Prisma.$LanguagesPayload<ExtArgs>
      Audio: Prisma.$AudioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      qzId: bigint
      lang: bigint
      name: string
      desc: string | null
      audio: bigint | null
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["quizzesLang"]>
    composites: {}
  }

  type QuizzesLangGetPayload<S extends boolean | null | undefined | QuizzesLangDefaultArgs> = $Result.GetResult<Prisma.$QuizzesLangPayload, S>

  type QuizzesLangCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuizzesLangFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuizzesLangCountAggregateInputType | true
    }

  export interface QuizzesLangDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizzesLang'], meta: { name: 'QuizzesLang' } }
    /**
     * Find zero or one QuizzesLang that matches the filter.
     * @param {QuizzesLangFindUniqueArgs} args - Arguments to find a QuizzesLang
     * @example
     * // Get one QuizzesLang
     * const quizzesLang = await prisma.quizzesLang.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizzesLangFindUniqueArgs>(args: SelectSubset<T, QuizzesLangFindUniqueArgs<ExtArgs>>): Prisma__QuizzesLangClient<$Result.GetResult<Prisma.$QuizzesLangPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QuizzesLang that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuizzesLangFindUniqueOrThrowArgs} args - Arguments to find a QuizzesLang
     * @example
     * // Get one QuizzesLang
     * const quizzesLang = await prisma.quizzesLang.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizzesLangFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizzesLangFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizzesLangClient<$Result.GetResult<Prisma.$QuizzesLangPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QuizzesLang that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizzesLangFindFirstArgs} args - Arguments to find a QuizzesLang
     * @example
     * // Get one QuizzesLang
     * const quizzesLang = await prisma.quizzesLang.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizzesLangFindFirstArgs>(args?: SelectSubset<T, QuizzesLangFindFirstArgs<ExtArgs>>): Prisma__QuizzesLangClient<$Result.GetResult<Prisma.$QuizzesLangPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QuizzesLang that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizzesLangFindFirstOrThrowArgs} args - Arguments to find a QuizzesLang
     * @example
     * // Get one QuizzesLang
     * const quizzesLang = await prisma.quizzesLang.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizzesLangFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizzesLangFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizzesLangClient<$Result.GetResult<Prisma.$QuizzesLangPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QuizzesLangs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizzesLangFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizzesLangs
     * const quizzesLangs = await prisma.quizzesLang.findMany()
     * 
     * // Get first 10 QuizzesLangs
     * const quizzesLangs = await prisma.quizzesLang.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizzesLangWithIdOnly = await prisma.quizzesLang.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizzesLangFindManyArgs>(args?: SelectSubset<T, QuizzesLangFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizzesLangPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QuizzesLang.
     * @param {QuizzesLangCreateArgs} args - Arguments to create a QuizzesLang.
     * @example
     * // Create one QuizzesLang
     * const QuizzesLang = await prisma.quizzesLang.create({
     *   data: {
     *     // ... data to create a QuizzesLang
     *   }
     * })
     * 
     */
    create<T extends QuizzesLangCreateArgs>(args: SelectSubset<T, QuizzesLangCreateArgs<ExtArgs>>): Prisma__QuizzesLangClient<$Result.GetResult<Prisma.$QuizzesLangPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QuizzesLangs.
     * @param {QuizzesLangCreateManyArgs} args - Arguments to create many QuizzesLangs.
     * @example
     * // Create many QuizzesLangs
     * const quizzesLang = await prisma.quizzesLang.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizzesLangCreateManyArgs>(args?: SelectSubset<T, QuizzesLangCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a QuizzesLang.
     * @param {QuizzesLangDeleteArgs} args - Arguments to delete one QuizzesLang.
     * @example
     * // Delete one QuizzesLang
     * const QuizzesLang = await prisma.quizzesLang.delete({
     *   where: {
     *     // ... filter to delete one QuizzesLang
     *   }
     * })
     * 
     */
    delete<T extends QuizzesLangDeleteArgs>(args: SelectSubset<T, QuizzesLangDeleteArgs<ExtArgs>>): Prisma__QuizzesLangClient<$Result.GetResult<Prisma.$QuizzesLangPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QuizzesLang.
     * @param {QuizzesLangUpdateArgs} args - Arguments to update one QuizzesLang.
     * @example
     * // Update one QuizzesLang
     * const quizzesLang = await prisma.quizzesLang.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizzesLangUpdateArgs>(args: SelectSubset<T, QuizzesLangUpdateArgs<ExtArgs>>): Prisma__QuizzesLangClient<$Result.GetResult<Prisma.$QuizzesLangPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QuizzesLangs.
     * @param {QuizzesLangDeleteManyArgs} args - Arguments to filter QuizzesLangs to delete.
     * @example
     * // Delete a few QuizzesLangs
     * const { count } = await prisma.quizzesLang.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizzesLangDeleteManyArgs>(args?: SelectSubset<T, QuizzesLangDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizzesLangs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizzesLangUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizzesLangs
     * const quizzesLang = await prisma.quizzesLang.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizzesLangUpdateManyArgs>(args: SelectSubset<T, QuizzesLangUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuizzesLang.
     * @param {QuizzesLangUpsertArgs} args - Arguments to update or create a QuizzesLang.
     * @example
     * // Update or create a QuizzesLang
     * const quizzesLang = await prisma.quizzesLang.upsert({
     *   create: {
     *     // ... data to create a QuizzesLang
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizzesLang we want to update
     *   }
     * })
     */
    upsert<T extends QuizzesLangUpsertArgs>(args: SelectSubset<T, QuizzesLangUpsertArgs<ExtArgs>>): Prisma__QuizzesLangClient<$Result.GetResult<Prisma.$QuizzesLangPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QuizzesLangs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizzesLangCountArgs} args - Arguments to filter QuizzesLangs to count.
     * @example
     * // Count the number of QuizzesLangs
     * const count = await prisma.quizzesLang.count({
     *   where: {
     *     // ... the filter for the QuizzesLangs we want to count
     *   }
     * })
    **/
    count<T extends QuizzesLangCountArgs>(
      args?: Subset<T, QuizzesLangCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizzesLangCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizzesLang.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizzesLangAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizzesLangAggregateArgs>(args: Subset<T, QuizzesLangAggregateArgs>): Prisma.PrismaPromise<GetQuizzesLangAggregateType<T>>

    /**
     * Group by QuizzesLang.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizzesLangGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizzesLangGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizzesLangGroupByArgs['orderBy'] }
        : { orderBy?: QuizzesLangGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizzesLangGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizzesLangGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizzesLang model
   */
  readonly fields: QuizzesLangFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizzesLang.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizzesLangClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Quizzes<T extends QuizzesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizzesDefaultArgs<ExtArgs>>): Prisma__QuizzesClient<$Result.GetResult<Prisma.$QuizzesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Languages<T extends LanguagesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LanguagesDefaultArgs<ExtArgs>>): Prisma__LanguagesClient<$Result.GetResult<Prisma.$LanguagesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Audio<T extends QuizzesLang$AudioArgs<ExtArgs> = {}>(args?: Subset<T, QuizzesLang$AudioArgs<ExtArgs>>): Prisma__AudioClient<$Result.GetResult<Prisma.$AudioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizzesLang model
   */ 
  interface QuizzesLangFieldRefs {
    readonly id: FieldRef<"QuizzesLang", 'BigInt'>
    readonly qzId: FieldRef<"QuizzesLang", 'BigInt'>
    readonly lang: FieldRef<"QuizzesLang", 'BigInt'>
    readonly name: FieldRef<"QuizzesLang", 'String'>
    readonly desc: FieldRef<"QuizzesLang", 'String'>
    readonly audio: FieldRef<"QuizzesLang", 'BigInt'>
    readonly createdAt: FieldRef<"QuizzesLang", 'DateTime'>
    readonly updatedAt: FieldRef<"QuizzesLang", 'DateTime'>
    readonly deletedAt: FieldRef<"QuizzesLang", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizzesLang findUnique
   */
  export type QuizzesLangFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizzesLang
     */
    select?: QuizzesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizzesLangInclude<ExtArgs> | null
    /**
     * Filter, which QuizzesLang to fetch.
     */
    where: QuizzesLangWhereUniqueInput
  }

  /**
   * QuizzesLang findUniqueOrThrow
   */
  export type QuizzesLangFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizzesLang
     */
    select?: QuizzesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizzesLangInclude<ExtArgs> | null
    /**
     * Filter, which QuizzesLang to fetch.
     */
    where: QuizzesLangWhereUniqueInput
  }

  /**
   * QuizzesLang findFirst
   */
  export type QuizzesLangFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizzesLang
     */
    select?: QuizzesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizzesLangInclude<ExtArgs> | null
    /**
     * Filter, which QuizzesLang to fetch.
     */
    where?: QuizzesLangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizzesLangs to fetch.
     */
    orderBy?: QuizzesLangOrderByWithRelationInput | QuizzesLangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizzesLangs.
     */
    cursor?: QuizzesLangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizzesLangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizzesLangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizzesLangs.
     */
    distinct?: QuizzesLangScalarFieldEnum | QuizzesLangScalarFieldEnum[]
  }

  /**
   * QuizzesLang findFirstOrThrow
   */
  export type QuizzesLangFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizzesLang
     */
    select?: QuizzesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizzesLangInclude<ExtArgs> | null
    /**
     * Filter, which QuizzesLang to fetch.
     */
    where?: QuizzesLangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizzesLangs to fetch.
     */
    orderBy?: QuizzesLangOrderByWithRelationInput | QuizzesLangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizzesLangs.
     */
    cursor?: QuizzesLangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizzesLangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizzesLangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizzesLangs.
     */
    distinct?: QuizzesLangScalarFieldEnum | QuizzesLangScalarFieldEnum[]
  }

  /**
   * QuizzesLang findMany
   */
  export type QuizzesLangFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizzesLang
     */
    select?: QuizzesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizzesLangInclude<ExtArgs> | null
    /**
     * Filter, which QuizzesLangs to fetch.
     */
    where?: QuizzesLangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizzesLangs to fetch.
     */
    orderBy?: QuizzesLangOrderByWithRelationInput | QuizzesLangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizzesLangs.
     */
    cursor?: QuizzesLangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizzesLangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizzesLangs.
     */
    skip?: number
    distinct?: QuizzesLangScalarFieldEnum | QuizzesLangScalarFieldEnum[]
  }

  /**
   * QuizzesLang create
   */
  export type QuizzesLangCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizzesLang
     */
    select?: QuizzesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizzesLangInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizzesLang.
     */
    data: XOR<QuizzesLangCreateInput, QuizzesLangUncheckedCreateInput>
  }

  /**
   * QuizzesLang createMany
   */
  export type QuizzesLangCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizzesLangs.
     */
    data: QuizzesLangCreateManyInput | QuizzesLangCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizzesLang update
   */
  export type QuizzesLangUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizzesLang
     */
    select?: QuizzesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizzesLangInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizzesLang.
     */
    data: XOR<QuizzesLangUpdateInput, QuizzesLangUncheckedUpdateInput>
    /**
     * Choose, which QuizzesLang to update.
     */
    where: QuizzesLangWhereUniqueInput
  }

  /**
   * QuizzesLang updateMany
   */
  export type QuizzesLangUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizzesLangs.
     */
    data: XOR<QuizzesLangUpdateManyMutationInput, QuizzesLangUncheckedUpdateManyInput>
    /**
     * Filter which QuizzesLangs to update
     */
    where?: QuizzesLangWhereInput
  }

  /**
   * QuizzesLang upsert
   */
  export type QuizzesLangUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizzesLang
     */
    select?: QuizzesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizzesLangInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizzesLang to update in case it exists.
     */
    where: QuizzesLangWhereUniqueInput
    /**
     * In case the QuizzesLang found by the `where` argument doesn't exist, create a new QuizzesLang with this data.
     */
    create: XOR<QuizzesLangCreateInput, QuizzesLangUncheckedCreateInput>
    /**
     * In case the QuizzesLang was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizzesLangUpdateInput, QuizzesLangUncheckedUpdateInput>
  }

  /**
   * QuizzesLang delete
   */
  export type QuizzesLangDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizzesLang
     */
    select?: QuizzesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizzesLangInclude<ExtArgs> | null
    /**
     * Filter which QuizzesLang to delete.
     */
    where: QuizzesLangWhereUniqueInput
  }

  /**
   * QuizzesLang deleteMany
   */
  export type QuizzesLangDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizzesLangs to delete
     */
    where?: QuizzesLangWhereInput
  }

  /**
   * QuizzesLang.Audio
   */
  export type QuizzesLang$AudioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Audio
     */
    select?: AudioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioInclude<ExtArgs> | null
    where?: AudioWhereInput
  }

  /**
   * QuizzesLang without action
   */
  export type QuizzesLangDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizzesLang
     */
    select?: QuizzesLangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizzesLangInclude<ExtArgs> | null
  }


  /**
   * Model Relations
   */

  export type AggregateRelations = {
    _count: RelationsCountAggregateOutputType | null
    _avg: RelationsAvgAggregateOutputType | null
    _sum: RelationsSumAggregateOutputType | null
    _min: RelationsMinAggregateOutputType | null
    _max: RelationsMaxAggregateOutputType | null
  }

  export type RelationsAvgAggregateOutputType = {
    id: number | null
    liId: number | null
    gpId: number | null
    qzId: number | null
  }

  export type RelationsSumAggregateOutputType = {
    id: bigint | null
    liId: bigint | null
    gpId: bigint | null
    qzId: bigint | null
  }

  export type RelationsMinAggregateOutputType = {
    id: bigint | null
    liId: bigint | null
    gpId: bigint | null
    qzId: bigint | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type RelationsMaxAggregateOutputType = {
    id: bigint | null
    liId: bigint | null
    gpId: bigint | null
    qzId: bigint | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type RelationsCountAggregateOutputType = {
    id: number
    liId: number
    gpId: number
    qzId: number
    enabled: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type RelationsAvgAggregateInputType = {
    id?: true
    liId?: true
    gpId?: true
    qzId?: true
  }

  export type RelationsSumAggregateInputType = {
    id?: true
    liId?: true
    gpId?: true
    qzId?: true
  }

  export type RelationsMinAggregateInputType = {
    id?: true
    liId?: true
    gpId?: true
    qzId?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type RelationsMaxAggregateInputType = {
    id?: true
    liId?: true
    gpId?: true
    qzId?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type RelationsCountAggregateInputType = {
    id?: true
    liId?: true
    gpId?: true
    qzId?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type RelationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Relations to aggregate.
     */
    where?: RelationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Relations to fetch.
     */
    orderBy?: RelationsOrderByWithRelationInput | RelationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Relations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Relations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Relations
    **/
    _count?: true | RelationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RelationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RelationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelationsMaxAggregateInputType
  }

  export type GetRelationsAggregateType<T extends RelationsAggregateArgs> = {
        [P in keyof T & keyof AggregateRelations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelations[P]>
      : GetScalarType<T[P], AggregateRelations[P]>
  }




  export type RelationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationsWhereInput
    orderBy?: RelationsOrderByWithAggregationInput | RelationsOrderByWithAggregationInput[]
    by: RelationsScalarFieldEnum[] | RelationsScalarFieldEnum
    having?: RelationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelationsCountAggregateInputType | true
    _avg?: RelationsAvgAggregateInputType
    _sum?: RelationsSumAggregateInputType
    _min?: RelationsMinAggregateInputType
    _max?: RelationsMaxAggregateInputType
  }

  export type RelationsGroupByOutputType = {
    id: bigint
    liId: bigint
    gpId: bigint
    qzId: bigint
    enabled: boolean
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: RelationsCountAggregateOutputType | null
    _avg: RelationsAvgAggregateOutputType | null
    _sum: RelationsSumAggregateOutputType | null
    _min: RelationsMinAggregateOutputType | null
    _max: RelationsMaxAggregateOutputType | null
  }

  type GetRelationsGroupByPayload<T extends RelationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelationsGroupByOutputType[P]>
            : GetScalarType<T[P], RelationsGroupByOutputType[P]>
        }
      >
    >


  export type RelationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    liId?: boolean
    gpId?: boolean
    qzId?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    Licenses?: boolean | LicensesDefaultArgs<ExtArgs>
    Groups?: boolean | GroupsDefaultArgs<ExtArgs>
    Quizzes?: boolean | QuizzesDefaultArgs<ExtArgs>
    RelationsChoices?: boolean | Relations$RelationsChoicesArgs<ExtArgs>
    RelationsQuestions?: boolean | Relations$RelationsQuestionsArgs<ExtArgs>
    UsersRelations?: boolean | Relations$UsersRelationsArgs<ExtArgs>
    _count?: boolean | RelationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["relations"]>


  export type RelationsSelectScalar = {
    id?: boolean
    liId?: boolean
    gpId?: boolean
    qzId?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type RelationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Licenses?: boolean | LicensesDefaultArgs<ExtArgs>
    Groups?: boolean | GroupsDefaultArgs<ExtArgs>
    Quizzes?: boolean | QuizzesDefaultArgs<ExtArgs>
    RelationsChoices?: boolean | Relations$RelationsChoicesArgs<ExtArgs>
    RelationsQuestions?: boolean | Relations$RelationsQuestionsArgs<ExtArgs>
    UsersRelations?: boolean | Relations$UsersRelationsArgs<ExtArgs>
    _count?: boolean | RelationsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RelationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Relations"
    objects: {
      Licenses: Prisma.$LicensesPayload<ExtArgs>
      Groups: Prisma.$GroupsPayload<ExtArgs>
      Quizzes: Prisma.$QuizzesPayload<ExtArgs>
      RelationsChoices: Prisma.$RelationsChoicesPayload<ExtArgs>[]
      RelationsQuestions: Prisma.$RelationsQuestionsPayload<ExtArgs>[]
      UsersRelations: Prisma.$UsersRelationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      liId: bigint
      gpId: bigint
      qzId: bigint
      enabled: boolean
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["relations"]>
    composites: {}
  }

  type RelationsGetPayload<S extends boolean | null | undefined | RelationsDefaultArgs> = $Result.GetResult<Prisma.$RelationsPayload, S>

  type RelationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RelationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RelationsCountAggregateInputType | true
    }

  export interface RelationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Relations'], meta: { name: 'Relations' } }
    /**
     * Find zero or one Relations that matches the filter.
     * @param {RelationsFindUniqueArgs} args - Arguments to find a Relations
     * @example
     * // Get one Relations
     * const relations = await prisma.relations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RelationsFindUniqueArgs>(args: SelectSubset<T, RelationsFindUniqueArgs<ExtArgs>>): Prisma__RelationsClient<$Result.GetResult<Prisma.$RelationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Relations that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RelationsFindUniqueOrThrowArgs} args - Arguments to find a Relations
     * @example
     * // Get one Relations
     * const relations = await prisma.relations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RelationsFindUniqueOrThrowArgs>(args: SelectSubset<T, RelationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RelationsClient<$Result.GetResult<Prisma.$RelationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Relations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationsFindFirstArgs} args - Arguments to find a Relations
     * @example
     * // Get one Relations
     * const relations = await prisma.relations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RelationsFindFirstArgs>(args?: SelectSubset<T, RelationsFindFirstArgs<ExtArgs>>): Prisma__RelationsClient<$Result.GetResult<Prisma.$RelationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Relations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationsFindFirstOrThrowArgs} args - Arguments to find a Relations
     * @example
     * // Get one Relations
     * const relations = await prisma.relations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RelationsFindFirstOrThrowArgs>(args?: SelectSubset<T, RelationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__RelationsClient<$Result.GetResult<Prisma.$RelationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Relations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Relations
     * const relations = await prisma.relations.findMany()
     * 
     * // Get first 10 Relations
     * const relations = await prisma.relations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relationsWithIdOnly = await prisma.relations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RelationsFindManyArgs>(args?: SelectSubset<T, RelationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Relations.
     * @param {RelationsCreateArgs} args - Arguments to create a Relations.
     * @example
     * // Create one Relations
     * const Relations = await prisma.relations.create({
     *   data: {
     *     // ... data to create a Relations
     *   }
     * })
     * 
     */
    create<T extends RelationsCreateArgs>(args: SelectSubset<T, RelationsCreateArgs<ExtArgs>>): Prisma__RelationsClient<$Result.GetResult<Prisma.$RelationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Relations.
     * @param {RelationsCreateManyArgs} args - Arguments to create many Relations.
     * @example
     * // Create many Relations
     * const relations = await prisma.relations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RelationsCreateManyArgs>(args?: SelectSubset<T, RelationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Relations.
     * @param {RelationsDeleteArgs} args - Arguments to delete one Relations.
     * @example
     * // Delete one Relations
     * const Relations = await prisma.relations.delete({
     *   where: {
     *     // ... filter to delete one Relations
     *   }
     * })
     * 
     */
    delete<T extends RelationsDeleteArgs>(args: SelectSubset<T, RelationsDeleteArgs<ExtArgs>>): Prisma__RelationsClient<$Result.GetResult<Prisma.$RelationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Relations.
     * @param {RelationsUpdateArgs} args - Arguments to update one Relations.
     * @example
     * // Update one Relations
     * const relations = await prisma.relations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RelationsUpdateArgs>(args: SelectSubset<T, RelationsUpdateArgs<ExtArgs>>): Prisma__RelationsClient<$Result.GetResult<Prisma.$RelationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Relations.
     * @param {RelationsDeleteManyArgs} args - Arguments to filter Relations to delete.
     * @example
     * // Delete a few Relations
     * const { count } = await prisma.relations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RelationsDeleteManyArgs>(args?: SelectSubset<T, RelationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Relations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Relations
     * const relations = await prisma.relations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RelationsUpdateManyArgs>(args: SelectSubset<T, RelationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Relations.
     * @param {RelationsUpsertArgs} args - Arguments to update or create a Relations.
     * @example
     * // Update or create a Relations
     * const relations = await prisma.relations.upsert({
     *   create: {
     *     // ... data to create a Relations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Relations we want to update
     *   }
     * })
     */
    upsert<T extends RelationsUpsertArgs>(args: SelectSubset<T, RelationsUpsertArgs<ExtArgs>>): Prisma__RelationsClient<$Result.GetResult<Prisma.$RelationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Relations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationsCountArgs} args - Arguments to filter Relations to count.
     * @example
     * // Count the number of Relations
     * const count = await prisma.relations.count({
     *   where: {
     *     // ... the filter for the Relations we want to count
     *   }
     * })
    **/
    count<T extends RelationsCountArgs>(
      args?: Subset<T, RelationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Relations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelationsAggregateArgs>(args: Subset<T, RelationsAggregateArgs>): Prisma.PrismaPromise<GetRelationsAggregateType<T>>

    /**
     * Group by Relations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelationsGroupByArgs['orderBy'] }
        : { orderBy?: RelationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Relations model
   */
  readonly fields: RelationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Relations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Licenses<T extends LicensesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LicensesDefaultArgs<ExtArgs>>): Prisma__LicensesClient<$Result.GetResult<Prisma.$LicensesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Groups<T extends GroupsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupsDefaultArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Quizzes<T extends QuizzesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizzesDefaultArgs<ExtArgs>>): Prisma__QuizzesClient<$Result.GetResult<Prisma.$QuizzesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    RelationsChoices<T extends Relations$RelationsChoicesArgs<ExtArgs> = {}>(args?: Subset<T, Relations$RelationsChoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationsChoicesPayload<ExtArgs>, T, "findMany"> | Null>
    RelationsQuestions<T extends Relations$RelationsQuestionsArgs<ExtArgs> = {}>(args?: Subset<T, Relations$RelationsQuestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationsQuestionsPayload<ExtArgs>, T, "findMany"> | Null>
    UsersRelations<T extends Relations$UsersRelationsArgs<ExtArgs> = {}>(args?: Subset<T, Relations$UsersRelationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersRelationsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Relations model
   */ 
  interface RelationsFieldRefs {
    readonly id: FieldRef<"Relations", 'BigInt'>
    readonly liId: FieldRef<"Relations", 'BigInt'>
    readonly gpId: FieldRef<"Relations", 'BigInt'>
    readonly qzId: FieldRef<"Relations", 'BigInt'>
    readonly enabled: FieldRef<"Relations", 'Boolean'>
    readonly createdAt: FieldRef<"Relations", 'DateTime'>
    readonly updatedAt: FieldRef<"Relations", 'DateTime'>
    readonly deletedAt: FieldRef<"Relations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Relations findUnique
   */
  export type RelationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relations
     */
    select?: RelationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsInclude<ExtArgs> | null
    /**
     * Filter, which Relations to fetch.
     */
    where: RelationsWhereUniqueInput
  }

  /**
   * Relations findUniqueOrThrow
   */
  export type RelationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relations
     */
    select?: RelationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsInclude<ExtArgs> | null
    /**
     * Filter, which Relations to fetch.
     */
    where: RelationsWhereUniqueInput
  }

  /**
   * Relations findFirst
   */
  export type RelationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relations
     */
    select?: RelationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsInclude<ExtArgs> | null
    /**
     * Filter, which Relations to fetch.
     */
    where?: RelationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Relations to fetch.
     */
    orderBy?: RelationsOrderByWithRelationInput | RelationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Relations.
     */
    cursor?: RelationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Relations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Relations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Relations.
     */
    distinct?: RelationsScalarFieldEnum | RelationsScalarFieldEnum[]
  }

  /**
   * Relations findFirstOrThrow
   */
  export type RelationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relations
     */
    select?: RelationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsInclude<ExtArgs> | null
    /**
     * Filter, which Relations to fetch.
     */
    where?: RelationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Relations to fetch.
     */
    orderBy?: RelationsOrderByWithRelationInput | RelationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Relations.
     */
    cursor?: RelationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Relations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Relations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Relations.
     */
    distinct?: RelationsScalarFieldEnum | RelationsScalarFieldEnum[]
  }

  /**
   * Relations findMany
   */
  export type RelationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relations
     */
    select?: RelationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsInclude<ExtArgs> | null
    /**
     * Filter, which Relations to fetch.
     */
    where?: RelationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Relations to fetch.
     */
    orderBy?: RelationsOrderByWithRelationInput | RelationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Relations.
     */
    cursor?: RelationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Relations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Relations.
     */
    skip?: number
    distinct?: RelationsScalarFieldEnum | RelationsScalarFieldEnum[]
  }

  /**
   * Relations create
   */
  export type RelationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relations
     */
    select?: RelationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsInclude<ExtArgs> | null
    /**
     * The data needed to create a Relations.
     */
    data: XOR<RelationsCreateInput, RelationsUncheckedCreateInput>
  }

  /**
   * Relations createMany
   */
  export type RelationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Relations.
     */
    data: RelationsCreateManyInput | RelationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Relations update
   */
  export type RelationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relations
     */
    select?: RelationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsInclude<ExtArgs> | null
    /**
     * The data needed to update a Relations.
     */
    data: XOR<RelationsUpdateInput, RelationsUncheckedUpdateInput>
    /**
     * Choose, which Relations to update.
     */
    where: RelationsWhereUniqueInput
  }

  /**
   * Relations updateMany
   */
  export type RelationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Relations.
     */
    data: XOR<RelationsUpdateManyMutationInput, RelationsUncheckedUpdateManyInput>
    /**
     * Filter which Relations to update
     */
    where?: RelationsWhereInput
  }

  /**
   * Relations upsert
   */
  export type RelationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relations
     */
    select?: RelationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsInclude<ExtArgs> | null
    /**
     * The filter to search for the Relations to update in case it exists.
     */
    where: RelationsWhereUniqueInput
    /**
     * In case the Relations found by the `where` argument doesn't exist, create a new Relations with this data.
     */
    create: XOR<RelationsCreateInput, RelationsUncheckedCreateInput>
    /**
     * In case the Relations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelationsUpdateInput, RelationsUncheckedUpdateInput>
  }

  /**
   * Relations delete
   */
  export type RelationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relations
     */
    select?: RelationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsInclude<ExtArgs> | null
    /**
     * Filter which Relations to delete.
     */
    where: RelationsWhereUniqueInput
  }

  /**
   * Relations deleteMany
   */
  export type RelationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Relations to delete
     */
    where?: RelationsWhereInput
  }

  /**
   * Relations.RelationsChoices
   */
  export type Relations$RelationsChoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsChoices
     */
    select?: RelationsChoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsChoicesInclude<ExtArgs> | null
    where?: RelationsChoicesWhereInput
    orderBy?: RelationsChoicesOrderByWithRelationInput | RelationsChoicesOrderByWithRelationInput[]
    cursor?: RelationsChoicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelationsChoicesScalarFieldEnum | RelationsChoicesScalarFieldEnum[]
  }

  /**
   * Relations.RelationsQuestions
   */
  export type Relations$RelationsQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsQuestions
     */
    select?: RelationsQuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsQuestionsInclude<ExtArgs> | null
    where?: RelationsQuestionsWhereInput
    orderBy?: RelationsQuestionsOrderByWithRelationInput | RelationsQuestionsOrderByWithRelationInput[]
    cursor?: RelationsQuestionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelationsQuestionsScalarFieldEnum | RelationsQuestionsScalarFieldEnum[]
  }

  /**
   * Relations.UsersRelations
   */
  export type Relations$UsersRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersRelations
     */
    select?: UsersRelationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersRelationsInclude<ExtArgs> | null
    where?: UsersRelationsWhereInput
    orderBy?: UsersRelationsOrderByWithRelationInput | UsersRelationsOrderByWithRelationInput[]
    cursor?: UsersRelationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersRelationsScalarFieldEnum | UsersRelationsScalarFieldEnum[]
  }

  /**
   * Relations without action
   */
  export type RelationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relations
     */
    select?: RelationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsInclude<ExtArgs> | null
  }


  /**
   * Model RelationsChoices
   */

  export type AggregateRelationsChoices = {
    _count: RelationsChoicesCountAggregateOutputType | null
    _avg: RelationsChoicesAvgAggregateOutputType | null
    _sum: RelationsChoicesSumAggregateOutputType | null
    _min: RelationsChoicesMinAggregateOutputType | null
    _max: RelationsChoicesMaxAggregateOutputType | null
  }

  export type RelationsChoicesAvgAggregateOutputType = {
    id: number | null
    rqId: number | null
    chId: number | null
    mdId: number | null
    ordering: number | null
    relationsId: number | null
  }

  export type RelationsChoicesSumAggregateOutputType = {
    id: bigint | null
    rqId: bigint | null
    chId: bigint | null
    mdId: bigint | null
    ordering: number | null
    relationsId: bigint | null
  }

  export type RelationsChoicesMinAggregateOutputType = {
    id: bigint | null
    rqId: bigint | null
    chId: bigint | null
    mdId: bigint | null
    correct: boolean | null
    ordering: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    relationsId: bigint | null
  }

  export type RelationsChoicesMaxAggregateOutputType = {
    id: bigint | null
    rqId: bigint | null
    chId: bigint | null
    mdId: bigint | null
    correct: boolean | null
    ordering: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    relationsId: bigint | null
  }

  export type RelationsChoicesCountAggregateOutputType = {
    id: number
    rqId: number
    chId: number
    mdId: number
    correct: number
    ordering: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    relationsId: number
    _all: number
  }


  export type RelationsChoicesAvgAggregateInputType = {
    id?: true
    rqId?: true
    chId?: true
    mdId?: true
    ordering?: true
    relationsId?: true
  }

  export type RelationsChoicesSumAggregateInputType = {
    id?: true
    rqId?: true
    chId?: true
    mdId?: true
    ordering?: true
    relationsId?: true
  }

  export type RelationsChoicesMinAggregateInputType = {
    id?: true
    rqId?: true
    chId?: true
    mdId?: true
    correct?: true
    ordering?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    relationsId?: true
  }

  export type RelationsChoicesMaxAggregateInputType = {
    id?: true
    rqId?: true
    chId?: true
    mdId?: true
    correct?: true
    ordering?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    relationsId?: true
  }

  export type RelationsChoicesCountAggregateInputType = {
    id?: true
    rqId?: true
    chId?: true
    mdId?: true
    correct?: true
    ordering?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    relationsId?: true
    _all?: true
  }

  export type RelationsChoicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelationsChoices to aggregate.
     */
    where?: RelationsChoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelationsChoices to fetch.
     */
    orderBy?: RelationsChoicesOrderByWithRelationInput | RelationsChoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelationsChoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelationsChoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelationsChoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RelationsChoices
    **/
    _count?: true | RelationsChoicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RelationsChoicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RelationsChoicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelationsChoicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelationsChoicesMaxAggregateInputType
  }

  export type GetRelationsChoicesAggregateType<T extends RelationsChoicesAggregateArgs> = {
        [P in keyof T & keyof AggregateRelationsChoices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelationsChoices[P]>
      : GetScalarType<T[P], AggregateRelationsChoices[P]>
  }




  export type RelationsChoicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationsChoicesWhereInput
    orderBy?: RelationsChoicesOrderByWithAggregationInput | RelationsChoicesOrderByWithAggregationInput[]
    by: RelationsChoicesScalarFieldEnum[] | RelationsChoicesScalarFieldEnum
    having?: RelationsChoicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelationsChoicesCountAggregateInputType | true
    _avg?: RelationsChoicesAvgAggregateInputType
    _sum?: RelationsChoicesSumAggregateInputType
    _min?: RelationsChoicesMinAggregateInputType
    _max?: RelationsChoicesMaxAggregateInputType
  }

  export type RelationsChoicesGroupByOutputType = {
    id: bigint
    rqId: bigint
    chId: bigint
    mdId: bigint | null
    correct: boolean
    ordering: number
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    relationsId: bigint | null
    _count: RelationsChoicesCountAggregateOutputType | null
    _avg: RelationsChoicesAvgAggregateOutputType | null
    _sum: RelationsChoicesSumAggregateOutputType | null
    _min: RelationsChoicesMinAggregateOutputType | null
    _max: RelationsChoicesMaxAggregateOutputType | null
  }

  type GetRelationsChoicesGroupByPayload<T extends RelationsChoicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelationsChoicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelationsChoicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelationsChoicesGroupByOutputType[P]>
            : GetScalarType<T[P], RelationsChoicesGroupByOutputType[P]>
        }
      >
    >


  export type RelationsChoicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rqId?: boolean
    chId?: boolean
    mdId?: boolean
    correct?: boolean
    ordering?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    relationsId?: boolean
    Choices?: boolean | ChoicesDefaultArgs<ExtArgs>
    Media?: boolean | RelationsChoices$MediaArgs<ExtArgs>
    RelationsQuestions?: boolean | RelationsQuestionsDefaultArgs<ExtArgs>
    Relations?: boolean | RelationsChoices$RelationsArgs<ExtArgs>
    UsersRelationsDetails?: boolean | RelationsChoices$UsersRelationsDetailsArgs<ExtArgs>
    _count?: boolean | RelationsChoicesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["relationsChoices"]>


  export type RelationsChoicesSelectScalar = {
    id?: boolean
    rqId?: boolean
    chId?: boolean
    mdId?: boolean
    correct?: boolean
    ordering?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    relationsId?: boolean
  }

  export type RelationsChoicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Choices?: boolean | ChoicesDefaultArgs<ExtArgs>
    Media?: boolean | RelationsChoices$MediaArgs<ExtArgs>
    RelationsQuestions?: boolean | RelationsQuestionsDefaultArgs<ExtArgs>
    Relations?: boolean | RelationsChoices$RelationsArgs<ExtArgs>
    UsersRelationsDetails?: boolean | RelationsChoices$UsersRelationsDetailsArgs<ExtArgs>
    _count?: boolean | RelationsChoicesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RelationsChoicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RelationsChoices"
    objects: {
      Choices: Prisma.$ChoicesPayload<ExtArgs>
      Media: Prisma.$MediaPayload<ExtArgs> | null
      RelationsQuestions: Prisma.$RelationsQuestionsPayload<ExtArgs>
      Relations: Prisma.$RelationsPayload<ExtArgs> | null
      UsersRelationsDetails: Prisma.$UsersRelationsDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      rqId: bigint
      chId: bigint
      mdId: bigint | null
      correct: boolean
      ordering: number
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
      relationsId: bigint | null
    }, ExtArgs["result"]["relationsChoices"]>
    composites: {}
  }

  type RelationsChoicesGetPayload<S extends boolean | null | undefined | RelationsChoicesDefaultArgs> = $Result.GetResult<Prisma.$RelationsChoicesPayload, S>

  type RelationsChoicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RelationsChoicesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RelationsChoicesCountAggregateInputType | true
    }

  export interface RelationsChoicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RelationsChoices'], meta: { name: 'RelationsChoices' } }
    /**
     * Find zero or one RelationsChoices that matches the filter.
     * @param {RelationsChoicesFindUniqueArgs} args - Arguments to find a RelationsChoices
     * @example
     * // Get one RelationsChoices
     * const relationsChoices = await prisma.relationsChoices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RelationsChoicesFindUniqueArgs>(args: SelectSubset<T, RelationsChoicesFindUniqueArgs<ExtArgs>>): Prisma__RelationsChoicesClient<$Result.GetResult<Prisma.$RelationsChoicesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RelationsChoices that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RelationsChoicesFindUniqueOrThrowArgs} args - Arguments to find a RelationsChoices
     * @example
     * // Get one RelationsChoices
     * const relationsChoices = await prisma.relationsChoices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RelationsChoicesFindUniqueOrThrowArgs>(args: SelectSubset<T, RelationsChoicesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RelationsChoicesClient<$Result.GetResult<Prisma.$RelationsChoicesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RelationsChoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationsChoicesFindFirstArgs} args - Arguments to find a RelationsChoices
     * @example
     * // Get one RelationsChoices
     * const relationsChoices = await prisma.relationsChoices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RelationsChoicesFindFirstArgs>(args?: SelectSubset<T, RelationsChoicesFindFirstArgs<ExtArgs>>): Prisma__RelationsChoicesClient<$Result.GetResult<Prisma.$RelationsChoicesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RelationsChoices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationsChoicesFindFirstOrThrowArgs} args - Arguments to find a RelationsChoices
     * @example
     * // Get one RelationsChoices
     * const relationsChoices = await prisma.relationsChoices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RelationsChoicesFindFirstOrThrowArgs>(args?: SelectSubset<T, RelationsChoicesFindFirstOrThrowArgs<ExtArgs>>): Prisma__RelationsChoicesClient<$Result.GetResult<Prisma.$RelationsChoicesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RelationsChoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationsChoicesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RelationsChoices
     * const relationsChoices = await prisma.relationsChoices.findMany()
     * 
     * // Get first 10 RelationsChoices
     * const relationsChoices = await prisma.relationsChoices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relationsChoicesWithIdOnly = await prisma.relationsChoices.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RelationsChoicesFindManyArgs>(args?: SelectSubset<T, RelationsChoicesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationsChoicesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RelationsChoices.
     * @param {RelationsChoicesCreateArgs} args - Arguments to create a RelationsChoices.
     * @example
     * // Create one RelationsChoices
     * const RelationsChoices = await prisma.relationsChoices.create({
     *   data: {
     *     // ... data to create a RelationsChoices
     *   }
     * })
     * 
     */
    create<T extends RelationsChoicesCreateArgs>(args: SelectSubset<T, RelationsChoicesCreateArgs<ExtArgs>>): Prisma__RelationsChoicesClient<$Result.GetResult<Prisma.$RelationsChoicesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RelationsChoices.
     * @param {RelationsChoicesCreateManyArgs} args - Arguments to create many RelationsChoices.
     * @example
     * // Create many RelationsChoices
     * const relationsChoices = await prisma.relationsChoices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RelationsChoicesCreateManyArgs>(args?: SelectSubset<T, RelationsChoicesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RelationsChoices.
     * @param {RelationsChoicesDeleteArgs} args - Arguments to delete one RelationsChoices.
     * @example
     * // Delete one RelationsChoices
     * const RelationsChoices = await prisma.relationsChoices.delete({
     *   where: {
     *     // ... filter to delete one RelationsChoices
     *   }
     * })
     * 
     */
    delete<T extends RelationsChoicesDeleteArgs>(args: SelectSubset<T, RelationsChoicesDeleteArgs<ExtArgs>>): Prisma__RelationsChoicesClient<$Result.GetResult<Prisma.$RelationsChoicesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RelationsChoices.
     * @param {RelationsChoicesUpdateArgs} args - Arguments to update one RelationsChoices.
     * @example
     * // Update one RelationsChoices
     * const relationsChoices = await prisma.relationsChoices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RelationsChoicesUpdateArgs>(args: SelectSubset<T, RelationsChoicesUpdateArgs<ExtArgs>>): Prisma__RelationsChoicesClient<$Result.GetResult<Prisma.$RelationsChoicesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RelationsChoices.
     * @param {RelationsChoicesDeleteManyArgs} args - Arguments to filter RelationsChoices to delete.
     * @example
     * // Delete a few RelationsChoices
     * const { count } = await prisma.relationsChoices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RelationsChoicesDeleteManyArgs>(args?: SelectSubset<T, RelationsChoicesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelationsChoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationsChoicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RelationsChoices
     * const relationsChoices = await prisma.relationsChoices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RelationsChoicesUpdateManyArgs>(args: SelectSubset<T, RelationsChoicesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RelationsChoices.
     * @param {RelationsChoicesUpsertArgs} args - Arguments to update or create a RelationsChoices.
     * @example
     * // Update or create a RelationsChoices
     * const relationsChoices = await prisma.relationsChoices.upsert({
     *   create: {
     *     // ... data to create a RelationsChoices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RelationsChoices we want to update
     *   }
     * })
     */
    upsert<T extends RelationsChoicesUpsertArgs>(args: SelectSubset<T, RelationsChoicesUpsertArgs<ExtArgs>>): Prisma__RelationsChoicesClient<$Result.GetResult<Prisma.$RelationsChoicesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RelationsChoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationsChoicesCountArgs} args - Arguments to filter RelationsChoices to count.
     * @example
     * // Count the number of RelationsChoices
     * const count = await prisma.relationsChoices.count({
     *   where: {
     *     // ... the filter for the RelationsChoices we want to count
     *   }
     * })
    **/
    count<T extends RelationsChoicesCountArgs>(
      args?: Subset<T, RelationsChoicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelationsChoicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RelationsChoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationsChoicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelationsChoicesAggregateArgs>(args: Subset<T, RelationsChoicesAggregateArgs>): Prisma.PrismaPromise<GetRelationsChoicesAggregateType<T>>

    /**
     * Group by RelationsChoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationsChoicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelationsChoicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelationsChoicesGroupByArgs['orderBy'] }
        : { orderBy?: RelationsChoicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelationsChoicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelationsChoicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RelationsChoices model
   */
  readonly fields: RelationsChoicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RelationsChoices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelationsChoicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Choices<T extends ChoicesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChoicesDefaultArgs<ExtArgs>>): Prisma__ChoicesClient<$Result.GetResult<Prisma.$ChoicesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Media<T extends RelationsChoices$MediaArgs<ExtArgs> = {}>(args?: Subset<T, RelationsChoices$MediaArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    RelationsQuestions<T extends RelationsQuestionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RelationsQuestionsDefaultArgs<ExtArgs>>): Prisma__RelationsQuestionsClient<$Result.GetResult<Prisma.$RelationsQuestionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Relations<T extends RelationsChoices$RelationsArgs<ExtArgs> = {}>(args?: Subset<T, RelationsChoices$RelationsArgs<ExtArgs>>): Prisma__RelationsClient<$Result.GetResult<Prisma.$RelationsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    UsersRelationsDetails<T extends RelationsChoices$UsersRelationsDetailsArgs<ExtArgs> = {}>(args?: Subset<T, RelationsChoices$UsersRelationsDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersRelationsDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RelationsChoices model
   */ 
  interface RelationsChoicesFieldRefs {
    readonly id: FieldRef<"RelationsChoices", 'BigInt'>
    readonly rqId: FieldRef<"RelationsChoices", 'BigInt'>
    readonly chId: FieldRef<"RelationsChoices", 'BigInt'>
    readonly mdId: FieldRef<"RelationsChoices", 'BigInt'>
    readonly correct: FieldRef<"RelationsChoices", 'Boolean'>
    readonly ordering: FieldRef<"RelationsChoices", 'Int'>
    readonly createdAt: FieldRef<"RelationsChoices", 'DateTime'>
    readonly updatedAt: FieldRef<"RelationsChoices", 'DateTime'>
    readonly deletedAt: FieldRef<"RelationsChoices", 'DateTime'>
    readonly relationsId: FieldRef<"RelationsChoices", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * RelationsChoices findUnique
   */
  export type RelationsChoicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsChoices
     */
    select?: RelationsChoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsChoicesInclude<ExtArgs> | null
    /**
     * Filter, which RelationsChoices to fetch.
     */
    where: RelationsChoicesWhereUniqueInput
  }

  /**
   * RelationsChoices findUniqueOrThrow
   */
  export type RelationsChoicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsChoices
     */
    select?: RelationsChoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsChoicesInclude<ExtArgs> | null
    /**
     * Filter, which RelationsChoices to fetch.
     */
    where: RelationsChoicesWhereUniqueInput
  }

  /**
   * RelationsChoices findFirst
   */
  export type RelationsChoicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsChoices
     */
    select?: RelationsChoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsChoicesInclude<ExtArgs> | null
    /**
     * Filter, which RelationsChoices to fetch.
     */
    where?: RelationsChoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelationsChoices to fetch.
     */
    orderBy?: RelationsChoicesOrderByWithRelationInput | RelationsChoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelationsChoices.
     */
    cursor?: RelationsChoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelationsChoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelationsChoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelationsChoices.
     */
    distinct?: RelationsChoicesScalarFieldEnum | RelationsChoicesScalarFieldEnum[]
  }

  /**
   * RelationsChoices findFirstOrThrow
   */
  export type RelationsChoicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsChoices
     */
    select?: RelationsChoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsChoicesInclude<ExtArgs> | null
    /**
     * Filter, which RelationsChoices to fetch.
     */
    where?: RelationsChoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelationsChoices to fetch.
     */
    orderBy?: RelationsChoicesOrderByWithRelationInput | RelationsChoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelationsChoices.
     */
    cursor?: RelationsChoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelationsChoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelationsChoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelationsChoices.
     */
    distinct?: RelationsChoicesScalarFieldEnum | RelationsChoicesScalarFieldEnum[]
  }

  /**
   * RelationsChoices findMany
   */
  export type RelationsChoicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsChoices
     */
    select?: RelationsChoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsChoicesInclude<ExtArgs> | null
    /**
     * Filter, which RelationsChoices to fetch.
     */
    where?: RelationsChoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelationsChoices to fetch.
     */
    orderBy?: RelationsChoicesOrderByWithRelationInput | RelationsChoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RelationsChoices.
     */
    cursor?: RelationsChoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelationsChoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelationsChoices.
     */
    skip?: number
    distinct?: RelationsChoicesScalarFieldEnum | RelationsChoicesScalarFieldEnum[]
  }

  /**
   * RelationsChoices create
   */
  export type RelationsChoicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsChoices
     */
    select?: RelationsChoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsChoicesInclude<ExtArgs> | null
    /**
     * The data needed to create a RelationsChoices.
     */
    data: XOR<RelationsChoicesCreateInput, RelationsChoicesUncheckedCreateInput>
  }

  /**
   * RelationsChoices createMany
   */
  export type RelationsChoicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RelationsChoices.
     */
    data: RelationsChoicesCreateManyInput | RelationsChoicesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelationsChoices update
   */
  export type RelationsChoicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsChoices
     */
    select?: RelationsChoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsChoicesInclude<ExtArgs> | null
    /**
     * The data needed to update a RelationsChoices.
     */
    data: XOR<RelationsChoicesUpdateInput, RelationsChoicesUncheckedUpdateInput>
    /**
     * Choose, which RelationsChoices to update.
     */
    where: RelationsChoicesWhereUniqueInput
  }

  /**
   * RelationsChoices updateMany
   */
  export type RelationsChoicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RelationsChoices.
     */
    data: XOR<RelationsChoicesUpdateManyMutationInput, RelationsChoicesUncheckedUpdateManyInput>
    /**
     * Filter which RelationsChoices to update
     */
    where?: RelationsChoicesWhereInput
  }

  /**
   * RelationsChoices upsert
   */
  export type RelationsChoicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsChoices
     */
    select?: RelationsChoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsChoicesInclude<ExtArgs> | null
    /**
     * The filter to search for the RelationsChoices to update in case it exists.
     */
    where: RelationsChoicesWhereUniqueInput
    /**
     * In case the RelationsChoices found by the `where` argument doesn't exist, create a new RelationsChoices with this data.
     */
    create: XOR<RelationsChoicesCreateInput, RelationsChoicesUncheckedCreateInput>
    /**
     * In case the RelationsChoices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelationsChoicesUpdateInput, RelationsChoicesUncheckedUpdateInput>
  }

  /**
   * RelationsChoices delete
   */
  export type RelationsChoicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsChoices
     */
    select?: RelationsChoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsChoicesInclude<ExtArgs> | null
    /**
     * Filter which RelationsChoices to delete.
     */
    where: RelationsChoicesWhereUniqueInput
  }

  /**
   * RelationsChoices deleteMany
   */
  export type RelationsChoicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelationsChoices to delete
     */
    where?: RelationsChoicesWhereInput
  }

  /**
   * RelationsChoices.Media
   */
  export type RelationsChoices$MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * RelationsChoices.Relations
   */
  export type RelationsChoices$RelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relations
     */
    select?: RelationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsInclude<ExtArgs> | null
    where?: RelationsWhereInput
  }

  /**
   * RelationsChoices.UsersRelationsDetails
   */
  export type RelationsChoices$UsersRelationsDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersRelationsDetails
     */
    select?: UsersRelationsDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersRelationsDetailsInclude<ExtArgs> | null
    where?: UsersRelationsDetailsWhereInput
    orderBy?: UsersRelationsDetailsOrderByWithRelationInput | UsersRelationsDetailsOrderByWithRelationInput[]
    cursor?: UsersRelationsDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersRelationsDetailsScalarFieldEnum | UsersRelationsDetailsScalarFieldEnum[]
  }

  /**
   * RelationsChoices without action
   */
  export type RelationsChoicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsChoices
     */
    select?: RelationsChoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsChoicesInclude<ExtArgs> | null
  }


  /**
   * Model RelationsQuestions
   */

  export type AggregateRelationsQuestions = {
    _count: RelationsQuestionsCountAggregateOutputType | null
    _avg: RelationsQuestionsAvgAggregateOutputType | null
    _sum: RelationsQuestionsSumAggregateOutputType | null
    _min: RelationsQuestionsMinAggregateOutputType | null
    _max: RelationsQuestionsMaxAggregateOutputType | null
  }

  export type RelationsQuestionsAvgAggregateOutputType = {
    id: number | null
    reId: number | null
    qsId: number | null
    mdId: number | null
    ordering: number | null
  }

  export type RelationsQuestionsSumAggregateOutputType = {
    id: bigint | null
    reId: bigint | null
    qsId: bigint | null
    mdId: bigint | null
    ordering: number | null
  }

  export type RelationsQuestionsMinAggregateOutputType = {
    id: bigint | null
    reId: bigint | null
    qsId: bigint | null
    mdId: bigint | null
    ordering: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type RelationsQuestionsMaxAggregateOutputType = {
    id: bigint | null
    reId: bigint | null
    qsId: bigint | null
    mdId: bigint | null
    ordering: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type RelationsQuestionsCountAggregateOutputType = {
    id: number
    reId: number
    qsId: number
    mdId: number
    ordering: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type RelationsQuestionsAvgAggregateInputType = {
    id?: true
    reId?: true
    qsId?: true
    mdId?: true
    ordering?: true
  }

  export type RelationsQuestionsSumAggregateInputType = {
    id?: true
    reId?: true
    qsId?: true
    mdId?: true
    ordering?: true
  }

  export type RelationsQuestionsMinAggregateInputType = {
    id?: true
    reId?: true
    qsId?: true
    mdId?: true
    ordering?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type RelationsQuestionsMaxAggregateInputType = {
    id?: true
    reId?: true
    qsId?: true
    mdId?: true
    ordering?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type RelationsQuestionsCountAggregateInputType = {
    id?: true
    reId?: true
    qsId?: true
    mdId?: true
    ordering?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type RelationsQuestionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelationsQuestions to aggregate.
     */
    where?: RelationsQuestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelationsQuestions to fetch.
     */
    orderBy?: RelationsQuestionsOrderByWithRelationInput | RelationsQuestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelationsQuestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelationsQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelationsQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RelationsQuestions
    **/
    _count?: true | RelationsQuestionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RelationsQuestionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RelationsQuestionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelationsQuestionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelationsQuestionsMaxAggregateInputType
  }

  export type GetRelationsQuestionsAggregateType<T extends RelationsQuestionsAggregateArgs> = {
        [P in keyof T & keyof AggregateRelationsQuestions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelationsQuestions[P]>
      : GetScalarType<T[P], AggregateRelationsQuestions[P]>
  }




  export type RelationsQuestionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelationsQuestionsWhereInput
    orderBy?: RelationsQuestionsOrderByWithAggregationInput | RelationsQuestionsOrderByWithAggregationInput[]
    by: RelationsQuestionsScalarFieldEnum[] | RelationsQuestionsScalarFieldEnum
    having?: RelationsQuestionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelationsQuestionsCountAggregateInputType | true
    _avg?: RelationsQuestionsAvgAggregateInputType
    _sum?: RelationsQuestionsSumAggregateInputType
    _min?: RelationsQuestionsMinAggregateInputType
    _max?: RelationsQuestionsMaxAggregateInputType
  }

  export type RelationsQuestionsGroupByOutputType = {
    id: bigint
    reId: bigint
    qsId: bigint
    mdId: bigint | null
    ordering: number
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: RelationsQuestionsCountAggregateOutputType | null
    _avg: RelationsQuestionsAvgAggregateOutputType | null
    _sum: RelationsQuestionsSumAggregateOutputType | null
    _min: RelationsQuestionsMinAggregateOutputType | null
    _max: RelationsQuestionsMaxAggregateOutputType | null
  }

  type GetRelationsQuestionsGroupByPayload<T extends RelationsQuestionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelationsQuestionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelationsQuestionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelationsQuestionsGroupByOutputType[P]>
            : GetScalarType<T[P], RelationsQuestionsGroupByOutputType[P]>
        }
      >
    >


  export type RelationsQuestionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reId?: boolean
    qsId?: boolean
    mdId?: boolean
    ordering?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    Questions?: boolean | QuestionsDefaultArgs<ExtArgs>
    Media?: boolean | RelationsQuestions$MediaArgs<ExtArgs>
    Relations?: boolean | RelationsDefaultArgs<ExtArgs>
    RelationsChoices?: boolean | RelationsQuestions$RelationsChoicesArgs<ExtArgs>
    UsersRelationsDetails?: boolean | RelationsQuestions$UsersRelationsDetailsArgs<ExtArgs>
    _count?: boolean | RelationsQuestionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["relationsQuestions"]>


  export type RelationsQuestionsSelectScalar = {
    id?: boolean
    reId?: boolean
    qsId?: boolean
    mdId?: boolean
    ordering?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type RelationsQuestionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Questions?: boolean | QuestionsDefaultArgs<ExtArgs>
    Media?: boolean | RelationsQuestions$MediaArgs<ExtArgs>
    Relations?: boolean | RelationsDefaultArgs<ExtArgs>
    RelationsChoices?: boolean | RelationsQuestions$RelationsChoicesArgs<ExtArgs>
    UsersRelationsDetails?: boolean | RelationsQuestions$UsersRelationsDetailsArgs<ExtArgs>
    _count?: boolean | RelationsQuestionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RelationsQuestionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RelationsQuestions"
    objects: {
      Questions: Prisma.$QuestionsPayload<ExtArgs>
      Media: Prisma.$MediaPayload<ExtArgs> | null
      Relations: Prisma.$RelationsPayload<ExtArgs>
      RelationsChoices: Prisma.$RelationsChoicesPayload<ExtArgs>[]
      UsersRelationsDetails: Prisma.$UsersRelationsDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      reId: bigint
      qsId: bigint
      mdId: bigint | null
      ordering: number
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["relationsQuestions"]>
    composites: {}
  }

  type RelationsQuestionsGetPayload<S extends boolean | null | undefined | RelationsQuestionsDefaultArgs> = $Result.GetResult<Prisma.$RelationsQuestionsPayload, S>

  type RelationsQuestionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RelationsQuestionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RelationsQuestionsCountAggregateInputType | true
    }

  export interface RelationsQuestionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RelationsQuestions'], meta: { name: 'RelationsQuestions' } }
    /**
     * Find zero or one RelationsQuestions that matches the filter.
     * @param {RelationsQuestionsFindUniqueArgs} args - Arguments to find a RelationsQuestions
     * @example
     * // Get one RelationsQuestions
     * const relationsQuestions = await prisma.relationsQuestions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RelationsQuestionsFindUniqueArgs>(args: SelectSubset<T, RelationsQuestionsFindUniqueArgs<ExtArgs>>): Prisma__RelationsQuestionsClient<$Result.GetResult<Prisma.$RelationsQuestionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RelationsQuestions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RelationsQuestionsFindUniqueOrThrowArgs} args - Arguments to find a RelationsQuestions
     * @example
     * // Get one RelationsQuestions
     * const relationsQuestions = await prisma.relationsQuestions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RelationsQuestionsFindUniqueOrThrowArgs>(args: SelectSubset<T, RelationsQuestionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RelationsQuestionsClient<$Result.GetResult<Prisma.$RelationsQuestionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RelationsQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationsQuestionsFindFirstArgs} args - Arguments to find a RelationsQuestions
     * @example
     * // Get one RelationsQuestions
     * const relationsQuestions = await prisma.relationsQuestions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RelationsQuestionsFindFirstArgs>(args?: SelectSubset<T, RelationsQuestionsFindFirstArgs<ExtArgs>>): Prisma__RelationsQuestionsClient<$Result.GetResult<Prisma.$RelationsQuestionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RelationsQuestions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationsQuestionsFindFirstOrThrowArgs} args - Arguments to find a RelationsQuestions
     * @example
     * // Get one RelationsQuestions
     * const relationsQuestions = await prisma.relationsQuestions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RelationsQuestionsFindFirstOrThrowArgs>(args?: SelectSubset<T, RelationsQuestionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__RelationsQuestionsClient<$Result.GetResult<Prisma.$RelationsQuestionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RelationsQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationsQuestionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RelationsQuestions
     * const relationsQuestions = await prisma.relationsQuestions.findMany()
     * 
     * // Get first 10 RelationsQuestions
     * const relationsQuestions = await prisma.relationsQuestions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relationsQuestionsWithIdOnly = await prisma.relationsQuestions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RelationsQuestionsFindManyArgs>(args?: SelectSubset<T, RelationsQuestionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationsQuestionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RelationsQuestions.
     * @param {RelationsQuestionsCreateArgs} args - Arguments to create a RelationsQuestions.
     * @example
     * // Create one RelationsQuestions
     * const RelationsQuestions = await prisma.relationsQuestions.create({
     *   data: {
     *     // ... data to create a RelationsQuestions
     *   }
     * })
     * 
     */
    create<T extends RelationsQuestionsCreateArgs>(args: SelectSubset<T, RelationsQuestionsCreateArgs<ExtArgs>>): Prisma__RelationsQuestionsClient<$Result.GetResult<Prisma.$RelationsQuestionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RelationsQuestions.
     * @param {RelationsQuestionsCreateManyArgs} args - Arguments to create many RelationsQuestions.
     * @example
     * // Create many RelationsQuestions
     * const relationsQuestions = await prisma.relationsQuestions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RelationsQuestionsCreateManyArgs>(args?: SelectSubset<T, RelationsQuestionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RelationsQuestions.
     * @param {RelationsQuestionsDeleteArgs} args - Arguments to delete one RelationsQuestions.
     * @example
     * // Delete one RelationsQuestions
     * const RelationsQuestions = await prisma.relationsQuestions.delete({
     *   where: {
     *     // ... filter to delete one RelationsQuestions
     *   }
     * })
     * 
     */
    delete<T extends RelationsQuestionsDeleteArgs>(args: SelectSubset<T, RelationsQuestionsDeleteArgs<ExtArgs>>): Prisma__RelationsQuestionsClient<$Result.GetResult<Prisma.$RelationsQuestionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RelationsQuestions.
     * @param {RelationsQuestionsUpdateArgs} args - Arguments to update one RelationsQuestions.
     * @example
     * // Update one RelationsQuestions
     * const relationsQuestions = await prisma.relationsQuestions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RelationsQuestionsUpdateArgs>(args: SelectSubset<T, RelationsQuestionsUpdateArgs<ExtArgs>>): Prisma__RelationsQuestionsClient<$Result.GetResult<Prisma.$RelationsQuestionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RelationsQuestions.
     * @param {RelationsQuestionsDeleteManyArgs} args - Arguments to filter RelationsQuestions to delete.
     * @example
     * // Delete a few RelationsQuestions
     * const { count } = await prisma.relationsQuestions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RelationsQuestionsDeleteManyArgs>(args?: SelectSubset<T, RelationsQuestionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RelationsQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationsQuestionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RelationsQuestions
     * const relationsQuestions = await prisma.relationsQuestions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RelationsQuestionsUpdateManyArgs>(args: SelectSubset<T, RelationsQuestionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RelationsQuestions.
     * @param {RelationsQuestionsUpsertArgs} args - Arguments to update or create a RelationsQuestions.
     * @example
     * // Update or create a RelationsQuestions
     * const relationsQuestions = await prisma.relationsQuestions.upsert({
     *   create: {
     *     // ... data to create a RelationsQuestions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RelationsQuestions we want to update
     *   }
     * })
     */
    upsert<T extends RelationsQuestionsUpsertArgs>(args: SelectSubset<T, RelationsQuestionsUpsertArgs<ExtArgs>>): Prisma__RelationsQuestionsClient<$Result.GetResult<Prisma.$RelationsQuestionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RelationsQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationsQuestionsCountArgs} args - Arguments to filter RelationsQuestions to count.
     * @example
     * // Count the number of RelationsQuestions
     * const count = await prisma.relationsQuestions.count({
     *   where: {
     *     // ... the filter for the RelationsQuestions we want to count
     *   }
     * })
    **/
    count<T extends RelationsQuestionsCountArgs>(
      args?: Subset<T, RelationsQuestionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelationsQuestionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RelationsQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationsQuestionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelationsQuestionsAggregateArgs>(args: Subset<T, RelationsQuestionsAggregateArgs>): Prisma.PrismaPromise<GetRelationsQuestionsAggregateType<T>>

    /**
     * Group by RelationsQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelationsQuestionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelationsQuestionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelationsQuestionsGroupByArgs['orderBy'] }
        : { orderBy?: RelationsQuestionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelationsQuestionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelationsQuestionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RelationsQuestions model
   */
  readonly fields: RelationsQuestionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RelationsQuestions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelationsQuestionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Questions<T extends QuestionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionsDefaultArgs<ExtArgs>>): Prisma__QuestionsClient<$Result.GetResult<Prisma.$QuestionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Media<T extends RelationsQuestions$MediaArgs<ExtArgs> = {}>(args?: Subset<T, RelationsQuestions$MediaArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Relations<T extends RelationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RelationsDefaultArgs<ExtArgs>>): Prisma__RelationsClient<$Result.GetResult<Prisma.$RelationsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    RelationsChoices<T extends RelationsQuestions$RelationsChoicesArgs<ExtArgs> = {}>(args?: Subset<T, RelationsQuestions$RelationsChoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelationsChoicesPayload<ExtArgs>, T, "findMany"> | Null>
    UsersRelationsDetails<T extends RelationsQuestions$UsersRelationsDetailsArgs<ExtArgs> = {}>(args?: Subset<T, RelationsQuestions$UsersRelationsDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersRelationsDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RelationsQuestions model
   */ 
  interface RelationsQuestionsFieldRefs {
    readonly id: FieldRef<"RelationsQuestions", 'BigInt'>
    readonly reId: FieldRef<"RelationsQuestions", 'BigInt'>
    readonly qsId: FieldRef<"RelationsQuestions", 'BigInt'>
    readonly mdId: FieldRef<"RelationsQuestions", 'BigInt'>
    readonly ordering: FieldRef<"RelationsQuestions", 'Int'>
    readonly createdAt: FieldRef<"RelationsQuestions", 'DateTime'>
    readonly updatedAt: FieldRef<"RelationsQuestions", 'DateTime'>
    readonly deletedAt: FieldRef<"RelationsQuestions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RelationsQuestions findUnique
   */
  export type RelationsQuestionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsQuestions
     */
    select?: RelationsQuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsQuestionsInclude<ExtArgs> | null
    /**
     * Filter, which RelationsQuestions to fetch.
     */
    where: RelationsQuestionsWhereUniqueInput
  }

  /**
   * RelationsQuestions findUniqueOrThrow
   */
  export type RelationsQuestionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsQuestions
     */
    select?: RelationsQuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsQuestionsInclude<ExtArgs> | null
    /**
     * Filter, which RelationsQuestions to fetch.
     */
    where: RelationsQuestionsWhereUniqueInput
  }

  /**
   * RelationsQuestions findFirst
   */
  export type RelationsQuestionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsQuestions
     */
    select?: RelationsQuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsQuestionsInclude<ExtArgs> | null
    /**
     * Filter, which RelationsQuestions to fetch.
     */
    where?: RelationsQuestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelationsQuestions to fetch.
     */
    orderBy?: RelationsQuestionsOrderByWithRelationInput | RelationsQuestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelationsQuestions.
     */
    cursor?: RelationsQuestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelationsQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelationsQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelationsQuestions.
     */
    distinct?: RelationsQuestionsScalarFieldEnum | RelationsQuestionsScalarFieldEnum[]
  }

  /**
   * RelationsQuestions findFirstOrThrow
   */
  export type RelationsQuestionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsQuestions
     */
    select?: RelationsQuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsQuestionsInclude<ExtArgs> | null
    /**
     * Filter, which RelationsQuestions to fetch.
     */
    where?: RelationsQuestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelationsQuestions to fetch.
     */
    orderBy?: RelationsQuestionsOrderByWithRelationInput | RelationsQuestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RelationsQuestions.
     */
    cursor?: RelationsQuestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelationsQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelationsQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RelationsQuestions.
     */
    distinct?: RelationsQuestionsScalarFieldEnum | RelationsQuestionsScalarFieldEnum[]
  }

  /**
   * RelationsQuestions findMany
   */
  export type RelationsQuestionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsQuestions
     */
    select?: RelationsQuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsQuestionsInclude<ExtArgs> | null
    /**
     * Filter, which RelationsQuestions to fetch.
     */
    where?: RelationsQuestionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RelationsQuestions to fetch.
     */
    orderBy?: RelationsQuestionsOrderByWithRelationInput | RelationsQuestionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RelationsQuestions.
     */
    cursor?: RelationsQuestionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RelationsQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RelationsQuestions.
     */
    skip?: number
    distinct?: RelationsQuestionsScalarFieldEnum | RelationsQuestionsScalarFieldEnum[]
  }

  /**
   * RelationsQuestions create
   */
  export type RelationsQuestionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsQuestions
     */
    select?: RelationsQuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsQuestionsInclude<ExtArgs> | null
    /**
     * The data needed to create a RelationsQuestions.
     */
    data: XOR<RelationsQuestionsCreateInput, RelationsQuestionsUncheckedCreateInput>
  }

  /**
   * RelationsQuestions createMany
   */
  export type RelationsQuestionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RelationsQuestions.
     */
    data: RelationsQuestionsCreateManyInput | RelationsQuestionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RelationsQuestions update
   */
  export type RelationsQuestionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsQuestions
     */
    select?: RelationsQuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsQuestionsInclude<ExtArgs> | null
    /**
     * The data needed to update a RelationsQuestions.
     */
    data: XOR<RelationsQuestionsUpdateInput, RelationsQuestionsUncheckedUpdateInput>
    /**
     * Choose, which RelationsQuestions to update.
     */
    where: RelationsQuestionsWhereUniqueInput
  }

  /**
   * RelationsQuestions updateMany
   */
  export type RelationsQuestionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RelationsQuestions.
     */
    data: XOR<RelationsQuestionsUpdateManyMutationInput, RelationsQuestionsUncheckedUpdateManyInput>
    /**
     * Filter which RelationsQuestions to update
     */
    where?: RelationsQuestionsWhereInput
  }

  /**
   * RelationsQuestions upsert
   */
  export type RelationsQuestionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsQuestions
     */
    select?: RelationsQuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsQuestionsInclude<ExtArgs> | null
    /**
     * The filter to search for the RelationsQuestions to update in case it exists.
     */
    where: RelationsQuestionsWhereUniqueInput
    /**
     * In case the RelationsQuestions found by the `where` argument doesn't exist, create a new RelationsQuestions with this data.
     */
    create: XOR<RelationsQuestionsCreateInput, RelationsQuestionsUncheckedCreateInput>
    /**
     * In case the RelationsQuestions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelationsQuestionsUpdateInput, RelationsQuestionsUncheckedUpdateInput>
  }

  /**
   * RelationsQuestions delete
   */
  export type RelationsQuestionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsQuestions
     */
    select?: RelationsQuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsQuestionsInclude<ExtArgs> | null
    /**
     * Filter which RelationsQuestions to delete.
     */
    where: RelationsQuestionsWhereUniqueInput
  }

  /**
   * RelationsQuestions deleteMany
   */
  export type RelationsQuestionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RelationsQuestions to delete
     */
    where?: RelationsQuestionsWhereInput
  }

  /**
   * RelationsQuestions.Media
   */
  export type RelationsQuestions$MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
  }

  /**
   * RelationsQuestions.RelationsChoices
   */
  export type RelationsQuestions$RelationsChoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsChoices
     */
    select?: RelationsChoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsChoicesInclude<ExtArgs> | null
    where?: RelationsChoicesWhereInput
    orderBy?: RelationsChoicesOrderByWithRelationInput | RelationsChoicesOrderByWithRelationInput[]
    cursor?: RelationsChoicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelationsChoicesScalarFieldEnum | RelationsChoicesScalarFieldEnum[]
  }

  /**
   * RelationsQuestions.UsersRelationsDetails
   */
  export type RelationsQuestions$UsersRelationsDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersRelationsDetails
     */
    select?: UsersRelationsDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersRelationsDetailsInclude<ExtArgs> | null
    where?: UsersRelationsDetailsWhereInput
    orderBy?: UsersRelationsDetailsOrderByWithRelationInput | UsersRelationsDetailsOrderByWithRelationInput[]
    cursor?: UsersRelationsDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersRelationsDetailsScalarFieldEnum | UsersRelationsDetailsScalarFieldEnum[]
  }

  /**
   * RelationsQuestions without action
   */
  export type RelationsQuestionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RelationsQuestions
     */
    select?: RelationsQuestionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelationsQuestionsInclude<ExtArgs> | null
  }


  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
    location: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: bigint | null
    location: bigint | null
  }

  export type UsersMinAggregateOutputType = {
    id: bigint | null
    personalNumber: string | null
    name: string | null
    email: string | null
    phone: string | null
    location: bigint | null
    admin: boolean | null
    enabled: boolean | null
    activationDate: Date | null
    rememberToken: string | null
    emailVerifiedAt: Date | null
    password: string | null
    twoFactorSecret: string | null
    twoFactorRecoveryCodes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: bigint | null
    personalNumber: string | null
    name: string | null
    email: string | null
    phone: string | null
    location: bigint | null
    admin: boolean | null
    enabled: boolean | null
    activationDate: Date | null
    rememberToken: string | null
    emailVerifiedAt: Date | null
    password: string | null
    twoFactorSecret: string | null
    twoFactorRecoveryCodes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    personalNumber: number
    name: number
    email: number
    phone: number
    location: number
    admin: number
    enabled: number
    activationDate: number
    rememberToken: number
    emailVerifiedAt: number
    password: number
    twoFactorSecret: number
    twoFactorRecoveryCodes: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
    location?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
    location?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    personalNumber?: true
    name?: true
    email?: true
    phone?: true
    location?: true
    admin?: true
    enabled?: true
    activationDate?: true
    rememberToken?: true
    emailVerifiedAt?: true
    password?: true
    twoFactorSecret?: true
    twoFactorRecoveryCodes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    personalNumber?: true
    name?: true
    email?: true
    phone?: true
    location?: true
    admin?: true
    enabled?: true
    activationDate?: true
    rememberToken?: true
    emailVerifiedAt?: true
    password?: true
    twoFactorSecret?: true
    twoFactorRecoveryCodes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    personalNumber?: true
    name?: true
    email?: true
    phone?: true
    location?: true
    admin?: true
    enabled?: true
    activationDate?: true
    rememberToken?: true
    emailVerifiedAt?: true
    password?: true
    twoFactorSecret?: true
    twoFactorRecoveryCodes?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithAggregationInput | UsersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: bigint
    personalNumber: string
    name: string
    email: string
    phone: string | null
    location: bigint
    admin: boolean
    enabled: boolean
    activationDate: Date
    rememberToken: string | null
    emailVerifiedAt: Date | null
    password: string | null
    twoFactorSecret: string | null
    twoFactorRecoveryCodes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personalNumber?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    location?: boolean
    admin?: boolean
    enabled?: boolean
    activationDate?: boolean
    rememberToken?: boolean
    emailVerifiedAt?: boolean
    password?: boolean
    twoFactorSecret?: boolean
    twoFactorRecoveryCodes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    Locations?: boolean | LocationsDefaultArgs<ExtArgs>
    UsersAuth?: boolean | Users$UsersAuthArgs<ExtArgs>
    UsersGroups?: boolean | Users$UsersGroupsArgs<ExtArgs>
    UsersLogin?: boolean | Users$UsersLoginArgs<ExtArgs>
    UsersRelations?: boolean | Users$UsersRelationsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>


  export type UsersSelectScalar = {
    id?: boolean
    personalNumber?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    location?: boolean
    admin?: boolean
    enabled?: boolean
    activationDate?: boolean
    rememberToken?: boolean
    emailVerifiedAt?: boolean
    password?: boolean
    twoFactorSecret?: boolean
    twoFactorRecoveryCodes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Locations?: boolean | LocationsDefaultArgs<ExtArgs>
    UsersAuth?: boolean | Users$UsersAuthArgs<ExtArgs>
    UsersGroups?: boolean | Users$UsersGroupsArgs<ExtArgs>
    UsersLogin?: boolean | Users$UsersLoginArgs<ExtArgs>
    UsersRelations?: boolean | Users$UsersRelationsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users"
    objects: {
      Locations: Prisma.$LocationsPayload<ExtArgs>
      UsersAuth: Prisma.$UsersAuthPayload<ExtArgs>[]
      UsersGroups: Prisma.$UsersGroupsPayload<ExtArgs>[]
      UsersLogin: Prisma.$UsersLoginPayload<ExtArgs>[]
      UsersRelations: Prisma.$UsersRelationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      personalNumber: string
      name: string
      email: string
      phone: string | null
      location: bigint
      admin: boolean
      enabled: boolean
      activationDate: Date
      rememberToken: string | null
      emailVerifiedAt: Date | null
      password: string | null
      twoFactorSecret: string | null
      twoFactorRecoveryCodes: string | null
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type UsersGetPayload<S extends boolean | null | undefined | UsersDefaultArgs> = $Result.GetResult<Prisma.$UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users'], meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersFindUniqueArgs>(args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersFindFirstArgs>(args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsersFindManyArgs>(args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends UsersCreateArgs>(args: SelectSubset<T, UsersCreateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UsersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersCreateManyArgs>(args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends UsersDeleteArgs>(args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersUpdateArgs>(args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersDeleteManyArgs>(args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersUpdateManyArgs>(args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends UsersUpsertArgs>(args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users model
   */
  readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Locations<T extends LocationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationsDefaultArgs<ExtArgs>>): Prisma__LocationsClient<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    UsersAuth<T extends Users$UsersAuthArgs<ExtArgs> = {}>(args?: Subset<T, Users$UsersAuthArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersAuthPayload<ExtArgs>, T, "findMany"> | Null>
    UsersGroups<T extends Users$UsersGroupsArgs<ExtArgs> = {}>(args?: Subset<T, Users$UsersGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersGroupsPayload<ExtArgs>, T, "findMany"> | Null>
    UsersLogin<T extends Users$UsersLoginArgs<ExtArgs> = {}>(args?: Subset<T, Users$UsersLoginArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersLoginPayload<ExtArgs>, T, "findMany"> | Null>
    UsersRelations<T extends Users$UsersRelationsArgs<ExtArgs> = {}>(args?: Subset<T, Users$UsersRelationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersRelationsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users model
   */ 
  interface UsersFieldRefs {
    readonly id: FieldRef<"Users", 'BigInt'>
    readonly personalNumber: FieldRef<"Users", 'String'>
    readonly name: FieldRef<"Users", 'String'>
    readonly email: FieldRef<"Users", 'String'>
    readonly phone: FieldRef<"Users", 'String'>
    readonly location: FieldRef<"Users", 'BigInt'>
    readonly admin: FieldRef<"Users", 'Boolean'>
    readonly enabled: FieldRef<"Users", 'Boolean'>
    readonly activationDate: FieldRef<"Users", 'DateTime'>
    readonly rememberToken: FieldRef<"Users", 'String'>
    readonly emailVerifiedAt: FieldRef<"Users", 'DateTime'>
    readonly password: FieldRef<"Users", 'String'>
    readonly twoFactorSecret: FieldRef<"Users", 'String'>
    readonly twoFactorRecoveryCodes: FieldRef<"Users", 'String'>
    readonly createdAt: FieldRef<"Users", 'DateTime'>
    readonly updatedAt: FieldRef<"Users", 'DateTime'>
    readonly deletedAt: FieldRef<"Users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
  }

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }

  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
  }

  /**
   * Users.UsersAuth
   */
  export type Users$UsersAuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersAuth
     */
    select?: UsersAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersAuthInclude<ExtArgs> | null
    where?: UsersAuthWhereInput
    orderBy?: UsersAuthOrderByWithRelationInput | UsersAuthOrderByWithRelationInput[]
    cursor?: UsersAuthWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersAuthScalarFieldEnum | UsersAuthScalarFieldEnum[]
  }

  /**
   * Users.UsersGroups
   */
  export type Users$UsersGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersGroups
     */
    select?: UsersGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersGroupsInclude<ExtArgs> | null
    where?: UsersGroupsWhereInput
    orderBy?: UsersGroupsOrderByWithRelationInput | UsersGroupsOrderByWithRelationInput[]
    cursor?: UsersGroupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersGroupsScalarFieldEnum | UsersGroupsScalarFieldEnum[]
  }

  /**
   * Users.UsersLogin
   */
  export type Users$UsersLoginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersLogin
     */
    select?: UsersLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersLoginInclude<ExtArgs> | null
    where?: UsersLoginWhereInput
    orderBy?: UsersLoginOrderByWithRelationInput | UsersLoginOrderByWithRelationInput[]
    cursor?: UsersLoginWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersLoginScalarFieldEnum | UsersLoginScalarFieldEnum[]
  }

  /**
   * Users.UsersRelations
   */
  export type Users$UsersRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersRelations
     */
    select?: UsersRelationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersRelationsInclude<ExtArgs> | null
    where?: UsersRelationsWhereInput
    orderBy?: UsersRelationsOrderByWithRelationInput | UsersRelationsOrderByWithRelationInput[]
    cursor?: UsersRelationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersRelationsScalarFieldEnum | UsersRelationsScalarFieldEnum[]
  }

  /**
   * Users without action
   */
  export type UsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
  }


  /**
   * Model UsersAuth
   */

  export type AggregateUsersAuth = {
    _count: UsersAuthCountAggregateOutputType | null
    _avg: UsersAuthAvgAggregateOutputType | null
    _sum: UsersAuthSumAggregateOutputType | null
    _min: UsersAuthMinAggregateOutputType | null
    _max: UsersAuthMaxAggregateOutputType | null
  }

  export type UsersAuthAvgAggregateOutputType = {
    id: number | null
    usId: number | null
    auId: number | null
  }

  export type UsersAuthSumAggregateOutputType = {
    id: bigint | null
    usId: bigint | null
    auId: bigint | null
  }

  export type UsersAuthMinAggregateOutputType = {
    id: bigint | null
    usId: bigint | null
    auId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UsersAuthMaxAggregateOutputType = {
    id: bigint | null
    usId: bigint | null
    auId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UsersAuthCountAggregateOutputType = {
    id: number
    usId: number
    auId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UsersAuthAvgAggregateInputType = {
    id?: true
    usId?: true
    auId?: true
  }

  export type UsersAuthSumAggregateInputType = {
    id?: true
    usId?: true
    auId?: true
  }

  export type UsersAuthMinAggregateInputType = {
    id?: true
    usId?: true
    auId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UsersAuthMaxAggregateInputType = {
    id?: true
    usId?: true
    auId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UsersAuthCountAggregateInputType = {
    id?: true
    usId?: true
    auId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UsersAuthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsersAuth to aggregate.
     */
    where?: UsersAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersAuths to fetch.
     */
    orderBy?: UsersAuthOrderByWithRelationInput | UsersAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsersAuths
    **/
    _count?: true | UsersAuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAuthAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersAuthSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersAuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersAuthMaxAggregateInputType
  }

  export type GetUsersAuthAggregateType<T extends UsersAuthAggregateArgs> = {
        [P in keyof T & keyof AggregateUsersAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsersAuth[P]>
      : GetScalarType<T[P], AggregateUsersAuth[P]>
  }




  export type UsersAuthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersAuthWhereInput
    orderBy?: UsersAuthOrderByWithAggregationInput | UsersAuthOrderByWithAggregationInput[]
    by: UsersAuthScalarFieldEnum[] | UsersAuthScalarFieldEnum
    having?: UsersAuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersAuthCountAggregateInputType | true
    _avg?: UsersAuthAvgAggregateInputType
    _sum?: UsersAuthSumAggregateInputType
    _min?: UsersAuthMinAggregateInputType
    _max?: UsersAuthMaxAggregateInputType
  }

  export type UsersAuthGroupByOutputType = {
    id: bigint
    usId: bigint
    auId: bigint
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: UsersAuthCountAggregateOutputType | null
    _avg: UsersAuthAvgAggregateOutputType | null
    _sum: UsersAuthSumAggregateOutputType | null
    _min: UsersAuthMinAggregateOutputType | null
    _max: UsersAuthMaxAggregateOutputType | null
  }

  type GetUsersAuthGroupByPayload<T extends UsersAuthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersAuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersAuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersAuthGroupByOutputType[P]>
            : GetScalarType<T[P], UsersAuthGroupByOutputType[P]>
        }
      >
    >


  export type UsersAuthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usId?: boolean
    auId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    Authorizations?: boolean | AuthorizationsDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usersAuth"]>


  export type UsersAuthSelectScalar = {
    id?: boolean
    usId?: boolean
    auId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UsersAuthInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Authorizations?: boolean | AuthorizationsDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $UsersAuthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsersAuth"
    objects: {
      Authorizations: Prisma.$AuthorizationsPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      usId: bigint
      auId: bigint
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["usersAuth"]>
    composites: {}
  }

  type UsersAuthGetPayload<S extends boolean | null | undefined | UsersAuthDefaultArgs> = $Result.GetResult<Prisma.$UsersAuthPayload, S>

  type UsersAuthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsersAuthFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersAuthCountAggregateInputType | true
    }

  export interface UsersAuthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsersAuth'], meta: { name: 'UsersAuth' } }
    /**
     * Find zero or one UsersAuth that matches the filter.
     * @param {UsersAuthFindUniqueArgs} args - Arguments to find a UsersAuth
     * @example
     * // Get one UsersAuth
     * const usersAuth = await prisma.usersAuth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersAuthFindUniqueArgs>(args: SelectSubset<T, UsersAuthFindUniqueArgs<ExtArgs>>): Prisma__UsersAuthClient<$Result.GetResult<Prisma.$UsersAuthPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UsersAuth that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsersAuthFindUniqueOrThrowArgs} args - Arguments to find a UsersAuth
     * @example
     * // Get one UsersAuth
     * const usersAuth = await prisma.usersAuth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersAuthFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersAuthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersAuthClient<$Result.GetResult<Prisma.$UsersAuthPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UsersAuth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAuthFindFirstArgs} args - Arguments to find a UsersAuth
     * @example
     * // Get one UsersAuth
     * const usersAuth = await prisma.usersAuth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersAuthFindFirstArgs>(args?: SelectSubset<T, UsersAuthFindFirstArgs<ExtArgs>>): Prisma__UsersAuthClient<$Result.GetResult<Prisma.$UsersAuthPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UsersAuth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAuthFindFirstOrThrowArgs} args - Arguments to find a UsersAuth
     * @example
     * // Get one UsersAuth
     * const usersAuth = await prisma.usersAuth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersAuthFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersAuthFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersAuthClient<$Result.GetResult<Prisma.$UsersAuthPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UsersAuths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAuthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsersAuths
     * const usersAuths = await prisma.usersAuth.findMany()
     * 
     * // Get first 10 UsersAuths
     * const usersAuths = await prisma.usersAuth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersAuthWithIdOnly = await prisma.usersAuth.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsersAuthFindManyArgs>(args?: SelectSubset<T, UsersAuthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersAuthPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UsersAuth.
     * @param {UsersAuthCreateArgs} args - Arguments to create a UsersAuth.
     * @example
     * // Create one UsersAuth
     * const UsersAuth = await prisma.usersAuth.create({
     *   data: {
     *     // ... data to create a UsersAuth
     *   }
     * })
     * 
     */
    create<T extends UsersAuthCreateArgs>(args: SelectSubset<T, UsersAuthCreateArgs<ExtArgs>>): Prisma__UsersAuthClient<$Result.GetResult<Prisma.$UsersAuthPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UsersAuths.
     * @param {UsersAuthCreateManyArgs} args - Arguments to create many UsersAuths.
     * @example
     * // Create many UsersAuths
     * const usersAuth = await prisma.usersAuth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersAuthCreateManyArgs>(args?: SelectSubset<T, UsersAuthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UsersAuth.
     * @param {UsersAuthDeleteArgs} args - Arguments to delete one UsersAuth.
     * @example
     * // Delete one UsersAuth
     * const UsersAuth = await prisma.usersAuth.delete({
     *   where: {
     *     // ... filter to delete one UsersAuth
     *   }
     * })
     * 
     */
    delete<T extends UsersAuthDeleteArgs>(args: SelectSubset<T, UsersAuthDeleteArgs<ExtArgs>>): Prisma__UsersAuthClient<$Result.GetResult<Prisma.$UsersAuthPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UsersAuth.
     * @param {UsersAuthUpdateArgs} args - Arguments to update one UsersAuth.
     * @example
     * // Update one UsersAuth
     * const usersAuth = await prisma.usersAuth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersAuthUpdateArgs>(args: SelectSubset<T, UsersAuthUpdateArgs<ExtArgs>>): Prisma__UsersAuthClient<$Result.GetResult<Prisma.$UsersAuthPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UsersAuths.
     * @param {UsersAuthDeleteManyArgs} args - Arguments to filter UsersAuths to delete.
     * @example
     * // Delete a few UsersAuths
     * const { count } = await prisma.usersAuth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersAuthDeleteManyArgs>(args?: SelectSubset<T, UsersAuthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsersAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsersAuths
     * const usersAuth = await prisma.usersAuth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersAuthUpdateManyArgs>(args: SelectSubset<T, UsersAuthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsersAuth.
     * @param {UsersAuthUpsertArgs} args - Arguments to update or create a UsersAuth.
     * @example
     * // Update or create a UsersAuth
     * const usersAuth = await prisma.usersAuth.upsert({
     *   create: {
     *     // ... data to create a UsersAuth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsersAuth we want to update
     *   }
     * })
     */
    upsert<T extends UsersAuthUpsertArgs>(args: SelectSubset<T, UsersAuthUpsertArgs<ExtArgs>>): Prisma__UsersAuthClient<$Result.GetResult<Prisma.$UsersAuthPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UsersAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAuthCountArgs} args - Arguments to filter UsersAuths to count.
     * @example
     * // Count the number of UsersAuths
     * const count = await prisma.usersAuth.count({
     *   where: {
     *     // ... the filter for the UsersAuths we want to count
     *   }
     * })
    **/
    count<T extends UsersAuthCountArgs>(
      args?: Subset<T, UsersAuthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersAuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsersAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAuthAggregateArgs>(args: Subset<T, UsersAuthAggregateArgs>): Prisma.PrismaPromise<GetUsersAuthAggregateType<T>>

    /**
     * Group by UsersAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersAuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersAuthGroupByArgs['orderBy'] }
        : { orderBy?: UsersAuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersAuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersAuthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsersAuth model
   */
  readonly fields: UsersAuthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsersAuth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersAuthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Authorizations<T extends AuthorizationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AuthorizationsDefaultArgs<ExtArgs>>): Prisma__AuthorizationsClient<$Result.GetResult<Prisma.$AuthorizationsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsersAuth model
   */ 
  interface UsersAuthFieldRefs {
    readonly id: FieldRef<"UsersAuth", 'BigInt'>
    readonly usId: FieldRef<"UsersAuth", 'BigInt'>
    readonly auId: FieldRef<"UsersAuth", 'BigInt'>
    readonly createdAt: FieldRef<"UsersAuth", 'DateTime'>
    readonly updatedAt: FieldRef<"UsersAuth", 'DateTime'>
    readonly deletedAt: FieldRef<"UsersAuth", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsersAuth findUnique
   */
  export type UsersAuthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersAuth
     */
    select?: UsersAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersAuthInclude<ExtArgs> | null
    /**
     * Filter, which UsersAuth to fetch.
     */
    where: UsersAuthWhereUniqueInput
  }

  /**
   * UsersAuth findUniqueOrThrow
   */
  export type UsersAuthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersAuth
     */
    select?: UsersAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersAuthInclude<ExtArgs> | null
    /**
     * Filter, which UsersAuth to fetch.
     */
    where: UsersAuthWhereUniqueInput
  }

  /**
   * UsersAuth findFirst
   */
  export type UsersAuthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersAuth
     */
    select?: UsersAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersAuthInclude<ExtArgs> | null
    /**
     * Filter, which UsersAuth to fetch.
     */
    where?: UsersAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersAuths to fetch.
     */
    orderBy?: UsersAuthOrderByWithRelationInput | UsersAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsersAuths.
     */
    cursor?: UsersAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsersAuths.
     */
    distinct?: UsersAuthScalarFieldEnum | UsersAuthScalarFieldEnum[]
  }

  /**
   * UsersAuth findFirstOrThrow
   */
  export type UsersAuthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersAuth
     */
    select?: UsersAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersAuthInclude<ExtArgs> | null
    /**
     * Filter, which UsersAuth to fetch.
     */
    where?: UsersAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersAuths to fetch.
     */
    orderBy?: UsersAuthOrderByWithRelationInput | UsersAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsersAuths.
     */
    cursor?: UsersAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsersAuths.
     */
    distinct?: UsersAuthScalarFieldEnum | UsersAuthScalarFieldEnum[]
  }

  /**
   * UsersAuth findMany
   */
  export type UsersAuthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersAuth
     */
    select?: UsersAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersAuthInclude<ExtArgs> | null
    /**
     * Filter, which UsersAuths to fetch.
     */
    where?: UsersAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersAuths to fetch.
     */
    orderBy?: UsersAuthOrderByWithRelationInput | UsersAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsersAuths.
     */
    cursor?: UsersAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersAuths.
     */
    skip?: number
    distinct?: UsersAuthScalarFieldEnum | UsersAuthScalarFieldEnum[]
  }

  /**
   * UsersAuth create
   */
  export type UsersAuthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersAuth
     */
    select?: UsersAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersAuthInclude<ExtArgs> | null
    /**
     * The data needed to create a UsersAuth.
     */
    data: XOR<UsersAuthCreateInput, UsersAuthUncheckedCreateInput>
  }

  /**
   * UsersAuth createMany
   */
  export type UsersAuthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsersAuths.
     */
    data: UsersAuthCreateManyInput | UsersAuthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsersAuth update
   */
  export type UsersAuthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersAuth
     */
    select?: UsersAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersAuthInclude<ExtArgs> | null
    /**
     * The data needed to update a UsersAuth.
     */
    data: XOR<UsersAuthUpdateInput, UsersAuthUncheckedUpdateInput>
    /**
     * Choose, which UsersAuth to update.
     */
    where: UsersAuthWhereUniqueInput
  }

  /**
   * UsersAuth updateMany
   */
  export type UsersAuthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsersAuths.
     */
    data: XOR<UsersAuthUpdateManyMutationInput, UsersAuthUncheckedUpdateManyInput>
    /**
     * Filter which UsersAuths to update
     */
    where?: UsersAuthWhereInput
  }

  /**
   * UsersAuth upsert
   */
  export type UsersAuthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersAuth
     */
    select?: UsersAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersAuthInclude<ExtArgs> | null
    /**
     * The filter to search for the UsersAuth to update in case it exists.
     */
    where: UsersAuthWhereUniqueInput
    /**
     * In case the UsersAuth found by the `where` argument doesn't exist, create a new UsersAuth with this data.
     */
    create: XOR<UsersAuthCreateInput, UsersAuthUncheckedCreateInput>
    /**
     * In case the UsersAuth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersAuthUpdateInput, UsersAuthUncheckedUpdateInput>
  }

  /**
   * UsersAuth delete
   */
  export type UsersAuthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersAuth
     */
    select?: UsersAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersAuthInclude<ExtArgs> | null
    /**
     * Filter which UsersAuth to delete.
     */
    where: UsersAuthWhereUniqueInput
  }

  /**
   * UsersAuth deleteMany
   */
  export type UsersAuthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsersAuths to delete
     */
    where?: UsersAuthWhereInput
  }

  /**
   * UsersAuth without action
   */
  export type UsersAuthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersAuth
     */
    select?: UsersAuthSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersAuthInclude<ExtArgs> | null
  }


  /**
   * Model UsersGroups
   */

  export type AggregateUsersGroups = {
    _count: UsersGroupsCountAggregateOutputType | null
    _avg: UsersGroupsAvgAggregateOutputType | null
    _sum: UsersGroupsSumAggregateOutputType | null
    _min: UsersGroupsMinAggregateOutputType | null
    _max: UsersGroupsMaxAggregateOutputType | null
  }

  export type UsersGroupsAvgAggregateOutputType = {
    id: number | null
    usId: number | null
    gpId: number | null
  }

  export type UsersGroupsSumAggregateOutputType = {
    id: bigint | null
    usId: bigint | null
    gpId: bigint | null
  }

  export type UsersGroupsMinAggregateOutputType = {
    id: bigint | null
    usId: bigint | null
    gpId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UsersGroupsMaxAggregateOutputType = {
    id: bigint | null
    usId: bigint | null
    gpId: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UsersGroupsCountAggregateOutputType = {
    id: number
    usId: number
    gpId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UsersGroupsAvgAggregateInputType = {
    id?: true
    usId?: true
    gpId?: true
  }

  export type UsersGroupsSumAggregateInputType = {
    id?: true
    usId?: true
    gpId?: true
  }

  export type UsersGroupsMinAggregateInputType = {
    id?: true
    usId?: true
    gpId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UsersGroupsMaxAggregateInputType = {
    id?: true
    usId?: true
    gpId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UsersGroupsCountAggregateInputType = {
    id?: true
    usId?: true
    gpId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UsersGroupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsersGroups to aggregate.
     */
    where?: UsersGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersGroups to fetch.
     */
    orderBy?: UsersGroupsOrderByWithRelationInput | UsersGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsersGroups
    **/
    _count?: true | UsersGroupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersGroupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersGroupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersGroupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersGroupsMaxAggregateInputType
  }

  export type GetUsersGroupsAggregateType<T extends UsersGroupsAggregateArgs> = {
        [P in keyof T & keyof AggregateUsersGroups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsersGroups[P]>
      : GetScalarType<T[P], AggregateUsersGroups[P]>
  }




  export type UsersGroupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersGroupsWhereInput
    orderBy?: UsersGroupsOrderByWithAggregationInput | UsersGroupsOrderByWithAggregationInput[]
    by: UsersGroupsScalarFieldEnum[] | UsersGroupsScalarFieldEnum
    having?: UsersGroupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersGroupsCountAggregateInputType | true
    _avg?: UsersGroupsAvgAggregateInputType
    _sum?: UsersGroupsSumAggregateInputType
    _min?: UsersGroupsMinAggregateInputType
    _max?: UsersGroupsMaxAggregateInputType
  }

  export type UsersGroupsGroupByOutputType = {
    id: bigint
    usId: bigint
    gpId: bigint
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: UsersGroupsCountAggregateOutputType | null
    _avg: UsersGroupsAvgAggregateOutputType | null
    _sum: UsersGroupsSumAggregateOutputType | null
    _min: UsersGroupsMinAggregateOutputType | null
    _max: UsersGroupsMaxAggregateOutputType | null
  }

  type GetUsersGroupsGroupByPayload<T extends UsersGroupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupsGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupsGroupByOutputType[P]>
        }
      >
    >


  export type UsersGroupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usId?: boolean
    gpId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    Groups?: boolean | GroupsDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usersGroups"]>


  export type UsersGroupsSelectScalar = {
    id?: boolean
    usId?: boolean
    gpId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UsersGroupsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Groups?: boolean | GroupsDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $UsersGroupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsersGroups"
    objects: {
      Groups: Prisma.$GroupsPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      usId: bigint
      gpId: bigint
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["usersGroups"]>
    composites: {}
  }

  type UsersGroupsGetPayload<S extends boolean | null | undefined | UsersGroupsDefaultArgs> = $Result.GetResult<Prisma.$UsersGroupsPayload, S>

  type UsersGroupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsersGroupsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersGroupsCountAggregateInputType | true
    }

  export interface UsersGroupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsersGroups'], meta: { name: 'UsersGroups' } }
    /**
     * Find zero or one UsersGroups that matches the filter.
     * @param {UsersGroupsFindUniqueArgs} args - Arguments to find a UsersGroups
     * @example
     * // Get one UsersGroups
     * const usersGroups = await prisma.usersGroups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersGroupsFindUniqueArgs>(args: SelectSubset<T, UsersGroupsFindUniqueArgs<ExtArgs>>): Prisma__UsersGroupsClient<$Result.GetResult<Prisma.$UsersGroupsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UsersGroups that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsersGroupsFindUniqueOrThrowArgs} args - Arguments to find a UsersGroups
     * @example
     * // Get one UsersGroups
     * const usersGroups = await prisma.usersGroups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersGroupsFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersGroupsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersGroupsClient<$Result.GetResult<Prisma.$UsersGroupsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UsersGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupsFindFirstArgs} args - Arguments to find a UsersGroups
     * @example
     * // Get one UsersGroups
     * const usersGroups = await prisma.usersGroups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersGroupsFindFirstArgs>(args?: SelectSubset<T, UsersGroupsFindFirstArgs<ExtArgs>>): Prisma__UsersGroupsClient<$Result.GetResult<Prisma.$UsersGroupsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UsersGroups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupsFindFirstOrThrowArgs} args - Arguments to find a UsersGroups
     * @example
     * // Get one UsersGroups
     * const usersGroups = await prisma.usersGroups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersGroupsFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersGroupsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersGroupsClient<$Result.GetResult<Prisma.$UsersGroupsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UsersGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsersGroups
     * const usersGroups = await prisma.usersGroups.findMany()
     * 
     * // Get first 10 UsersGroups
     * const usersGroups = await prisma.usersGroups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersGroupsWithIdOnly = await prisma.usersGroups.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsersGroupsFindManyArgs>(args?: SelectSubset<T, UsersGroupsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersGroupsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UsersGroups.
     * @param {UsersGroupsCreateArgs} args - Arguments to create a UsersGroups.
     * @example
     * // Create one UsersGroups
     * const UsersGroups = await prisma.usersGroups.create({
     *   data: {
     *     // ... data to create a UsersGroups
     *   }
     * })
     * 
     */
    create<T extends UsersGroupsCreateArgs>(args: SelectSubset<T, UsersGroupsCreateArgs<ExtArgs>>): Prisma__UsersGroupsClient<$Result.GetResult<Prisma.$UsersGroupsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UsersGroups.
     * @param {UsersGroupsCreateManyArgs} args - Arguments to create many UsersGroups.
     * @example
     * // Create many UsersGroups
     * const usersGroups = await prisma.usersGroups.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersGroupsCreateManyArgs>(args?: SelectSubset<T, UsersGroupsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UsersGroups.
     * @param {UsersGroupsDeleteArgs} args - Arguments to delete one UsersGroups.
     * @example
     * // Delete one UsersGroups
     * const UsersGroups = await prisma.usersGroups.delete({
     *   where: {
     *     // ... filter to delete one UsersGroups
     *   }
     * })
     * 
     */
    delete<T extends UsersGroupsDeleteArgs>(args: SelectSubset<T, UsersGroupsDeleteArgs<ExtArgs>>): Prisma__UsersGroupsClient<$Result.GetResult<Prisma.$UsersGroupsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UsersGroups.
     * @param {UsersGroupsUpdateArgs} args - Arguments to update one UsersGroups.
     * @example
     * // Update one UsersGroups
     * const usersGroups = await prisma.usersGroups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersGroupsUpdateArgs>(args: SelectSubset<T, UsersGroupsUpdateArgs<ExtArgs>>): Prisma__UsersGroupsClient<$Result.GetResult<Prisma.$UsersGroupsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UsersGroups.
     * @param {UsersGroupsDeleteManyArgs} args - Arguments to filter UsersGroups to delete.
     * @example
     * // Delete a few UsersGroups
     * const { count } = await prisma.usersGroups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersGroupsDeleteManyArgs>(args?: SelectSubset<T, UsersGroupsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsersGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsersGroups
     * const usersGroups = await prisma.usersGroups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersGroupsUpdateManyArgs>(args: SelectSubset<T, UsersGroupsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsersGroups.
     * @param {UsersGroupsUpsertArgs} args - Arguments to update or create a UsersGroups.
     * @example
     * // Update or create a UsersGroups
     * const usersGroups = await prisma.usersGroups.upsert({
     *   create: {
     *     // ... data to create a UsersGroups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsersGroups we want to update
     *   }
     * })
     */
    upsert<T extends UsersGroupsUpsertArgs>(args: SelectSubset<T, UsersGroupsUpsertArgs<ExtArgs>>): Prisma__UsersGroupsClient<$Result.GetResult<Prisma.$UsersGroupsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UsersGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupsCountArgs} args - Arguments to filter UsersGroups to count.
     * @example
     * // Count the number of UsersGroups
     * const count = await prisma.usersGroups.count({
     *   where: {
     *     // ... the filter for the UsersGroups we want to count
     *   }
     * })
    **/
    count<T extends UsersGroupsCountArgs>(
      args?: Subset<T, UsersGroupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersGroupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsersGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersGroupsAggregateArgs>(args: Subset<T, UsersGroupsAggregateArgs>): Prisma.PrismaPromise<GetUsersGroupsAggregateType<T>>

    /**
     * Group by UsersGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupsGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsersGroups model
   */
  readonly fields: UsersGroupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsersGroups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersGroupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Groups<T extends GroupsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GroupsDefaultArgs<ExtArgs>>): Prisma__GroupsClient<$Result.GetResult<Prisma.$GroupsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsersGroups model
   */ 
  interface UsersGroupsFieldRefs {
    readonly id: FieldRef<"UsersGroups", 'BigInt'>
    readonly usId: FieldRef<"UsersGroups", 'BigInt'>
    readonly gpId: FieldRef<"UsersGroups", 'BigInt'>
    readonly createdAt: FieldRef<"UsersGroups", 'DateTime'>
    readonly updatedAt: FieldRef<"UsersGroups", 'DateTime'>
    readonly deletedAt: FieldRef<"UsersGroups", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsersGroups findUnique
   */
  export type UsersGroupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersGroups
     */
    select?: UsersGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersGroupsInclude<ExtArgs> | null
    /**
     * Filter, which UsersGroups to fetch.
     */
    where: UsersGroupsWhereUniqueInput
  }

  /**
   * UsersGroups findUniqueOrThrow
   */
  export type UsersGroupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersGroups
     */
    select?: UsersGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersGroupsInclude<ExtArgs> | null
    /**
     * Filter, which UsersGroups to fetch.
     */
    where: UsersGroupsWhereUniqueInput
  }

  /**
   * UsersGroups findFirst
   */
  export type UsersGroupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersGroups
     */
    select?: UsersGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersGroupsInclude<ExtArgs> | null
    /**
     * Filter, which UsersGroups to fetch.
     */
    where?: UsersGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersGroups to fetch.
     */
    orderBy?: UsersGroupsOrderByWithRelationInput | UsersGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsersGroups.
     */
    cursor?: UsersGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsersGroups.
     */
    distinct?: UsersGroupsScalarFieldEnum | UsersGroupsScalarFieldEnum[]
  }

  /**
   * UsersGroups findFirstOrThrow
   */
  export type UsersGroupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersGroups
     */
    select?: UsersGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersGroupsInclude<ExtArgs> | null
    /**
     * Filter, which UsersGroups to fetch.
     */
    where?: UsersGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersGroups to fetch.
     */
    orderBy?: UsersGroupsOrderByWithRelationInput | UsersGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsersGroups.
     */
    cursor?: UsersGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsersGroups.
     */
    distinct?: UsersGroupsScalarFieldEnum | UsersGroupsScalarFieldEnum[]
  }

  /**
   * UsersGroups findMany
   */
  export type UsersGroupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersGroups
     */
    select?: UsersGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersGroupsInclude<ExtArgs> | null
    /**
     * Filter, which UsersGroups to fetch.
     */
    where?: UsersGroupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersGroups to fetch.
     */
    orderBy?: UsersGroupsOrderByWithRelationInput | UsersGroupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsersGroups.
     */
    cursor?: UsersGroupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersGroups.
     */
    skip?: number
    distinct?: UsersGroupsScalarFieldEnum | UsersGroupsScalarFieldEnum[]
  }

  /**
   * UsersGroups create
   */
  export type UsersGroupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersGroups
     */
    select?: UsersGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersGroupsInclude<ExtArgs> | null
    /**
     * The data needed to create a UsersGroups.
     */
    data: XOR<UsersGroupsCreateInput, UsersGroupsUncheckedCreateInput>
  }

  /**
   * UsersGroups createMany
   */
  export type UsersGroupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsersGroups.
     */
    data: UsersGroupsCreateManyInput | UsersGroupsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsersGroups update
   */
  export type UsersGroupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersGroups
     */
    select?: UsersGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersGroupsInclude<ExtArgs> | null
    /**
     * The data needed to update a UsersGroups.
     */
    data: XOR<UsersGroupsUpdateInput, UsersGroupsUncheckedUpdateInput>
    /**
     * Choose, which UsersGroups to update.
     */
    where: UsersGroupsWhereUniqueInput
  }

  /**
   * UsersGroups updateMany
   */
  export type UsersGroupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsersGroups.
     */
    data: XOR<UsersGroupsUpdateManyMutationInput, UsersGroupsUncheckedUpdateManyInput>
    /**
     * Filter which UsersGroups to update
     */
    where?: UsersGroupsWhereInput
  }

  /**
   * UsersGroups upsert
   */
  export type UsersGroupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersGroups
     */
    select?: UsersGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersGroupsInclude<ExtArgs> | null
    /**
     * The filter to search for the UsersGroups to update in case it exists.
     */
    where: UsersGroupsWhereUniqueInput
    /**
     * In case the UsersGroups found by the `where` argument doesn't exist, create a new UsersGroups with this data.
     */
    create: XOR<UsersGroupsCreateInput, UsersGroupsUncheckedCreateInput>
    /**
     * In case the UsersGroups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersGroupsUpdateInput, UsersGroupsUncheckedUpdateInput>
  }

  /**
   * UsersGroups delete
   */
  export type UsersGroupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersGroups
     */
    select?: UsersGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersGroupsInclude<ExtArgs> | null
    /**
     * Filter which UsersGroups to delete.
     */
    where: UsersGroupsWhereUniqueInput
  }

  /**
   * UsersGroups deleteMany
   */
  export type UsersGroupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsersGroups to delete
     */
    where?: UsersGroupsWhereInput
  }

  /**
   * UsersGroups without action
   */
  export type UsersGroupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersGroups
     */
    select?: UsersGroupsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersGroupsInclude<ExtArgs> | null
  }


  /**
   * Model UsersLogin
   */

  export type AggregateUsersLogin = {
    _count: UsersLoginCountAggregateOutputType | null
    _avg: UsersLoginAvgAggregateOutputType | null
    _sum: UsersLoginSumAggregateOutputType | null
    _min: UsersLoginMinAggregateOutputType | null
    _max: UsersLoginMaxAggregateOutputType | null
  }

  export type UsersLoginAvgAggregateOutputType = {
    id: number | null
    usId: number | null
  }

  export type UsersLoginSumAggregateOutputType = {
    id: bigint | null
    usId: bigint | null
  }

  export type UsersLoginMinAggregateOutputType = {
    id: bigint | null
    usId: bigint | null
    action: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersLoginMaxAggregateOutputType = {
    id: bigint | null
    usId: bigint | null
    action: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersLoginCountAggregateOutputType = {
    id: number
    usId: number
    action: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsersLoginAvgAggregateInputType = {
    id?: true
    usId?: true
  }

  export type UsersLoginSumAggregateInputType = {
    id?: true
    usId?: true
  }

  export type UsersLoginMinAggregateInputType = {
    id?: true
    usId?: true
    action?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersLoginMaxAggregateInputType = {
    id?: true
    usId?: true
    action?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersLoginCountAggregateInputType = {
    id?: true
    usId?: true
    action?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsersLoginAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsersLogin to aggregate.
     */
    where?: UsersLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersLogins to fetch.
     */
    orderBy?: UsersLoginOrderByWithRelationInput | UsersLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsersLogins
    **/
    _count?: true | UsersLoginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersLoginAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersLoginSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersLoginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersLoginMaxAggregateInputType
  }

  export type GetUsersLoginAggregateType<T extends UsersLoginAggregateArgs> = {
        [P in keyof T & keyof AggregateUsersLogin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsersLogin[P]>
      : GetScalarType<T[P], AggregateUsersLogin[P]>
  }




  export type UsersLoginGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersLoginWhereInput
    orderBy?: UsersLoginOrderByWithAggregationInput | UsersLoginOrderByWithAggregationInput[]
    by: UsersLoginScalarFieldEnum[] | UsersLoginScalarFieldEnum
    having?: UsersLoginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersLoginCountAggregateInputType | true
    _avg?: UsersLoginAvgAggregateInputType
    _sum?: UsersLoginSumAggregateInputType
    _min?: UsersLoginMinAggregateInputType
    _max?: UsersLoginMaxAggregateInputType
  }

  export type UsersLoginGroupByOutputType = {
    id: bigint
    usId: bigint
    action: boolean
    createdAt: Date | null
    updatedAt: Date | null
    _count: UsersLoginCountAggregateOutputType | null
    _avg: UsersLoginAvgAggregateOutputType | null
    _sum: UsersLoginSumAggregateOutputType | null
    _min: UsersLoginMinAggregateOutputType | null
    _max: UsersLoginMaxAggregateOutputType | null
  }

  type GetUsersLoginGroupByPayload<T extends UsersLoginGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersLoginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersLoginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersLoginGroupByOutputType[P]>
            : GetScalarType<T[P], UsersLoginGroupByOutputType[P]>
        }
      >
    >


  export type UsersLoginSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usId?: boolean
    action?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usersLogin"]>


  export type UsersLoginSelectScalar = {
    id?: boolean
    usId?: boolean
    action?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UsersLoginInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $UsersLoginPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsersLogin"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      usId: bigint
      action: boolean
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["usersLogin"]>
    composites: {}
  }

  type UsersLoginGetPayload<S extends boolean | null | undefined | UsersLoginDefaultArgs> = $Result.GetResult<Prisma.$UsersLoginPayload, S>

  type UsersLoginCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsersLoginFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersLoginCountAggregateInputType | true
    }

  export interface UsersLoginDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsersLogin'], meta: { name: 'UsersLogin' } }
    /**
     * Find zero or one UsersLogin that matches the filter.
     * @param {UsersLoginFindUniqueArgs} args - Arguments to find a UsersLogin
     * @example
     * // Get one UsersLogin
     * const usersLogin = await prisma.usersLogin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersLoginFindUniqueArgs>(args: SelectSubset<T, UsersLoginFindUniqueArgs<ExtArgs>>): Prisma__UsersLoginClient<$Result.GetResult<Prisma.$UsersLoginPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UsersLogin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsersLoginFindUniqueOrThrowArgs} args - Arguments to find a UsersLogin
     * @example
     * // Get one UsersLogin
     * const usersLogin = await prisma.usersLogin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersLoginFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersLoginFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersLoginClient<$Result.GetResult<Prisma.$UsersLoginPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UsersLogin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersLoginFindFirstArgs} args - Arguments to find a UsersLogin
     * @example
     * // Get one UsersLogin
     * const usersLogin = await prisma.usersLogin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersLoginFindFirstArgs>(args?: SelectSubset<T, UsersLoginFindFirstArgs<ExtArgs>>): Prisma__UsersLoginClient<$Result.GetResult<Prisma.$UsersLoginPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UsersLogin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersLoginFindFirstOrThrowArgs} args - Arguments to find a UsersLogin
     * @example
     * // Get one UsersLogin
     * const usersLogin = await prisma.usersLogin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersLoginFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersLoginFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersLoginClient<$Result.GetResult<Prisma.$UsersLoginPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UsersLogins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersLoginFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsersLogins
     * const usersLogins = await prisma.usersLogin.findMany()
     * 
     * // Get first 10 UsersLogins
     * const usersLogins = await prisma.usersLogin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersLoginWithIdOnly = await prisma.usersLogin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsersLoginFindManyArgs>(args?: SelectSubset<T, UsersLoginFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersLoginPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UsersLogin.
     * @param {UsersLoginCreateArgs} args - Arguments to create a UsersLogin.
     * @example
     * // Create one UsersLogin
     * const UsersLogin = await prisma.usersLogin.create({
     *   data: {
     *     // ... data to create a UsersLogin
     *   }
     * })
     * 
     */
    create<T extends UsersLoginCreateArgs>(args: SelectSubset<T, UsersLoginCreateArgs<ExtArgs>>): Prisma__UsersLoginClient<$Result.GetResult<Prisma.$UsersLoginPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UsersLogins.
     * @param {UsersLoginCreateManyArgs} args - Arguments to create many UsersLogins.
     * @example
     * // Create many UsersLogins
     * const usersLogin = await prisma.usersLogin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersLoginCreateManyArgs>(args?: SelectSubset<T, UsersLoginCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UsersLogin.
     * @param {UsersLoginDeleteArgs} args - Arguments to delete one UsersLogin.
     * @example
     * // Delete one UsersLogin
     * const UsersLogin = await prisma.usersLogin.delete({
     *   where: {
     *     // ... filter to delete one UsersLogin
     *   }
     * })
     * 
     */
    delete<T extends UsersLoginDeleteArgs>(args: SelectSubset<T, UsersLoginDeleteArgs<ExtArgs>>): Prisma__UsersLoginClient<$Result.GetResult<Prisma.$UsersLoginPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UsersLogin.
     * @param {UsersLoginUpdateArgs} args - Arguments to update one UsersLogin.
     * @example
     * // Update one UsersLogin
     * const usersLogin = await prisma.usersLogin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersLoginUpdateArgs>(args: SelectSubset<T, UsersLoginUpdateArgs<ExtArgs>>): Prisma__UsersLoginClient<$Result.GetResult<Prisma.$UsersLoginPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UsersLogins.
     * @param {UsersLoginDeleteManyArgs} args - Arguments to filter UsersLogins to delete.
     * @example
     * // Delete a few UsersLogins
     * const { count } = await prisma.usersLogin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersLoginDeleteManyArgs>(args?: SelectSubset<T, UsersLoginDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsersLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersLoginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsersLogins
     * const usersLogin = await prisma.usersLogin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersLoginUpdateManyArgs>(args: SelectSubset<T, UsersLoginUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsersLogin.
     * @param {UsersLoginUpsertArgs} args - Arguments to update or create a UsersLogin.
     * @example
     * // Update or create a UsersLogin
     * const usersLogin = await prisma.usersLogin.upsert({
     *   create: {
     *     // ... data to create a UsersLogin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsersLogin we want to update
     *   }
     * })
     */
    upsert<T extends UsersLoginUpsertArgs>(args: SelectSubset<T, UsersLoginUpsertArgs<ExtArgs>>): Prisma__UsersLoginClient<$Result.GetResult<Prisma.$UsersLoginPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UsersLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersLoginCountArgs} args - Arguments to filter UsersLogins to count.
     * @example
     * // Count the number of UsersLogins
     * const count = await prisma.usersLogin.count({
     *   where: {
     *     // ... the filter for the UsersLogins we want to count
     *   }
     * })
    **/
    count<T extends UsersLoginCountArgs>(
      args?: Subset<T, UsersLoginCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersLoginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsersLogin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersLoginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersLoginAggregateArgs>(args: Subset<T, UsersLoginAggregateArgs>): Prisma.PrismaPromise<GetUsersLoginAggregateType<T>>

    /**
     * Group by UsersLogin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersLoginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersLoginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersLoginGroupByArgs['orderBy'] }
        : { orderBy?: UsersLoginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersLoginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersLoginGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsersLogin model
   */
  readonly fields: UsersLoginFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsersLogin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersLoginClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsersLogin model
   */ 
  interface UsersLoginFieldRefs {
    readonly id: FieldRef<"UsersLogin", 'BigInt'>
    readonly usId: FieldRef<"UsersLogin", 'BigInt'>
    readonly action: FieldRef<"UsersLogin", 'Boolean'>
    readonly createdAt: FieldRef<"UsersLogin", 'DateTime'>
    readonly updatedAt: FieldRef<"UsersLogin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsersLogin findUnique
   */
  export type UsersLoginFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersLogin
     */
    select?: UsersLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersLoginInclude<ExtArgs> | null
    /**
     * Filter, which UsersLogin to fetch.
     */
    where: UsersLoginWhereUniqueInput
  }

  /**
   * UsersLogin findUniqueOrThrow
   */
  export type UsersLoginFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersLogin
     */
    select?: UsersLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersLoginInclude<ExtArgs> | null
    /**
     * Filter, which UsersLogin to fetch.
     */
    where: UsersLoginWhereUniqueInput
  }

  /**
   * UsersLogin findFirst
   */
  export type UsersLoginFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersLogin
     */
    select?: UsersLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersLoginInclude<ExtArgs> | null
    /**
     * Filter, which UsersLogin to fetch.
     */
    where?: UsersLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersLogins to fetch.
     */
    orderBy?: UsersLoginOrderByWithRelationInput | UsersLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsersLogins.
     */
    cursor?: UsersLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsersLogins.
     */
    distinct?: UsersLoginScalarFieldEnum | UsersLoginScalarFieldEnum[]
  }

  /**
   * UsersLogin findFirstOrThrow
   */
  export type UsersLoginFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersLogin
     */
    select?: UsersLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersLoginInclude<ExtArgs> | null
    /**
     * Filter, which UsersLogin to fetch.
     */
    where?: UsersLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersLogins to fetch.
     */
    orderBy?: UsersLoginOrderByWithRelationInput | UsersLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsersLogins.
     */
    cursor?: UsersLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsersLogins.
     */
    distinct?: UsersLoginScalarFieldEnum | UsersLoginScalarFieldEnum[]
  }

  /**
   * UsersLogin findMany
   */
  export type UsersLoginFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersLogin
     */
    select?: UsersLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersLoginInclude<ExtArgs> | null
    /**
     * Filter, which UsersLogins to fetch.
     */
    where?: UsersLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersLogins to fetch.
     */
    orderBy?: UsersLoginOrderByWithRelationInput | UsersLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsersLogins.
     */
    cursor?: UsersLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersLogins.
     */
    skip?: number
    distinct?: UsersLoginScalarFieldEnum | UsersLoginScalarFieldEnum[]
  }

  /**
   * UsersLogin create
   */
  export type UsersLoginCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersLogin
     */
    select?: UsersLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersLoginInclude<ExtArgs> | null
    /**
     * The data needed to create a UsersLogin.
     */
    data: XOR<UsersLoginCreateInput, UsersLoginUncheckedCreateInput>
  }

  /**
   * UsersLogin createMany
   */
  export type UsersLoginCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsersLogins.
     */
    data: UsersLoginCreateManyInput | UsersLoginCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsersLogin update
   */
  export type UsersLoginUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersLogin
     */
    select?: UsersLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersLoginInclude<ExtArgs> | null
    /**
     * The data needed to update a UsersLogin.
     */
    data: XOR<UsersLoginUpdateInput, UsersLoginUncheckedUpdateInput>
    /**
     * Choose, which UsersLogin to update.
     */
    where: UsersLoginWhereUniqueInput
  }

  /**
   * UsersLogin updateMany
   */
  export type UsersLoginUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsersLogins.
     */
    data: XOR<UsersLoginUpdateManyMutationInput, UsersLoginUncheckedUpdateManyInput>
    /**
     * Filter which UsersLogins to update
     */
    where?: UsersLoginWhereInput
  }

  /**
   * UsersLogin upsert
   */
  export type UsersLoginUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersLogin
     */
    select?: UsersLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersLoginInclude<ExtArgs> | null
    /**
     * The filter to search for the UsersLogin to update in case it exists.
     */
    where: UsersLoginWhereUniqueInput
    /**
     * In case the UsersLogin found by the `where` argument doesn't exist, create a new UsersLogin with this data.
     */
    create: XOR<UsersLoginCreateInput, UsersLoginUncheckedCreateInput>
    /**
     * In case the UsersLogin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersLoginUpdateInput, UsersLoginUncheckedUpdateInput>
  }

  /**
   * UsersLogin delete
   */
  export type UsersLoginDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersLogin
     */
    select?: UsersLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersLoginInclude<ExtArgs> | null
    /**
     * Filter which UsersLogin to delete.
     */
    where: UsersLoginWhereUniqueInput
  }

  /**
   * UsersLogin deleteMany
   */
  export type UsersLoginDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsersLogins to delete
     */
    where?: UsersLoginWhereInput
  }

  /**
   * UsersLogin without action
   */
  export type UsersLoginDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersLogin
     */
    select?: UsersLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersLoginInclude<ExtArgs> | null
  }


  /**
   * Model UsersRelations
   */

  export type AggregateUsersRelations = {
    _count: UsersRelationsCountAggregateOutputType | null
    _avg: UsersRelationsAvgAggregateOutputType | null
    _sum: UsersRelationsSumAggregateOutputType | null
    _min: UsersRelationsMinAggregateOutputType | null
    _max: UsersRelationsMaxAggregateOutputType | null
  }

  export type UsersRelationsAvgAggregateOutputType = {
    id: number | null
    usId: number | null
    reId: number | null
    correct: number | null
    wrong: number | null
  }

  export type UsersRelationsSumAggregateOutputType = {
    id: bigint | null
    usId: bigint | null
    reId: bigint | null
    correct: number | null
    wrong: number | null
  }

  export type UsersRelationsMinAggregateOutputType = {
    id: bigint | null
    usId: bigint | null
    reId: bigint | null
    correct: number | null
    wrong: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersRelationsMaxAggregateOutputType = {
    id: bigint | null
    usId: bigint | null
    reId: bigint | null
    correct: number | null
    wrong: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersRelationsCountAggregateOutputType = {
    id: number
    usId: number
    reId: number
    correct: number
    wrong: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsersRelationsAvgAggregateInputType = {
    id?: true
    usId?: true
    reId?: true
    correct?: true
    wrong?: true
  }

  export type UsersRelationsSumAggregateInputType = {
    id?: true
    usId?: true
    reId?: true
    correct?: true
    wrong?: true
  }

  export type UsersRelationsMinAggregateInputType = {
    id?: true
    usId?: true
    reId?: true
    correct?: true
    wrong?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersRelationsMaxAggregateInputType = {
    id?: true
    usId?: true
    reId?: true
    correct?: true
    wrong?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersRelationsCountAggregateInputType = {
    id?: true
    usId?: true
    reId?: true
    correct?: true
    wrong?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsersRelationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsersRelations to aggregate.
     */
    where?: UsersRelationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersRelations to fetch.
     */
    orderBy?: UsersRelationsOrderByWithRelationInput | UsersRelationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersRelationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsersRelations
    **/
    _count?: true | UsersRelationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersRelationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersRelationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersRelationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersRelationsMaxAggregateInputType
  }

  export type GetUsersRelationsAggregateType<T extends UsersRelationsAggregateArgs> = {
        [P in keyof T & keyof AggregateUsersRelations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsersRelations[P]>
      : GetScalarType<T[P], AggregateUsersRelations[P]>
  }




  export type UsersRelationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersRelationsWhereInput
    orderBy?: UsersRelationsOrderByWithAggregationInput | UsersRelationsOrderByWithAggregationInput[]
    by: UsersRelationsScalarFieldEnum[] | UsersRelationsScalarFieldEnum
    having?: UsersRelationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersRelationsCountAggregateInputType | true
    _avg?: UsersRelationsAvgAggregateInputType
    _sum?: UsersRelationsSumAggregateInputType
    _min?: UsersRelationsMinAggregateInputType
    _max?: UsersRelationsMaxAggregateInputType
  }

  export type UsersRelationsGroupByOutputType = {
    id: bigint
    usId: bigint
    reId: bigint
    correct: number
    wrong: number
    createdAt: Date | null
    updatedAt: Date | null
    _count: UsersRelationsCountAggregateOutputType | null
    _avg: UsersRelationsAvgAggregateOutputType | null
    _sum: UsersRelationsSumAggregateOutputType | null
    _min: UsersRelationsMinAggregateOutputType | null
    _max: UsersRelationsMaxAggregateOutputType | null
  }

  type GetUsersRelationsGroupByPayload<T extends UsersRelationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersRelationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersRelationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersRelationsGroupByOutputType[P]>
            : GetScalarType<T[P], UsersRelationsGroupByOutputType[P]>
        }
      >
    >


  export type UsersRelationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usId?: boolean
    reId?: boolean
    correct?: boolean
    wrong?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Relations?: boolean | RelationsDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    UsersRelationsDetails?: boolean | UsersRelations$UsersRelationsDetailsArgs<ExtArgs>
    _count?: boolean | UsersRelationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usersRelations"]>


  export type UsersRelationsSelectScalar = {
    id?: boolean
    usId?: boolean
    reId?: boolean
    correct?: boolean
    wrong?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UsersRelationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Relations?: boolean | RelationsDefaultArgs<ExtArgs>
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    UsersRelationsDetails?: boolean | UsersRelations$UsersRelationsDetailsArgs<ExtArgs>
    _count?: boolean | UsersRelationsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UsersRelationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsersRelations"
    objects: {
      Relations: Prisma.$RelationsPayload<ExtArgs>
      Users: Prisma.$UsersPayload<ExtArgs>
      UsersRelationsDetails: Prisma.$UsersRelationsDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      usId: bigint
      reId: bigint
      correct: number
      wrong: number
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["usersRelations"]>
    composites: {}
  }

  type UsersRelationsGetPayload<S extends boolean | null | undefined | UsersRelationsDefaultArgs> = $Result.GetResult<Prisma.$UsersRelationsPayload, S>

  type UsersRelationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsersRelationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersRelationsCountAggregateInputType | true
    }

  export interface UsersRelationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsersRelations'], meta: { name: 'UsersRelations' } }
    /**
     * Find zero or one UsersRelations that matches the filter.
     * @param {UsersRelationsFindUniqueArgs} args - Arguments to find a UsersRelations
     * @example
     * // Get one UsersRelations
     * const usersRelations = await prisma.usersRelations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersRelationsFindUniqueArgs>(args: SelectSubset<T, UsersRelationsFindUniqueArgs<ExtArgs>>): Prisma__UsersRelationsClient<$Result.GetResult<Prisma.$UsersRelationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UsersRelations that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsersRelationsFindUniqueOrThrowArgs} args - Arguments to find a UsersRelations
     * @example
     * // Get one UsersRelations
     * const usersRelations = await prisma.usersRelations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersRelationsFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersRelationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersRelationsClient<$Result.GetResult<Prisma.$UsersRelationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UsersRelations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersRelationsFindFirstArgs} args - Arguments to find a UsersRelations
     * @example
     * // Get one UsersRelations
     * const usersRelations = await prisma.usersRelations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersRelationsFindFirstArgs>(args?: SelectSubset<T, UsersRelationsFindFirstArgs<ExtArgs>>): Prisma__UsersRelationsClient<$Result.GetResult<Prisma.$UsersRelationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UsersRelations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersRelationsFindFirstOrThrowArgs} args - Arguments to find a UsersRelations
     * @example
     * // Get one UsersRelations
     * const usersRelations = await prisma.usersRelations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersRelationsFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersRelationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersRelationsClient<$Result.GetResult<Prisma.$UsersRelationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UsersRelations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersRelationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsersRelations
     * const usersRelations = await prisma.usersRelations.findMany()
     * 
     * // Get first 10 UsersRelations
     * const usersRelations = await prisma.usersRelations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersRelationsWithIdOnly = await prisma.usersRelations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsersRelationsFindManyArgs>(args?: SelectSubset<T, UsersRelationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersRelationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UsersRelations.
     * @param {UsersRelationsCreateArgs} args - Arguments to create a UsersRelations.
     * @example
     * // Create one UsersRelations
     * const UsersRelations = await prisma.usersRelations.create({
     *   data: {
     *     // ... data to create a UsersRelations
     *   }
     * })
     * 
     */
    create<T extends UsersRelationsCreateArgs>(args: SelectSubset<T, UsersRelationsCreateArgs<ExtArgs>>): Prisma__UsersRelationsClient<$Result.GetResult<Prisma.$UsersRelationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UsersRelations.
     * @param {UsersRelationsCreateManyArgs} args - Arguments to create many UsersRelations.
     * @example
     * // Create many UsersRelations
     * const usersRelations = await prisma.usersRelations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersRelationsCreateManyArgs>(args?: SelectSubset<T, UsersRelationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UsersRelations.
     * @param {UsersRelationsDeleteArgs} args - Arguments to delete one UsersRelations.
     * @example
     * // Delete one UsersRelations
     * const UsersRelations = await prisma.usersRelations.delete({
     *   where: {
     *     // ... filter to delete one UsersRelations
     *   }
     * })
     * 
     */
    delete<T extends UsersRelationsDeleteArgs>(args: SelectSubset<T, UsersRelationsDeleteArgs<ExtArgs>>): Prisma__UsersRelationsClient<$Result.GetResult<Prisma.$UsersRelationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UsersRelations.
     * @param {UsersRelationsUpdateArgs} args - Arguments to update one UsersRelations.
     * @example
     * // Update one UsersRelations
     * const usersRelations = await prisma.usersRelations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersRelationsUpdateArgs>(args: SelectSubset<T, UsersRelationsUpdateArgs<ExtArgs>>): Prisma__UsersRelationsClient<$Result.GetResult<Prisma.$UsersRelationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UsersRelations.
     * @param {UsersRelationsDeleteManyArgs} args - Arguments to filter UsersRelations to delete.
     * @example
     * // Delete a few UsersRelations
     * const { count } = await prisma.usersRelations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersRelationsDeleteManyArgs>(args?: SelectSubset<T, UsersRelationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsersRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersRelationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsersRelations
     * const usersRelations = await prisma.usersRelations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersRelationsUpdateManyArgs>(args: SelectSubset<T, UsersRelationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsersRelations.
     * @param {UsersRelationsUpsertArgs} args - Arguments to update or create a UsersRelations.
     * @example
     * // Update or create a UsersRelations
     * const usersRelations = await prisma.usersRelations.upsert({
     *   create: {
     *     // ... data to create a UsersRelations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsersRelations we want to update
     *   }
     * })
     */
    upsert<T extends UsersRelationsUpsertArgs>(args: SelectSubset<T, UsersRelationsUpsertArgs<ExtArgs>>): Prisma__UsersRelationsClient<$Result.GetResult<Prisma.$UsersRelationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UsersRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersRelationsCountArgs} args - Arguments to filter UsersRelations to count.
     * @example
     * // Count the number of UsersRelations
     * const count = await prisma.usersRelations.count({
     *   where: {
     *     // ... the filter for the UsersRelations we want to count
     *   }
     * })
    **/
    count<T extends UsersRelationsCountArgs>(
      args?: Subset<T, UsersRelationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersRelationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsersRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersRelationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersRelationsAggregateArgs>(args: Subset<T, UsersRelationsAggregateArgs>): Prisma.PrismaPromise<GetUsersRelationsAggregateType<T>>

    /**
     * Group by UsersRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersRelationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersRelationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersRelationsGroupByArgs['orderBy'] }
        : { orderBy?: UsersRelationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersRelationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersRelationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsersRelations model
   */
  readonly fields: UsersRelationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsersRelations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersRelationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Relations<T extends RelationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RelationsDefaultArgs<ExtArgs>>): Prisma__RelationsClient<$Result.GetResult<Prisma.$RelationsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    UsersRelationsDetails<T extends UsersRelations$UsersRelationsDetailsArgs<ExtArgs> = {}>(args?: Subset<T, UsersRelations$UsersRelationsDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersRelationsDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsersRelations model
   */ 
  interface UsersRelationsFieldRefs {
    readonly id: FieldRef<"UsersRelations", 'BigInt'>
    readonly usId: FieldRef<"UsersRelations", 'BigInt'>
    readonly reId: FieldRef<"UsersRelations", 'BigInt'>
    readonly correct: FieldRef<"UsersRelations", 'Int'>
    readonly wrong: FieldRef<"UsersRelations", 'Int'>
    readonly createdAt: FieldRef<"UsersRelations", 'DateTime'>
    readonly updatedAt: FieldRef<"UsersRelations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsersRelations findUnique
   */
  export type UsersRelationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersRelations
     */
    select?: UsersRelationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersRelationsInclude<ExtArgs> | null
    /**
     * Filter, which UsersRelations to fetch.
     */
    where: UsersRelationsWhereUniqueInput
  }

  /**
   * UsersRelations findUniqueOrThrow
   */
  export type UsersRelationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersRelations
     */
    select?: UsersRelationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersRelationsInclude<ExtArgs> | null
    /**
     * Filter, which UsersRelations to fetch.
     */
    where: UsersRelationsWhereUniqueInput
  }

  /**
   * UsersRelations findFirst
   */
  export type UsersRelationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersRelations
     */
    select?: UsersRelationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersRelationsInclude<ExtArgs> | null
    /**
     * Filter, which UsersRelations to fetch.
     */
    where?: UsersRelationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersRelations to fetch.
     */
    orderBy?: UsersRelationsOrderByWithRelationInput | UsersRelationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsersRelations.
     */
    cursor?: UsersRelationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsersRelations.
     */
    distinct?: UsersRelationsScalarFieldEnum | UsersRelationsScalarFieldEnum[]
  }

  /**
   * UsersRelations findFirstOrThrow
   */
  export type UsersRelationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersRelations
     */
    select?: UsersRelationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersRelationsInclude<ExtArgs> | null
    /**
     * Filter, which UsersRelations to fetch.
     */
    where?: UsersRelationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersRelations to fetch.
     */
    orderBy?: UsersRelationsOrderByWithRelationInput | UsersRelationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsersRelations.
     */
    cursor?: UsersRelationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsersRelations.
     */
    distinct?: UsersRelationsScalarFieldEnum | UsersRelationsScalarFieldEnum[]
  }

  /**
   * UsersRelations findMany
   */
  export type UsersRelationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersRelations
     */
    select?: UsersRelationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersRelationsInclude<ExtArgs> | null
    /**
     * Filter, which UsersRelations to fetch.
     */
    where?: UsersRelationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersRelations to fetch.
     */
    orderBy?: UsersRelationsOrderByWithRelationInput | UsersRelationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsersRelations.
     */
    cursor?: UsersRelationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersRelations.
     */
    skip?: number
    distinct?: UsersRelationsScalarFieldEnum | UsersRelationsScalarFieldEnum[]
  }

  /**
   * UsersRelations create
   */
  export type UsersRelationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersRelations
     */
    select?: UsersRelationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersRelationsInclude<ExtArgs> | null
    /**
     * The data needed to create a UsersRelations.
     */
    data: XOR<UsersRelationsCreateInput, UsersRelationsUncheckedCreateInput>
  }

  /**
   * UsersRelations createMany
   */
  export type UsersRelationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsersRelations.
     */
    data: UsersRelationsCreateManyInput | UsersRelationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsersRelations update
   */
  export type UsersRelationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersRelations
     */
    select?: UsersRelationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersRelationsInclude<ExtArgs> | null
    /**
     * The data needed to update a UsersRelations.
     */
    data: XOR<UsersRelationsUpdateInput, UsersRelationsUncheckedUpdateInput>
    /**
     * Choose, which UsersRelations to update.
     */
    where: UsersRelationsWhereUniqueInput
  }

  /**
   * UsersRelations updateMany
   */
  export type UsersRelationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsersRelations.
     */
    data: XOR<UsersRelationsUpdateManyMutationInput, UsersRelationsUncheckedUpdateManyInput>
    /**
     * Filter which UsersRelations to update
     */
    where?: UsersRelationsWhereInput
  }

  /**
   * UsersRelations upsert
   */
  export type UsersRelationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersRelations
     */
    select?: UsersRelationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersRelationsInclude<ExtArgs> | null
    /**
     * The filter to search for the UsersRelations to update in case it exists.
     */
    where: UsersRelationsWhereUniqueInput
    /**
     * In case the UsersRelations found by the `where` argument doesn't exist, create a new UsersRelations with this data.
     */
    create: XOR<UsersRelationsCreateInput, UsersRelationsUncheckedCreateInput>
    /**
     * In case the UsersRelations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersRelationsUpdateInput, UsersRelationsUncheckedUpdateInput>
  }

  /**
   * UsersRelations delete
   */
  export type UsersRelationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersRelations
     */
    select?: UsersRelationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersRelationsInclude<ExtArgs> | null
    /**
     * Filter which UsersRelations to delete.
     */
    where: UsersRelationsWhereUniqueInput
  }

  /**
   * UsersRelations deleteMany
   */
  export type UsersRelationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsersRelations to delete
     */
    where?: UsersRelationsWhereInput
  }

  /**
   * UsersRelations.UsersRelationsDetails
   */
  export type UsersRelations$UsersRelationsDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersRelationsDetails
     */
    select?: UsersRelationsDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersRelationsDetailsInclude<ExtArgs> | null
    where?: UsersRelationsDetailsWhereInput
    orderBy?: UsersRelationsDetailsOrderByWithRelationInput | UsersRelationsDetailsOrderByWithRelationInput[]
    cursor?: UsersRelationsDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersRelationsDetailsScalarFieldEnum | UsersRelationsDetailsScalarFieldEnum[]
  }

  /**
   * UsersRelations without action
   */
  export type UsersRelationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersRelations
     */
    select?: UsersRelationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersRelationsInclude<ExtArgs> | null
  }


  /**
   * Model UsersRelationsDetails
   */

  export type AggregateUsersRelationsDetails = {
    _count: UsersRelationsDetailsCountAggregateOutputType | null
    _avg: UsersRelationsDetailsAvgAggregateOutputType | null
    _sum: UsersRelationsDetailsSumAggregateOutputType | null
    _min: UsersRelationsDetailsMinAggregateOutputType | null
    _max: UsersRelationsDetailsMaxAggregateOutputType | null
  }

  export type UsersRelationsDetailsAvgAggregateOutputType = {
    id: number | null
    urId: number | null
    rqId: number | null
    rcId: number | null
  }

  export type UsersRelationsDetailsSumAggregateOutputType = {
    id: bigint | null
    urId: bigint | null
    rqId: bigint | null
    rcId: bigint | null
  }

  export type UsersRelationsDetailsMinAggregateOutputType = {
    id: bigint | null
    urId: bigint | null
    rqId: bigint | null
    rcId: bigint | null
    observed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersRelationsDetailsMaxAggregateOutputType = {
    id: bigint | null
    urId: bigint | null
    rqId: bigint | null
    rcId: bigint | null
    observed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersRelationsDetailsCountAggregateOutputType = {
    id: number
    urId: number
    rqId: number
    rcId: number
    observed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsersRelationsDetailsAvgAggregateInputType = {
    id?: true
    urId?: true
    rqId?: true
    rcId?: true
  }

  export type UsersRelationsDetailsSumAggregateInputType = {
    id?: true
    urId?: true
    rqId?: true
    rcId?: true
  }

  export type UsersRelationsDetailsMinAggregateInputType = {
    id?: true
    urId?: true
    rqId?: true
    rcId?: true
    observed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersRelationsDetailsMaxAggregateInputType = {
    id?: true
    urId?: true
    rqId?: true
    rcId?: true
    observed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersRelationsDetailsCountAggregateInputType = {
    id?: true
    urId?: true
    rqId?: true
    rcId?: true
    observed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsersRelationsDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsersRelationsDetails to aggregate.
     */
    where?: UsersRelationsDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersRelationsDetails to fetch.
     */
    orderBy?: UsersRelationsDetailsOrderByWithRelationInput | UsersRelationsDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersRelationsDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersRelationsDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersRelationsDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsersRelationsDetails
    **/
    _count?: true | UsersRelationsDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersRelationsDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersRelationsDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersRelationsDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersRelationsDetailsMaxAggregateInputType
  }

  export type GetUsersRelationsDetailsAggregateType<T extends UsersRelationsDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateUsersRelationsDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsersRelationsDetails[P]>
      : GetScalarType<T[P], AggregateUsersRelationsDetails[P]>
  }




  export type UsersRelationsDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersRelationsDetailsWhereInput
    orderBy?: UsersRelationsDetailsOrderByWithAggregationInput | UsersRelationsDetailsOrderByWithAggregationInput[]
    by: UsersRelationsDetailsScalarFieldEnum[] | UsersRelationsDetailsScalarFieldEnum
    having?: UsersRelationsDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersRelationsDetailsCountAggregateInputType | true
    _avg?: UsersRelationsDetailsAvgAggregateInputType
    _sum?: UsersRelationsDetailsSumAggregateInputType
    _min?: UsersRelationsDetailsMinAggregateInputType
    _max?: UsersRelationsDetailsMaxAggregateInputType
  }

  export type UsersRelationsDetailsGroupByOutputType = {
    id: bigint
    urId: bigint
    rqId: bigint
    rcId: bigint
    observed: boolean
    createdAt: Date | null
    updatedAt: Date | null
    _count: UsersRelationsDetailsCountAggregateOutputType | null
    _avg: UsersRelationsDetailsAvgAggregateOutputType | null
    _sum: UsersRelationsDetailsSumAggregateOutputType | null
    _min: UsersRelationsDetailsMinAggregateOutputType | null
    _max: UsersRelationsDetailsMaxAggregateOutputType | null
  }

  type GetUsersRelationsDetailsGroupByPayload<T extends UsersRelationsDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersRelationsDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersRelationsDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersRelationsDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], UsersRelationsDetailsGroupByOutputType[P]>
        }
      >
    >


  export type UsersRelationsDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    urId?: boolean
    rqId?: boolean
    rcId?: boolean
    observed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    UsersRelations?: boolean | UsersRelationsDefaultArgs<ExtArgs>
    RelationsChoices?: boolean | RelationsChoicesDefaultArgs<ExtArgs>
    RelationsQuestions?: boolean | RelationsQuestionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usersRelationsDetails"]>


  export type UsersRelationsDetailsSelectScalar = {
    id?: boolean
    urId?: boolean
    rqId?: boolean
    rcId?: boolean
    observed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UsersRelationsDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UsersRelations?: boolean | UsersRelationsDefaultArgs<ExtArgs>
    RelationsChoices?: boolean | RelationsChoicesDefaultArgs<ExtArgs>
    RelationsQuestions?: boolean | RelationsQuestionsDefaultArgs<ExtArgs>
  }

  export type $UsersRelationsDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsersRelationsDetails"
    objects: {
      UsersRelations: Prisma.$UsersRelationsPayload<ExtArgs>
      RelationsChoices: Prisma.$RelationsChoicesPayload<ExtArgs>
      RelationsQuestions: Prisma.$RelationsQuestionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      urId: bigint
      rqId: bigint
      rcId: bigint
      observed: boolean
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["usersRelationsDetails"]>
    composites: {}
  }

  type UsersRelationsDetailsGetPayload<S extends boolean | null | undefined | UsersRelationsDetailsDefaultArgs> = $Result.GetResult<Prisma.$UsersRelationsDetailsPayload, S>

  type UsersRelationsDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsersRelationsDetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersRelationsDetailsCountAggregateInputType | true
    }

  export interface UsersRelationsDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsersRelationsDetails'], meta: { name: 'UsersRelationsDetails' } }
    /**
     * Find zero or one UsersRelationsDetails that matches the filter.
     * @param {UsersRelationsDetailsFindUniqueArgs} args - Arguments to find a UsersRelationsDetails
     * @example
     * // Get one UsersRelationsDetails
     * const usersRelationsDetails = await prisma.usersRelationsDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersRelationsDetailsFindUniqueArgs>(args: SelectSubset<T, UsersRelationsDetailsFindUniqueArgs<ExtArgs>>): Prisma__UsersRelationsDetailsClient<$Result.GetResult<Prisma.$UsersRelationsDetailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UsersRelationsDetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsersRelationsDetailsFindUniqueOrThrowArgs} args - Arguments to find a UsersRelationsDetails
     * @example
     * // Get one UsersRelationsDetails
     * const usersRelationsDetails = await prisma.usersRelationsDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersRelationsDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersRelationsDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersRelationsDetailsClient<$Result.GetResult<Prisma.$UsersRelationsDetailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UsersRelationsDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersRelationsDetailsFindFirstArgs} args - Arguments to find a UsersRelationsDetails
     * @example
     * // Get one UsersRelationsDetails
     * const usersRelationsDetails = await prisma.usersRelationsDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersRelationsDetailsFindFirstArgs>(args?: SelectSubset<T, UsersRelationsDetailsFindFirstArgs<ExtArgs>>): Prisma__UsersRelationsDetailsClient<$Result.GetResult<Prisma.$UsersRelationsDetailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UsersRelationsDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersRelationsDetailsFindFirstOrThrowArgs} args - Arguments to find a UsersRelationsDetails
     * @example
     * // Get one UsersRelationsDetails
     * const usersRelationsDetails = await prisma.usersRelationsDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersRelationsDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersRelationsDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersRelationsDetailsClient<$Result.GetResult<Prisma.$UsersRelationsDetailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UsersRelationsDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersRelationsDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsersRelationsDetails
     * const usersRelationsDetails = await prisma.usersRelationsDetails.findMany()
     * 
     * // Get first 10 UsersRelationsDetails
     * const usersRelationsDetails = await prisma.usersRelationsDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersRelationsDetailsWithIdOnly = await prisma.usersRelationsDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsersRelationsDetailsFindManyArgs>(args?: SelectSubset<T, UsersRelationsDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersRelationsDetailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UsersRelationsDetails.
     * @param {UsersRelationsDetailsCreateArgs} args - Arguments to create a UsersRelationsDetails.
     * @example
     * // Create one UsersRelationsDetails
     * const UsersRelationsDetails = await prisma.usersRelationsDetails.create({
     *   data: {
     *     // ... data to create a UsersRelationsDetails
     *   }
     * })
     * 
     */
    create<T extends UsersRelationsDetailsCreateArgs>(args: SelectSubset<T, UsersRelationsDetailsCreateArgs<ExtArgs>>): Prisma__UsersRelationsDetailsClient<$Result.GetResult<Prisma.$UsersRelationsDetailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UsersRelationsDetails.
     * @param {UsersRelationsDetailsCreateManyArgs} args - Arguments to create many UsersRelationsDetails.
     * @example
     * // Create many UsersRelationsDetails
     * const usersRelationsDetails = await prisma.usersRelationsDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersRelationsDetailsCreateManyArgs>(args?: SelectSubset<T, UsersRelationsDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UsersRelationsDetails.
     * @param {UsersRelationsDetailsDeleteArgs} args - Arguments to delete one UsersRelationsDetails.
     * @example
     * // Delete one UsersRelationsDetails
     * const UsersRelationsDetails = await prisma.usersRelationsDetails.delete({
     *   where: {
     *     // ... filter to delete one UsersRelationsDetails
     *   }
     * })
     * 
     */
    delete<T extends UsersRelationsDetailsDeleteArgs>(args: SelectSubset<T, UsersRelationsDetailsDeleteArgs<ExtArgs>>): Prisma__UsersRelationsDetailsClient<$Result.GetResult<Prisma.$UsersRelationsDetailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UsersRelationsDetails.
     * @param {UsersRelationsDetailsUpdateArgs} args - Arguments to update one UsersRelationsDetails.
     * @example
     * // Update one UsersRelationsDetails
     * const usersRelationsDetails = await prisma.usersRelationsDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersRelationsDetailsUpdateArgs>(args: SelectSubset<T, UsersRelationsDetailsUpdateArgs<ExtArgs>>): Prisma__UsersRelationsDetailsClient<$Result.GetResult<Prisma.$UsersRelationsDetailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UsersRelationsDetails.
     * @param {UsersRelationsDetailsDeleteManyArgs} args - Arguments to filter UsersRelationsDetails to delete.
     * @example
     * // Delete a few UsersRelationsDetails
     * const { count } = await prisma.usersRelationsDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersRelationsDetailsDeleteManyArgs>(args?: SelectSubset<T, UsersRelationsDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsersRelationsDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersRelationsDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsersRelationsDetails
     * const usersRelationsDetails = await prisma.usersRelationsDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersRelationsDetailsUpdateManyArgs>(args: SelectSubset<T, UsersRelationsDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UsersRelationsDetails.
     * @param {UsersRelationsDetailsUpsertArgs} args - Arguments to update or create a UsersRelationsDetails.
     * @example
     * // Update or create a UsersRelationsDetails
     * const usersRelationsDetails = await prisma.usersRelationsDetails.upsert({
     *   create: {
     *     // ... data to create a UsersRelationsDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsersRelationsDetails we want to update
     *   }
     * })
     */
    upsert<T extends UsersRelationsDetailsUpsertArgs>(args: SelectSubset<T, UsersRelationsDetailsUpsertArgs<ExtArgs>>): Prisma__UsersRelationsDetailsClient<$Result.GetResult<Prisma.$UsersRelationsDetailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UsersRelationsDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersRelationsDetailsCountArgs} args - Arguments to filter UsersRelationsDetails to count.
     * @example
     * // Count the number of UsersRelationsDetails
     * const count = await prisma.usersRelationsDetails.count({
     *   where: {
     *     // ... the filter for the UsersRelationsDetails we want to count
     *   }
     * })
    **/
    count<T extends UsersRelationsDetailsCountArgs>(
      args?: Subset<T, UsersRelationsDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersRelationsDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsersRelationsDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersRelationsDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersRelationsDetailsAggregateArgs>(args: Subset<T, UsersRelationsDetailsAggregateArgs>): Prisma.PrismaPromise<GetUsersRelationsDetailsAggregateType<T>>

    /**
     * Group by UsersRelationsDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersRelationsDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersRelationsDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersRelationsDetailsGroupByArgs['orderBy'] }
        : { orderBy?: UsersRelationsDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersRelationsDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersRelationsDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsersRelationsDetails model
   */
  readonly fields: UsersRelationsDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsersRelationsDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersRelationsDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    UsersRelations<T extends UsersRelationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersRelationsDefaultArgs<ExtArgs>>): Prisma__UsersRelationsClient<$Result.GetResult<Prisma.$UsersRelationsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    RelationsChoices<T extends RelationsChoicesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RelationsChoicesDefaultArgs<ExtArgs>>): Prisma__RelationsChoicesClient<$Result.GetResult<Prisma.$RelationsChoicesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    RelationsQuestions<T extends RelationsQuestionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RelationsQuestionsDefaultArgs<ExtArgs>>): Prisma__RelationsQuestionsClient<$Result.GetResult<Prisma.$RelationsQuestionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsersRelationsDetails model
   */ 
  interface UsersRelationsDetailsFieldRefs {
    readonly id: FieldRef<"UsersRelationsDetails", 'BigInt'>
    readonly urId: FieldRef<"UsersRelationsDetails", 'BigInt'>
    readonly rqId: FieldRef<"UsersRelationsDetails", 'BigInt'>
    readonly rcId: FieldRef<"UsersRelationsDetails", 'BigInt'>
    readonly observed: FieldRef<"UsersRelationsDetails", 'Boolean'>
    readonly createdAt: FieldRef<"UsersRelationsDetails", 'DateTime'>
    readonly updatedAt: FieldRef<"UsersRelationsDetails", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsersRelationsDetails findUnique
   */
  export type UsersRelationsDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersRelationsDetails
     */
    select?: UsersRelationsDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersRelationsDetailsInclude<ExtArgs> | null
    /**
     * Filter, which UsersRelationsDetails to fetch.
     */
    where: UsersRelationsDetailsWhereUniqueInput
  }

  /**
   * UsersRelationsDetails findUniqueOrThrow
   */
  export type UsersRelationsDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersRelationsDetails
     */
    select?: UsersRelationsDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersRelationsDetailsInclude<ExtArgs> | null
    /**
     * Filter, which UsersRelationsDetails to fetch.
     */
    where: UsersRelationsDetailsWhereUniqueInput
  }

  /**
   * UsersRelationsDetails findFirst
   */
  export type UsersRelationsDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersRelationsDetails
     */
    select?: UsersRelationsDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersRelationsDetailsInclude<ExtArgs> | null
    /**
     * Filter, which UsersRelationsDetails to fetch.
     */
    where?: UsersRelationsDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersRelationsDetails to fetch.
     */
    orderBy?: UsersRelationsDetailsOrderByWithRelationInput | UsersRelationsDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsersRelationsDetails.
     */
    cursor?: UsersRelationsDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersRelationsDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersRelationsDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsersRelationsDetails.
     */
    distinct?: UsersRelationsDetailsScalarFieldEnum | UsersRelationsDetailsScalarFieldEnum[]
  }

  /**
   * UsersRelationsDetails findFirstOrThrow
   */
  export type UsersRelationsDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersRelationsDetails
     */
    select?: UsersRelationsDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersRelationsDetailsInclude<ExtArgs> | null
    /**
     * Filter, which UsersRelationsDetails to fetch.
     */
    where?: UsersRelationsDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersRelationsDetails to fetch.
     */
    orderBy?: UsersRelationsDetailsOrderByWithRelationInput | UsersRelationsDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsersRelationsDetails.
     */
    cursor?: UsersRelationsDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersRelationsDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersRelationsDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsersRelationsDetails.
     */
    distinct?: UsersRelationsDetailsScalarFieldEnum | UsersRelationsDetailsScalarFieldEnum[]
  }

  /**
   * UsersRelationsDetails findMany
   */
  export type UsersRelationsDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersRelationsDetails
     */
    select?: UsersRelationsDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersRelationsDetailsInclude<ExtArgs> | null
    /**
     * Filter, which UsersRelationsDetails to fetch.
     */
    where?: UsersRelationsDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsersRelationsDetails to fetch.
     */
    orderBy?: UsersRelationsDetailsOrderByWithRelationInput | UsersRelationsDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsersRelationsDetails.
     */
    cursor?: UsersRelationsDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsersRelationsDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsersRelationsDetails.
     */
    skip?: number
    distinct?: UsersRelationsDetailsScalarFieldEnum | UsersRelationsDetailsScalarFieldEnum[]
  }

  /**
   * UsersRelationsDetails create
   */
  export type UsersRelationsDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersRelationsDetails
     */
    select?: UsersRelationsDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersRelationsDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a UsersRelationsDetails.
     */
    data: XOR<UsersRelationsDetailsCreateInput, UsersRelationsDetailsUncheckedCreateInput>
  }

  /**
   * UsersRelationsDetails createMany
   */
  export type UsersRelationsDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsersRelationsDetails.
     */
    data: UsersRelationsDetailsCreateManyInput | UsersRelationsDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsersRelationsDetails update
   */
  export type UsersRelationsDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersRelationsDetails
     */
    select?: UsersRelationsDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersRelationsDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a UsersRelationsDetails.
     */
    data: XOR<UsersRelationsDetailsUpdateInput, UsersRelationsDetailsUncheckedUpdateInput>
    /**
     * Choose, which UsersRelationsDetails to update.
     */
    where: UsersRelationsDetailsWhereUniqueInput
  }

  /**
   * UsersRelationsDetails updateMany
   */
  export type UsersRelationsDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsersRelationsDetails.
     */
    data: XOR<UsersRelationsDetailsUpdateManyMutationInput, UsersRelationsDetailsUncheckedUpdateManyInput>
    /**
     * Filter which UsersRelationsDetails to update
     */
    where?: UsersRelationsDetailsWhereInput
  }

  /**
   * UsersRelationsDetails upsert
   */
  export type UsersRelationsDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersRelationsDetails
     */
    select?: UsersRelationsDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersRelationsDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the UsersRelationsDetails to update in case it exists.
     */
    where: UsersRelationsDetailsWhereUniqueInput
    /**
     * In case the UsersRelationsDetails found by the `where` argument doesn't exist, create a new UsersRelationsDetails with this data.
     */
    create: XOR<UsersRelationsDetailsCreateInput, UsersRelationsDetailsUncheckedCreateInput>
    /**
     * In case the UsersRelationsDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersRelationsDetailsUpdateInput, UsersRelationsDetailsUncheckedUpdateInput>
  }

  /**
   * UsersRelationsDetails delete
   */
  export type UsersRelationsDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersRelationsDetails
     */
    select?: UsersRelationsDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersRelationsDetailsInclude<ExtArgs> | null
    /**
     * Filter which UsersRelationsDetails to delete.
     */
    where: UsersRelationsDetailsWhereUniqueInput
  }

  /**
   * UsersRelationsDetails deleteMany
   */
  export type UsersRelationsDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsersRelationsDetails to delete
     */
    where?: UsersRelationsDetailsWhereInput
  }

  /**
   * UsersRelationsDetails without action
   */
  export type UsersRelationsDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersRelationsDetails
     */
    select?: UsersRelationsDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersRelationsDetailsInclude<ExtArgs> | null
  }


  /**
   * Model Locations
   */

  export type AggregateLocations = {
    _count: LocationsCountAggregateOutputType | null
    _avg: LocationsAvgAggregateOutputType | null
    _sum: LocationsSumAggregateOutputType | null
    _min: LocationsMinAggregateOutputType | null
    _max: LocationsMaxAggregateOutputType | null
  }

  export type LocationsAvgAggregateOutputType = {
    id: number | null
  }

  export type LocationsSumAggregateOutputType = {
    id: bigint | null
  }

  export type LocationsMinAggregateOutputType = {
    id: bigint | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type LocationsMaxAggregateOutputType = {
    id: bigint | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type LocationsCountAggregateOutputType = {
    id: number
    location: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type LocationsAvgAggregateInputType = {
    id?: true
  }

  export type LocationsSumAggregateInputType = {
    id?: true
  }

  export type LocationsMinAggregateInputType = {
    id?: true
    location?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type LocationsMaxAggregateInputType = {
    id?: true
    location?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type LocationsCountAggregateInputType = {
    id?: true
    location?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type LocationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to aggregate.
     */
    where?: LocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationsOrderByWithRelationInput | LocationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationsMaxAggregateInputType
  }

  export type GetLocationsAggregateType<T extends LocationsAggregateArgs> = {
        [P in keyof T & keyof AggregateLocations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocations[P]>
      : GetScalarType<T[P], AggregateLocations[P]>
  }




  export type LocationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationsWhereInput
    orderBy?: LocationsOrderByWithAggregationInput | LocationsOrderByWithAggregationInput[]
    by: LocationsScalarFieldEnum[] | LocationsScalarFieldEnum
    having?: LocationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationsCountAggregateInputType | true
    _avg?: LocationsAvgAggregateInputType
    _sum?: LocationsSumAggregateInputType
    _min?: LocationsMinAggregateInputType
    _max?: LocationsMaxAggregateInputType
  }

  export type LocationsGroupByOutputType = {
    id: bigint
    location: string
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    _count: LocationsCountAggregateOutputType | null
    _avg: LocationsAvgAggregateOutputType | null
    _sum: LocationsSumAggregateOutputType | null
    _min: LocationsMinAggregateOutputType | null
    _max: LocationsMaxAggregateOutputType | null
  }

  type GetLocationsGroupByPayload<T extends LocationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationsGroupByOutputType[P]>
            : GetScalarType<T[P], LocationsGroupByOutputType[P]>
        }
      >
    >


  export type LocationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    Users?: boolean | Locations$UsersArgs<ExtArgs>
    _count?: boolean | LocationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locations"]>


  export type LocationsSelectScalar = {
    id?: boolean
    location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type LocationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | Locations$UsersArgs<ExtArgs>
    _count?: boolean | LocationsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LocationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Locations"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      location: string
      createdAt: Date | null
      updatedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["locations"]>
    composites: {}
  }

  type LocationsGetPayload<S extends boolean | null | undefined | LocationsDefaultArgs> = $Result.GetResult<Prisma.$LocationsPayload, S>

  type LocationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LocationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LocationsCountAggregateInputType | true
    }

  export interface LocationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Locations'], meta: { name: 'Locations' } }
    /**
     * Find zero or one Locations that matches the filter.
     * @param {LocationsFindUniqueArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationsFindUniqueArgs>(args: SelectSubset<T, LocationsFindUniqueArgs<ExtArgs>>): Prisma__LocationsClient<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Locations that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LocationsFindUniqueOrThrowArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationsFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationsClient<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsFindFirstArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationsFindFirstArgs>(args?: SelectSubset<T, LocationsFindFirstArgs<ExtArgs>>): Prisma__LocationsClient<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Locations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsFindFirstOrThrowArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationsFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationsClient<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.locations.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.locations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationsWithIdOnly = await prisma.locations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationsFindManyArgs>(args?: SelectSubset<T, LocationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Locations.
     * @param {LocationsCreateArgs} args - Arguments to create a Locations.
     * @example
     * // Create one Locations
     * const Locations = await prisma.locations.create({
     *   data: {
     *     // ... data to create a Locations
     *   }
     * })
     * 
     */
    create<T extends LocationsCreateArgs>(args: SelectSubset<T, LocationsCreateArgs<ExtArgs>>): Prisma__LocationsClient<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Locations.
     * @param {LocationsCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const locations = await prisma.locations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationsCreateManyArgs>(args?: SelectSubset<T, LocationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Locations.
     * @param {LocationsDeleteArgs} args - Arguments to delete one Locations.
     * @example
     * // Delete one Locations
     * const Locations = await prisma.locations.delete({
     *   where: {
     *     // ... filter to delete one Locations
     *   }
     * })
     * 
     */
    delete<T extends LocationsDeleteArgs>(args: SelectSubset<T, LocationsDeleteArgs<ExtArgs>>): Prisma__LocationsClient<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Locations.
     * @param {LocationsUpdateArgs} args - Arguments to update one Locations.
     * @example
     * // Update one Locations
     * const locations = await prisma.locations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationsUpdateArgs>(args: SelectSubset<T, LocationsUpdateArgs<ExtArgs>>): Prisma__LocationsClient<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Locations.
     * @param {LocationsDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.locations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationsDeleteManyArgs>(args?: SelectSubset<T, LocationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const locations = await prisma.locations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationsUpdateManyArgs>(args: SelectSubset<T, LocationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Locations.
     * @param {LocationsUpsertArgs} args - Arguments to update or create a Locations.
     * @example
     * // Update or create a Locations
     * const locations = await prisma.locations.upsert({
     *   create: {
     *     // ... data to create a Locations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Locations we want to update
     *   }
     * })
     */
    upsert<T extends LocationsUpsertArgs>(args: SelectSubset<T, LocationsUpsertArgs<ExtArgs>>): Prisma__LocationsClient<$Result.GetResult<Prisma.$LocationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.locations.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationsCountArgs>(
      args?: Subset<T, LocationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationsAggregateArgs>(args: Subset<T, LocationsAggregateArgs>): Prisma.PrismaPromise<GetLocationsAggregateType<T>>

    /**
     * Group by Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationsGroupByArgs['orderBy'] }
        : { orderBy?: LocationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Locations model
   */
  readonly fields: LocationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Locations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends Locations$UsersArgs<ExtArgs> = {}>(args?: Subset<T, Locations$UsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Locations model
   */ 
  interface LocationsFieldRefs {
    readonly id: FieldRef<"Locations", 'BigInt'>
    readonly location: FieldRef<"Locations", 'String'>
    readonly createdAt: FieldRef<"Locations", 'DateTime'>
    readonly updatedAt: FieldRef<"Locations", 'DateTime'>
    readonly deletedAt: FieldRef<"Locations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Locations findUnique
   */
  export type LocationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where: LocationsWhereUniqueInput
  }

  /**
   * Locations findUniqueOrThrow
   */
  export type LocationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where: LocationsWhereUniqueInput
  }

  /**
   * Locations findFirst
   */
  export type LocationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationsOrderByWithRelationInput | LocationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationsScalarFieldEnum | LocationsScalarFieldEnum[]
  }

  /**
   * Locations findFirstOrThrow
   */
  export type LocationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationsOrderByWithRelationInput | LocationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationsScalarFieldEnum | LocationsScalarFieldEnum[]
  }

  /**
   * Locations findMany
   */
  export type LocationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationsOrderByWithRelationInput | LocationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationsScalarFieldEnum | LocationsScalarFieldEnum[]
  }

  /**
   * Locations create
   */
  export type LocationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * The data needed to create a Locations.
     */
    data: XOR<LocationsCreateInput, LocationsUncheckedCreateInput>
  }

  /**
   * Locations createMany
   */
  export type LocationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationsCreateManyInput | LocationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Locations update
   */
  export type LocationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * The data needed to update a Locations.
     */
    data: XOR<LocationsUpdateInput, LocationsUncheckedUpdateInput>
    /**
     * Choose, which Locations to update.
     */
    where: LocationsWhereUniqueInput
  }

  /**
   * Locations updateMany
   */
  export type LocationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationsUpdateManyMutationInput, LocationsUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationsWhereInput
  }

  /**
   * Locations upsert
   */
  export type LocationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * The filter to search for the Locations to update in case it exists.
     */
    where: LocationsWhereUniqueInput
    /**
     * In case the Locations found by the `where` argument doesn't exist, create a new Locations with this data.
     */
    create: XOR<LocationsCreateInput, LocationsUncheckedCreateInput>
    /**
     * In case the Locations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationsUpdateInput, LocationsUncheckedUpdateInput>
  }

  /**
   * Locations delete
   */
  export type LocationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
    /**
     * Filter which Locations to delete.
     */
    where: LocationsWhereUniqueInput
  }

  /**
   * Locations deleteMany
   */
  export type LocationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationsWhereInput
  }

  /**
   * Locations.Users
   */
  export type Locations$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    cursor?: UsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Locations without action
   */
  export type LocationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Locations
     */
    select?: LocationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AudioScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    enabled: 'enabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type AudioScalarFieldEnum = (typeof AudioScalarFieldEnum)[keyof typeof AudioScalarFieldEnum]


  export const AuthorizationsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    enabled: 'enabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuthorizationsScalarFieldEnum = (typeof AuthorizationsScalarFieldEnum)[keyof typeof AuthorizationsScalarFieldEnum]


  export const ChoicesScalarFieldEnum: {
    id: 'id',
    enabled: 'enabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ChoicesScalarFieldEnum = (typeof ChoicesScalarFieldEnum)[keyof typeof ChoicesScalarFieldEnum]


  export const ChoicesLangScalarFieldEnum: {
    id: 'id',
    chId: 'chId',
    lang: 'lang',
    text: 'text',
    hint: 'hint',
    audio: 'audio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ChoicesLangScalarFieldEnum = (typeof ChoicesLangScalarFieldEnum)[keyof typeof ChoicesLangScalarFieldEnum]


  export const FailedJobsScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    connection: 'connection',
    queue: 'queue',
    payload: 'payload',
    exception: 'exception',
    failedAt: 'failedAt'
  };

  export type FailedJobsScalarFieldEnum = (typeof FailedJobsScalarFieldEnum)[keyof typeof FailedJobsScalarFieldEnum]


  export const GroupsScalarFieldEnum: {
    id: 'id',
    code: 'code',
    level: 'level',
    media: 'media',
    randCount: 'randCount',
    enabled: 'enabled',
    other: 'other',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type GroupsScalarFieldEnum = (typeof GroupsScalarFieldEnum)[keyof typeof GroupsScalarFieldEnum]


  export const GroupsLangScalarFieldEnum: {
    id: 'id',
    gpId: 'gpId',
    lang: 'lang',
    name: 'name',
    desc: 'desc',
    audio: 'audio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type GroupsLangScalarFieldEnum = (typeof GroupsLangScalarFieldEnum)[keyof typeof GroupsLangScalarFieldEnum]


  export const LanguagesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    voiceCode: 'voiceCode',
    voiceType: 'voiceType',
    voiceName: 'voiceName',
    voiceGender: 'voiceGender',
    voiceProfile: 'voiceProfile',
    enabled: 'enabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type LanguagesScalarFieldEnum = (typeof LanguagesScalarFieldEnum)[keyof typeof LanguagesScalarFieldEnum]


  export const LicensesScalarFieldEnum: {
    id: 'id',
    code: 'code',
    media: 'media',
    enabled: 'enabled',
    other: 'other',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type LicensesScalarFieldEnum = (typeof LicensesScalarFieldEnum)[keyof typeof LicensesScalarFieldEnum]


  export const LicensesLangScalarFieldEnum: {
    id: 'id',
    liId: 'liId',
    lang: 'lang',
    name: 'name',
    desc: 'desc',
    audio: 'audio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type LicensesLangScalarFieldEnum = (typeof LicensesLangScalarFieldEnum)[keyof typeof LicensesLangScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    name: 'name',
    extension: 'extension',
    url: 'url',
    uploadedName: 'uploadedName',
    enabled: 'enabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const MigrationsScalarFieldEnum: {
    id: 'id',
    migration: 'migration',
    batch: 'batch'
  };

  export type MigrationsScalarFieldEnum = (typeof MigrationsScalarFieldEnum)[keyof typeof MigrationsScalarFieldEnum]


  export const PasswordResetsScalarFieldEnum: {
    email: 'email',
    token: 'token',
    createdAt: 'createdAt'
  };

  export type PasswordResetsScalarFieldEnum = (typeof PasswordResetsScalarFieldEnum)[keyof typeof PasswordResetsScalarFieldEnum]


  export const QuestionsScalarFieldEnum: {
    id: 'id',
    enabled: 'enabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type QuestionsScalarFieldEnum = (typeof QuestionsScalarFieldEnum)[keyof typeof QuestionsScalarFieldEnum]


  export const QuestionsLangScalarFieldEnum: {
    id: 'id',
    qsId: 'qsId',
    lang: 'lang',
    text: 'text',
    hint: 'hint',
    audio: 'audio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type QuestionsLangScalarFieldEnum = (typeof QuestionsLangScalarFieldEnum)[keyof typeof QuestionsLangScalarFieldEnum]


  export const QuizzesScalarFieldEnum: {
    id: 'id',
    code: 'code',
    duration: 'duration',
    level: 'level',
    media: 'media',
    enabled: 'enabled',
    other: 'other',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type QuizzesScalarFieldEnum = (typeof QuizzesScalarFieldEnum)[keyof typeof QuizzesScalarFieldEnum]


  export const QuizzesLangScalarFieldEnum: {
    id: 'id',
    qzId: 'qzId',
    lang: 'lang',
    name: 'name',
    desc: 'desc',
    audio: 'audio',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type QuizzesLangScalarFieldEnum = (typeof QuizzesLangScalarFieldEnum)[keyof typeof QuizzesLangScalarFieldEnum]


  export const RelationsScalarFieldEnum: {
    id: 'id',
    liId: 'liId',
    gpId: 'gpId',
    qzId: 'qzId',
    enabled: 'enabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type RelationsScalarFieldEnum = (typeof RelationsScalarFieldEnum)[keyof typeof RelationsScalarFieldEnum]


  export const RelationsChoicesScalarFieldEnum: {
    id: 'id',
    rqId: 'rqId',
    chId: 'chId',
    mdId: 'mdId',
    correct: 'correct',
    ordering: 'ordering',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    relationsId: 'relationsId'
  };

  export type RelationsChoicesScalarFieldEnum = (typeof RelationsChoicesScalarFieldEnum)[keyof typeof RelationsChoicesScalarFieldEnum]


  export const RelationsQuestionsScalarFieldEnum: {
    id: 'id',
    reId: 'reId',
    qsId: 'qsId',
    mdId: 'mdId',
    ordering: 'ordering',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type RelationsQuestionsScalarFieldEnum = (typeof RelationsQuestionsScalarFieldEnum)[keyof typeof RelationsQuestionsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    personalNumber: 'personalNumber',
    name: 'name',
    email: 'email',
    phone: 'phone',
    location: 'location',
    admin: 'admin',
    enabled: 'enabled',
    activationDate: 'activationDate',
    rememberToken: 'rememberToken',
    emailVerifiedAt: 'emailVerifiedAt',
    password: 'password',
    twoFactorSecret: 'twoFactorSecret',
    twoFactorRecoveryCodes: 'twoFactorRecoveryCodes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const UsersAuthScalarFieldEnum: {
    id: 'id',
    usId: 'usId',
    auId: 'auId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UsersAuthScalarFieldEnum = (typeof UsersAuthScalarFieldEnum)[keyof typeof UsersAuthScalarFieldEnum]


  export const UsersGroupsScalarFieldEnum: {
    id: 'id',
    usId: 'usId',
    gpId: 'gpId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UsersGroupsScalarFieldEnum = (typeof UsersGroupsScalarFieldEnum)[keyof typeof UsersGroupsScalarFieldEnum]


  export const UsersLoginScalarFieldEnum: {
    id: 'id',
    usId: 'usId',
    action: 'action',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsersLoginScalarFieldEnum = (typeof UsersLoginScalarFieldEnum)[keyof typeof UsersLoginScalarFieldEnum]


  export const UsersRelationsScalarFieldEnum: {
    id: 'id',
    usId: 'usId',
    reId: 'reId',
    correct: 'correct',
    wrong: 'wrong',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsersRelationsScalarFieldEnum = (typeof UsersRelationsScalarFieldEnum)[keyof typeof UsersRelationsScalarFieldEnum]


  export const UsersRelationsDetailsScalarFieldEnum: {
    id: 'id',
    urId: 'urId',
    rqId: 'rqId',
    rcId: 'rcId',
    observed: 'observed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsersRelationsDetailsScalarFieldEnum = (typeof UsersRelationsDetailsScalarFieldEnum)[keyof typeof UsersRelationsDetailsScalarFieldEnum]


  export const LocationsScalarFieldEnum: {
    id: 'id',
    location: 'location',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type LocationsScalarFieldEnum = (typeof LocationsScalarFieldEnum)[keyof typeof LocationsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type AudioWhereInput = {
    AND?: AudioWhereInput | AudioWhereInput[]
    OR?: AudioWhereInput[]
    NOT?: AudioWhereInput | AudioWhereInput[]
    id?: BigIntFilter<"Audio"> | bigint | number
    name?: StringFilter<"Audio"> | string
    url?: StringFilter<"Audio"> | string
    enabled?: BoolFilter<"Audio"> | boolean
    createdAt?: DateTimeNullableFilter<"Audio"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Audio"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Audio"> | Date | string | null
    ChoicesLang?: ChoicesLangListRelationFilter
    GroupsLang?: GroupsLangListRelationFilter
    LicensesLang?: LicensesLangListRelationFilter
    QuizzesLang?: QuizzesLangListRelationFilter
    QuestionsLang?: QuestionsLangListRelationFilter
  }

  export type AudioOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    ChoicesLang?: ChoicesLangOrderByRelationAggregateInput
    GroupsLang?: GroupsLangOrderByRelationAggregateInput
    LicensesLang?: LicensesLangOrderByRelationAggregateInput
    QuizzesLang?: QuizzesLangOrderByRelationAggregateInput
    QuestionsLang?: QuestionsLangOrderByRelationAggregateInput
  }

  export type AudioWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: AudioWhereInput | AudioWhereInput[]
    OR?: AudioWhereInput[]
    NOT?: AudioWhereInput | AudioWhereInput[]
    name?: StringFilter<"Audio"> | string
    url?: StringFilter<"Audio"> | string
    enabled?: BoolFilter<"Audio"> | boolean
    createdAt?: DateTimeNullableFilter<"Audio"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Audio"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Audio"> | Date | string | null
    ChoicesLang?: ChoicesLangListRelationFilter
    GroupsLang?: GroupsLangListRelationFilter
    LicensesLang?: LicensesLangListRelationFilter
    QuizzesLang?: QuizzesLangListRelationFilter
    QuestionsLang?: QuestionsLangListRelationFilter
  }, "id">

  export type AudioOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: AudioCountOrderByAggregateInput
    _avg?: AudioAvgOrderByAggregateInput
    _max?: AudioMaxOrderByAggregateInput
    _min?: AudioMinOrderByAggregateInput
    _sum?: AudioSumOrderByAggregateInput
  }

  export type AudioScalarWhereWithAggregatesInput = {
    AND?: AudioScalarWhereWithAggregatesInput | AudioScalarWhereWithAggregatesInput[]
    OR?: AudioScalarWhereWithAggregatesInput[]
    NOT?: AudioScalarWhereWithAggregatesInput | AudioScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Audio"> | bigint | number
    name?: StringWithAggregatesFilter<"Audio"> | string
    url?: StringWithAggregatesFilter<"Audio"> | string
    enabled?: BoolWithAggregatesFilter<"Audio"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"Audio"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Audio"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Audio"> | Date | string | null
  }

  export type AuthorizationsWhereInput = {
    AND?: AuthorizationsWhereInput | AuthorizationsWhereInput[]
    OR?: AuthorizationsWhereInput[]
    NOT?: AuthorizationsWhereInput | AuthorizationsWhereInput[]
    id?: BigIntFilter<"Authorizations"> | bigint | number
    name?: StringFilter<"Authorizations"> | string
    enabled?: BoolFilter<"Authorizations"> | boolean
    createdAt?: DateTimeNullableFilter<"Authorizations"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Authorizations"> | Date | string | null
    UsersAuth?: UsersAuthListRelationFilter
  }

  export type AuthorizationsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    UsersAuth?: UsersAuthOrderByRelationAggregateInput
  }

  export type AuthorizationsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: AuthorizationsWhereInput | AuthorizationsWhereInput[]
    OR?: AuthorizationsWhereInput[]
    NOT?: AuthorizationsWhereInput | AuthorizationsWhereInput[]
    name?: StringFilter<"Authorizations"> | string
    enabled?: BoolFilter<"Authorizations"> | boolean
    createdAt?: DateTimeNullableFilter<"Authorizations"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Authorizations"> | Date | string | null
    UsersAuth?: UsersAuthListRelationFilter
  }, "id">

  export type AuthorizationsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: AuthorizationsCountOrderByAggregateInput
    _avg?: AuthorizationsAvgOrderByAggregateInput
    _max?: AuthorizationsMaxOrderByAggregateInput
    _min?: AuthorizationsMinOrderByAggregateInput
    _sum?: AuthorizationsSumOrderByAggregateInput
  }

  export type AuthorizationsScalarWhereWithAggregatesInput = {
    AND?: AuthorizationsScalarWhereWithAggregatesInput | AuthorizationsScalarWhereWithAggregatesInput[]
    OR?: AuthorizationsScalarWhereWithAggregatesInput[]
    NOT?: AuthorizationsScalarWhereWithAggregatesInput | AuthorizationsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Authorizations"> | bigint | number
    name?: StringWithAggregatesFilter<"Authorizations"> | string
    enabled?: BoolWithAggregatesFilter<"Authorizations"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"Authorizations"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Authorizations"> | Date | string | null
  }

  export type ChoicesWhereInput = {
    AND?: ChoicesWhereInput | ChoicesWhereInput[]
    OR?: ChoicesWhereInput[]
    NOT?: ChoicesWhereInput | ChoicesWhereInput[]
    id?: BigIntFilter<"Choices"> | bigint | number
    enabled?: BoolFilter<"Choices"> | boolean
    createdAt?: DateTimeNullableFilter<"Choices"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Choices"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Choices"> | Date | string | null
    ChoicesLang?: ChoicesLangListRelationFilter
    RelationsChoices?: RelationsChoicesListRelationFilter
  }

  export type ChoicesOrderByWithRelationInput = {
    id?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    ChoicesLang?: ChoicesLangOrderByRelationAggregateInput
    RelationsChoices?: RelationsChoicesOrderByRelationAggregateInput
  }

  export type ChoicesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: ChoicesWhereInput | ChoicesWhereInput[]
    OR?: ChoicesWhereInput[]
    NOT?: ChoicesWhereInput | ChoicesWhereInput[]
    enabled?: BoolFilter<"Choices"> | boolean
    createdAt?: DateTimeNullableFilter<"Choices"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Choices"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Choices"> | Date | string | null
    ChoicesLang?: ChoicesLangListRelationFilter
    RelationsChoices?: RelationsChoicesListRelationFilter
  }, "id">

  export type ChoicesOrderByWithAggregationInput = {
    id?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ChoicesCountOrderByAggregateInput
    _avg?: ChoicesAvgOrderByAggregateInput
    _max?: ChoicesMaxOrderByAggregateInput
    _min?: ChoicesMinOrderByAggregateInput
    _sum?: ChoicesSumOrderByAggregateInput
  }

  export type ChoicesScalarWhereWithAggregatesInput = {
    AND?: ChoicesScalarWhereWithAggregatesInput | ChoicesScalarWhereWithAggregatesInput[]
    OR?: ChoicesScalarWhereWithAggregatesInput[]
    NOT?: ChoicesScalarWhereWithAggregatesInput | ChoicesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Choices"> | bigint | number
    enabled?: BoolWithAggregatesFilter<"Choices"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"Choices"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Choices"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Choices"> | Date | string | null
  }

  export type ChoicesLangWhereInput = {
    AND?: ChoicesLangWhereInput | ChoicesLangWhereInput[]
    OR?: ChoicesLangWhereInput[]
    NOT?: ChoicesLangWhereInput | ChoicesLangWhereInput[]
    id?: BigIntFilter<"ChoicesLang"> | bigint | number
    chId?: BigIntFilter<"ChoicesLang"> | bigint | number
    lang?: BigIntFilter<"ChoicesLang"> | bigint | number
    text?: StringFilter<"ChoicesLang"> | string
    hint?: StringNullableFilter<"ChoicesLang"> | string | null
    audio?: BigIntNullableFilter<"ChoicesLang"> | bigint | number | null
    createdAt?: DateTimeNullableFilter<"ChoicesLang"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ChoicesLang"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"ChoicesLang"> | Date | string | null
    Choices?: XOR<ChoicesRelationFilter, ChoicesWhereInput>
    Languages?: XOR<LanguagesRelationFilter, LanguagesWhereInput>
    Audio?: XOR<AudioNullableRelationFilter, AudioWhereInput> | null
  }

  export type ChoicesLangOrderByWithRelationInput = {
    id?: SortOrder
    chId?: SortOrder
    lang?: SortOrder
    text?: SortOrder
    hint?: SortOrderInput | SortOrder
    audio?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    Choices?: ChoicesOrderByWithRelationInput
    Languages?: LanguagesOrderByWithRelationInput
    Audio?: AudioOrderByWithRelationInput
  }

  export type ChoicesLangWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    chId_lang_deletedAt?: ChoicesLangChIdLangDeletedAtCompoundUniqueInput
    AND?: ChoicesLangWhereInput | ChoicesLangWhereInput[]
    OR?: ChoicesLangWhereInput[]
    NOT?: ChoicesLangWhereInput | ChoicesLangWhereInput[]
    chId?: BigIntFilter<"ChoicesLang"> | bigint | number
    lang?: BigIntFilter<"ChoicesLang"> | bigint | number
    text?: StringFilter<"ChoicesLang"> | string
    hint?: StringNullableFilter<"ChoicesLang"> | string | null
    audio?: BigIntNullableFilter<"ChoicesLang"> | bigint | number | null
    createdAt?: DateTimeNullableFilter<"ChoicesLang"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ChoicesLang"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"ChoicesLang"> | Date | string | null
    Choices?: XOR<ChoicesRelationFilter, ChoicesWhereInput>
    Languages?: XOR<LanguagesRelationFilter, LanguagesWhereInput>
    Audio?: XOR<AudioNullableRelationFilter, AudioWhereInput> | null
  }, "id" | "chId_lang_deletedAt">

  export type ChoicesLangOrderByWithAggregationInput = {
    id?: SortOrder
    chId?: SortOrder
    lang?: SortOrder
    text?: SortOrder
    hint?: SortOrderInput | SortOrder
    audio?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ChoicesLangCountOrderByAggregateInput
    _avg?: ChoicesLangAvgOrderByAggregateInput
    _max?: ChoicesLangMaxOrderByAggregateInput
    _min?: ChoicesLangMinOrderByAggregateInput
    _sum?: ChoicesLangSumOrderByAggregateInput
  }

  export type ChoicesLangScalarWhereWithAggregatesInput = {
    AND?: ChoicesLangScalarWhereWithAggregatesInput | ChoicesLangScalarWhereWithAggregatesInput[]
    OR?: ChoicesLangScalarWhereWithAggregatesInput[]
    NOT?: ChoicesLangScalarWhereWithAggregatesInput | ChoicesLangScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"ChoicesLang"> | bigint | number
    chId?: BigIntWithAggregatesFilter<"ChoicesLang"> | bigint | number
    lang?: BigIntWithAggregatesFilter<"ChoicesLang"> | bigint | number
    text?: StringWithAggregatesFilter<"ChoicesLang"> | string
    hint?: StringNullableWithAggregatesFilter<"ChoicesLang"> | string | null
    audio?: BigIntNullableWithAggregatesFilter<"ChoicesLang"> | bigint | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"ChoicesLang"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"ChoicesLang"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ChoicesLang"> | Date | string | null
  }

  export type FailedJobsWhereInput = {
    AND?: FailedJobsWhereInput | FailedJobsWhereInput[]
    OR?: FailedJobsWhereInput[]
    NOT?: FailedJobsWhereInput | FailedJobsWhereInput[]
    id?: BigIntFilter<"FailedJobs"> | bigint | number
    uuid?: StringFilter<"FailedJobs"> | string
    connection?: StringFilter<"FailedJobs"> | string
    queue?: StringFilter<"FailedJobs"> | string
    payload?: StringFilter<"FailedJobs"> | string
    exception?: StringFilter<"FailedJobs"> | string
    failedAt?: DateTimeFilter<"FailedJobs"> | Date | string
  }

  export type FailedJobsOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    connection?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    exception?: SortOrder
    failedAt?: SortOrder
  }

  export type FailedJobsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    uuid?: string
    AND?: FailedJobsWhereInput | FailedJobsWhereInput[]
    OR?: FailedJobsWhereInput[]
    NOT?: FailedJobsWhereInput | FailedJobsWhereInput[]
    connection?: StringFilter<"FailedJobs"> | string
    queue?: StringFilter<"FailedJobs"> | string
    payload?: StringFilter<"FailedJobs"> | string
    exception?: StringFilter<"FailedJobs"> | string
    failedAt?: DateTimeFilter<"FailedJobs"> | Date | string
  }, "id" | "uuid">

  export type FailedJobsOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    connection?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    exception?: SortOrder
    failedAt?: SortOrder
    _count?: FailedJobsCountOrderByAggregateInput
    _avg?: FailedJobsAvgOrderByAggregateInput
    _max?: FailedJobsMaxOrderByAggregateInput
    _min?: FailedJobsMinOrderByAggregateInput
    _sum?: FailedJobsSumOrderByAggregateInput
  }

  export type FailedJobsScalarWhereWithAggregatesInput = {
    AND?: FailedJobsScalarWhereWithAggregatesInput | FailedJobsScalarWhereWithAggregatesInput[]
    OR?: FailedJobsScalarWhereWithAggregatesInput[]
    NOT?: FailedJobsScalarWhereWithAggregatesInput | FailedJobsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"FailedJobs"> | bigint | number
    uuid?: StringWithAggregatesFilter<"FailedJobs"> | string
    connection?: StringWithAggregatesFilter<"FailedJobs"> | string
    queue?: StringWithAggregatesFilter<"FailedJobs"> | string
    payload?: StringWithAggregatesFilter<"FailedJobs"> | string
    exception?: StringWithAggregatesFilter<"FailedJobs"> | string
    failedAt?: DateTimeWithAggregatesFilter<"FailedJobs"> | Date | string
  }

  export type GroupsWhereInput = {
    AND?: GroupsWhereInput | GroupsWhereInput[]
    OR?: GroupsWhereInput[]
    NOT?: GroupsWhereInput | GroupsWhereInput[]
    id?: BigIntFilter<"Groups"> | bigint | number
    code?: StringFilter<"Groups"> | string
    level?: IntFilter<"Groups"> | number
    media?: BigIntNullableFilter<"Groups"> | bigint | number | null
    randCount?: IntFilter<"Groups"> | number
    enabled?: BoolFilter<"Groups"> | boolean
    other?: StringNullableFilter<"Groups"> | string | null
    createdAt?: DateTimeNullableFilter<"Groups"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Groups"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Groups"> | Date | string | null
    Media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    GroupsLang?: GroupsLangListRelationFilter
    Relations?: RelationsListRelationFilter
    UsersGroups?: UsersGroupsListRelationFilter
  }

  export type GroupsOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    level?: SortOrder
    media?: SortOrderInput | SortOrder
    randCount?: SortOrder
    enabled?: SortOrder
    other?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    Media?: MediaOrderByWithRelationInput
    GroupsLang?: GroupsLangOrderByRelationAggregateInput
    Relations?: RelationsOrderByRelationAggregateInput
    UsersGroups?: UsersGroupsOrderByRelationAggregateInput
  }

  export type GroupsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    code_deletedAt?: GroupsCodeDeletedAtCompoundUniqueInput
    AND?: GroupsWhereInput | GroupsWhereInput[]
    OR?: GroupsWhereInput[]
    NOT?: GroupsWhereInput | GroupsWhereInput[]
    code?: StringFilter<"Groups"> | string
    level?: IntFilter<"Groups"> | number
    media?: BigIntNullableFilter<"Groups"> | bigint | number | null
    randCount?: IntFilter<"Groups"> | number
    enabled?: BoolFilter<"Groups"> | boolean
    other?: StringNullableFilter<"Groups"> | string | null
    createdAt?: DateTimeNullableFilter<"Groups"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Groups"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Groups"> | Date | string | null
    Media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    GroupsLang?: GroupsLangListRelationFilter
    Relations?: RelationsListRelationFilter
    UsersGroups?: UsersGroupsListRelationFilter
  }, "id" | "code_deletedAt">

  export type GroupsOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    level?: SortOrder
    media?: SortOrderInput | SortOrder
    randCount?: SortOrder
    enabled?: SortOrder
    other?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: GroupsCountOrderByAggregateInput
    _avg?: GroupsAvgOrderByAggregateInput
    _max?: GroupsMaxOrderByAggregateInput
    _min?: GroupsMinOrderByAggregateInput
    _sum?: GroupsSumOrderByAggregateInput
  }

  export type GroupsScalarWhereWithAggregatesInput = {
    AND?: GroupsScalarWhereWithAggregatesInput | GroupsScalarWhereWithAggregatesInput[]
    OR?: GroupsScalarWhereWithAggregatesInput[]
    NOT?: GroupsScalarWhereWithAggregatesInput | GroupsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Groups"> | bigint | number
    code?: StringWithAggregatesFilter<"Groups"> | string
    level?: IntWithAggregatesFilter<"Groups"> | number
    media?: BigIntNullableWithAggregatesFilter<"Groups"> | bigint | number | null
    randCount?: IntWithAggregatesFilter<"Groups"> | number
    enabled?: BoolWithAggregatesFilter<"Groups"> | boolean
    other?: StringNullableWithAggregatesFilter<"Groups"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Groups"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Groups"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Groups"> | Date | string | null
  }

  export type GroupsLangWhereInput = {
    AND?: GroupsLangWhereInput | GroupsLangWhereInput[]
    OR?: GroupsLangWhereInput[]
    NOT?: GroupsLangWhereInput | GroupsLangWhereInput[]
    id?: BigIntFilter<"GroupsLang"> | bigint | number
    gpId?: BigIntFilter<"GroupsLang"> | bigint | number
    lang?: BigIntFilter<"GroupsLang"> | bigint | number
    name?: StringFilter<"GroupsLang"> | string
    desc?: StringNullableFilter<"GroupsLang"> | string | null
    audio?: BigIntNullableFilter<"GroupsLang"> | bigint | number | null
    createdAt?: DateTimeNullableFilter<"GroupsLang"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"GroupsLang"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"GroupsLang"> | Date | string | null
    Groups?: XOR<GroupsRelationFilter, GroupsWhereInput>
    Languages?: XOR<LanguagesRelationFilter, LanguagesWhereInput>
    Audio?: XOR<AudioNullableRelationFilter, AudioWhereInput> | null
  }

  export type GroupsLangOrderByWithRelationInput = {
    id?: SortOrder
    gpId?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    desc?: SortOrderInput | SortOrder
    audio?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    Groups?: GroupsOrderByWithRelationInput
    Languages?: LanguagesOrderByWithRelationInput
    Audio?: AudioOrderByWithRelationInput
  }

  export type GroupsLangWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    gpId_lang_deletedAt?: GroupsLangGpIdLangDeletedAtCompoundUniqueInput
    AND?: GroupsLangWhereInput | GroupsLangWhereInput[]
    OR?: GroupsLangWhereInput[]
    NOT?: GroupsLangWhereInput | GroupsLangWhereInput[]
    gpId?: BigIntFilter<"GroupsLang"> | bigint | number
    lang?: BigIntFilter<"GroupsLang"> | bigint | number
    name?: StringFilter<"GroupsLang"> | string
    desc?: StringNullableFilter<"GroupsLang"> | string | null
    audio?: BigIntNullableFilter<"GroupsLang"> | bigint | number | null
    createdAt?: DateTimeNullableFilter<"GroupsLang"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"GroupsLang"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"GroupsLang"> | Date | string | null
    Groups?: XOR<GroupsRelationFilter, GroupsWhereInput>
    Languages?: XOR<LanguagesRelationFilter, LanguagesWhereInput>
    Audio?: XOR<AudioNullableRelationFilter, AudioWhereInput> | null
  }, "id" | "gpId_lang_deletedAt">

  export type GroupsLangOrderByWithAggregationInput = {
    id?: SortOrder
    gpId?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    desc?: SortOrderInput | SortOrder
    audio?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: GroupsLangCountOrderByAggregateInput
    _avg?: GroupsLangAvgOrderByAggregateInput
    _max?: GroupsLangMaxOrderByAggregateInput
    _min?: GroupsLangMinOrderByAggregateInput
    _sum?: GroupsLangSumOrderByAggregateInput
  }

  export type GroupsLangScalarWhereWithAggregatesInput = {
    AND?: GroupsLangScalarWhereWithAggregatesInput | GroupsLangScalarWhereWithAggregatesInput[]
    OR?: GroupsLangScalarWhereWithAggregatesInput[]
    NOT?: GroupsLangScalarWhereWithAggregatesInput | GroupsLangScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"GroupsLang"> | bigint | number
    gpId?: BigIntWithAggregatesFilter<"GroupsLang"> | bigint | number
    lang?: BigIntWithAggregatesFilter<"GroupsLang"> | bigint | number
    name?: StringWithAggregatesFilter<"GroupsLang"> | string
    desc?: StringNullableWithAggregatesFilter<"GroupsLang"> | string | null
    audio?: BigIntNullableWithAggregatesFilter<"GroupsLang"> | bigint | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"GroupsLang"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"GroupsLang"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"GroupsLang"> | Date | string | null
  }

  export type LanguagesWhereInput = {
    AND?: LanguagesWhereInput | LanguagesWhereInput[]
    OR?: LanguagesWhereInput[]
    NOT?: LanguagesWhereInput | LanguagesWhereInput[]
    id?: BigIntFilter<"Languages"> | bigint | number
    name?: StringFilter<"Languages"> | string
    code?: StringFilter<"Languages"> | string
    voiceCode?: StringFilter<"Languages"> | string
    voiceType?: StringFilter<"Languages"> | string
    voiceName?: StringFilter<"Languages"> | string
    voiceGender?: StringFilter<"Languages"> | string
    voiceProfile?: StringFilter<"Languages"> | string
    enabled?: BoolFilter<"Languages"> | boolean
    createdAt?: DateTimeNullableFilter<"Languages"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Languages"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Languages"> | Date | string | null
    ChoicesLang?: ChoicesLangListRelationFilter
    GroupsLang?: GroupsLangListRelationFilter
    LicensesLang?: LicensesLangListRelationFilter
    QuestionsLang?: QuestionsLangListRelationFilter
    QuizzesLang?: QuizzesLangListRelationFilter
  }

  export type LanguagesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    voiceCode?: SortOrder
    voiceType?: SortOrder
    voiceName?: SortOrder
    voiceGender?: SortOrder
    voiceProfile?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    ChoicesLang?: ChoicesLangOrderByRelationAggregateInput
    GroupsLang?: GroupsLangOrderByRelationAggregateInput
    LicensesLang?: LicensesLangOrderByRelationAggregateInput
    QuestionsLang?: QuestionsLangOrderByRelationAggregateInput
    QuizzesLang?: QuizzesLangOrderByRelationAggregateInput
  }

  export type LanguagesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    code?: string
    AND?: LanguagesWhereInput | LanguagesWhereInput[]
    OR?: LanguagesWhereInput[]
    NOT?: LanguagesWhereInput | LanguagesWhereInput[]
    name?: StringFilter<"Languages"> | string
    voiceCode?: StringFilter<"Languages"> | string
    voiceType?: StringFilter<"Languages"> | string
    voiceName?: StringFilter<"Languages"> | string
    voiceGender?: StringFilter<"Languages"> | string
    voiceProfile?: StringFilter<"Languages"> | string
    enabled?: BoolFilter<"Languages"> | boolean
    createdAt?: DateTimeNullableFilter<"Languages"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Languages"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Languages"> | Date | string | null
    ChoicesLang?: ChoicesLangListRelationFilter
    GroupsLang?: GroupsLangListRelationFilter
    LicensesLang?: LicensesLangListRelationFilter
    QuestionsLang?: QuestionsLangListRelationFilter
    QuizzesLang?: QuizzesLangListRelationFilter
  }, "id" | "code">

  export type LanguagesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    voiceCode?: SortOrder
    voiceType?: SortOrder
    voiceName?: SortOrder
    voiceGender?: SortOrder
    voiceProfile?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: LanguagesCountOrderByAggregateInput
    _avg?: LanguagesAvgOrderByAggregateInput
    _max?: LanguagesMaxOrderByAggregateInput
    _min?: LanguagesMinOrderByAggregateInput
    _sum?: LanguagesSumOrderByAggregateInput
  }

  export type LanguagesScalarWhereWithAggregatesInput = {
    AND?: LanguagesScalarWhereWithAggregatesInput | LanguagesScalarWhereWithAggregatesInput[]
    OR?: LanguagesScalarWhereWithAggregatesInput[]
    NOT?: LanguagesScalarWhereWithAggregatesInput | LanguagesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Languages"> | bigint | number
    name?: StringWithAggregatesFilter<"Languages"> | string
    code?: StringWithAggregatesFilter<"Languages"> | string
    voiceCode?: StringWithAggregatesFilter<"Languages"> | string
    voiceType?: StringWithAggregatesFilter<"Languages"> | string
    voiceName?: StringWithAggregatesFilter<"Languages"> | string
    voiceGender?: StringWithAggregatesFilter<"Languages"> | string
    voiceProfile?: StringWithAggregatesFilter<"Languages"> | string
    enabled?: BoolWithAggregatesFilter<"Languages"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"Languages"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Languages"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Languages"> | Date | string | null
  }

  export type LicensesWhereInput = {
    AND?: LicensesWhereInput | LicensesWhereInput[]
    OR?: LicensesWhereInput[]
    NOT?: LicensesWhereInput | LicensesWhereInput[]
    id?: BigIntFilter<"Licenses"> | bigint | number
    code?: StringFilter<"Licenses"> | string
    media?: BigIntNullableFilter<"Licenses"> | bigint | number | null
    enabled?: BoolFilter<"Licenses"> | boolean
    other?: StringNullableFilter<"Licenses"> | string | null
    createdAt?: DateTimeNullableFilter<"Licenses"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Licenses"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Licenses"> | Date | string | null
    Media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    LicensesLang?: LicensesLangListRelationFilter
    Relations?: RelationsListRelationFilter
  }

  export type LicensesOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    media?: SortOrderInput | SortOrder
    enabled?: SortOrder
    other?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    Media?: MediaOrderByWithRelationInput
    LicensesLang?: LicensesLangOrderByRelationAggregateInput
    Relations?: RelationsOrderByRelationAggregateInput
  }

  export type LicensesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    code_deletedAt?: LicensesCodeDeletedAtCompoundUniqueInput
    AND?: LicensesWhereInput | LicensesWhereInput[]
    OR?: LicensesWhereInput[]
    NOT?: LicensesWhereInput | LicensesWhereInput[]
    code?: StringFilter<"Licenses"> | string
    media?: BigIntNullableFilter<"Licenses"> | bigint | number | null
    enabled?: BoolFilter<"Licenses"> | boolean
    other?: StringNullableFilter<"Licenses"> | string | null
    createdAt?: DateTimeNullableFilter<"Licenses"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Licenses"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Licenses"> | Date | string | null
    Media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    LicensesLang?: LicensesLangListRelationFilter
    Relations?: RelationsListRelationFilter
  }, "id" | "code_deletedAt">

  export type LicensesOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    media?: SortOrderInput | SortOrder
    enabled?: SortOrder
    other?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: LicensesCountOrderByAggregateInput
    _avg?: LicensesAvgOrderByAggregateInput
    _max?: LicensesMaxOrderByAggregateInput
    _min?: LicensesMinOrderByAggregateInput
    _sum?: LicensesSumOrderByAggregateInput
  }

  export type LicensesScalarWhereWithAggregatesInput = {
    AND?: LicensesScalarWhereWithAggregatesInput | LicensesScalarWhereWithAggregatesInput[]
    OR?: LicensesScalarWhereWithAggregatesInput[]
    NOT?: LicensesScalarWhereWithAggregatesInput | LicensesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Licenses"> | bigint | number
    code?: StringWithAggregatesFilter<"Licenses"> | string
    media?: BigIntNullableWithAggregatesFilter<"Licenses"> | bigint | number | null
    enabled?: BoolWithAggregatesFilter<"Licenses"> | boolean
    other?: StringNullableWithAggregatesFilter<"Licenses"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Licenses"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Licenses"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Licenses"> | Date | string | null
  }

  export type LicensesLangWhereInput = {
    AND?: LicensesLangWhereInput | LicensesLangWhereInput[]
    OR?: LicensesLangWhereInput[]
    NOT?: LicensesLangWhereInput | LicensesLangWhereInput[]
    id?: BigIntFilter<"LicensesLang"> | bigint | number
    liId?: BigIntFilter<"LicensesLang"> | bigint | number
    lang?: BigIntFilter<"LicensesLang"> | bigint | number
    name?: StringFilter<"LicensesLang"> | string
    desc?: StringNullableFilter<"LicensesLang"> | string | null
    audio?: BigIntNullableFilter<"LicensesLang"> | bigint | number | null
    createdAt?: DateTimeNullableFilter<"LicensesLang"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"LicensesLang"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"LicensesLang"> | Date | string | null
    Licenses?: XOR<LicensesRelationFilter, LicensesWhereInput>
    Languages?: XOR<LanguagesRelationFilter, LanguagesWhereInput>
    Audio?: XOR<AudioNullableRelationFilter, AudioWhereInput> | null
  }

  export type LicensesLangOrderByWithRelationInput = {
    id?: SortOrder
    liId?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    desc?: SortOrderInput | SortOrder
    audio?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    Licenses?: LicensesOrderByWithRelationInput
    Languages?: LanguagesOrderByWithRelationInput
    Audio?: AudioOrderByWithRelationInput
  }

  export type LicensesLangWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    liId_lang_deletedAt?: LicensesLangLiIdLangDeletedAtCompoundUniqueInput
    AND?: LicensesLangWhereInput | LicensesLangWhereInput[]
    OR?: LicensesLangWhereInput[]
    NOT?: LicensesLangWhereInput | LicensesLangWhereInput[]
    liId?: BigIntFilter<"LicensesLang"> | bigint | number
    lang?: BigIntFilter<"LicensesLang"> | bigint | number
    name?: StringFilter<"LicensesLang"> | string
    desc?: StringNullableFilter<"LicensesLang"> | string | null
    audio?: BigIntNullableFilter<"LicensesLang"> | bigint | number | null
    createdAt?: DateTimeNullableFilter<"LicensesLang"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"LicensesLang"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"LicensesLang"> | Date | string | null
    Licenses?: XOR<LicensesRelationFilter, LicensesWhereInput>
    Languages?: XOR<LanguagesRelationFilter, LanguagesWhereInput>
    Audio?: XOR<AudioNullableRelationFilter, AudioWhereInput> | null
  }, "id" | "liId_lang_deletedAt">

  export type LicensesLangOrderByWithAggregationInput = {
    id?: SortOrder
    liId?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    desc?: SortOrderInput | SortOrder
    audio?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: LicensesLangCountOrderByAggregateInput
    _avg?: LicensesLangAvgOrderByAggregateInput
    _max?: LicensesLangMaxOrderByAggregateInput
    _min?: LicensesLangMinOrderByAggregateInput
    _sum?: LicensesLangSumOrderByAggregateInput
  }

  export type LicensesLangScalarWhereWithAggregatesInput = {
    AND?: LicensesLangScalarWhereWithAggregatesInput | LicensesLangScalarWhereWithAggregatesInput[]
    OR?: LicensesLangScalarWhereWithAggregatesInput[]
    NOT?: LicensesLangScalarWhereWithAggregatesInput | LicensesLangScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"LicensesLang"> | bigint | number
    liId?: BigIntWithAggregatesFilter<"LicensesLang"> | bigint | number
    lang?: BigIntWithAggregatesFilter<"LicensesLang"> | bigint | number
    name?: StringWithAggregatesFilter<"LicensesLang"> | string
    desc?: StringNullableWithAggregatesFilter<"LicensesLang"> | string | null
    audio?: BigIntNullableWithAggregatesFilter<"LicensesLang"> | bigint | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"LicensesLang"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"LicensesLang"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"LicensesLang"> | Date | string | null
  }

  export type MediaWhereInput = {
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    id?: BigIntFilter<"Media"> | bigint | number
    name?: StringFilter<"Media"> | string
    extension?: StringFilter<"Media"> | string
    url?: StringFilter<"Media"> | string
    uploadedName?: StringFilter<"Media"> | string
    enabled?: BoolFilter<"Media"> | boolean
    createdAt?: DateTimeNullableFilter<"Media"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Media"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Media"> | Date | string | null
    Groups?: GroupsListRelationFilter
    Licenses?: LicensesListRelationFilter
    RelationsChoices?: RelationsChoicesListRelationFilter
    RelationsQuestions?: RelationsQuestionsListRelationFilter
    Quizzes?: QuizzesListRelationFilter
  }

  export type MediaOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    extension?: SortOrder
    url?: SortOrder
    uploadedName?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    Groups?: GroupsOrderByRelationAggregateInput
    Licenses?: LicensesOrderByRelationAggregateInput
    RelationsChoices?: RelationsChoicesOrderByRelationAggregateInput
    RelationsQuestions?: RelationsQuestionsOrderByRelationAggregateInput
    Quizzes?: QuizzesOrderByRelationAggregateInput
  }

  export type MediaWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    name?: StringFilter<"Media"> | string
    extension?: StringFilter<"Media"> | string
    url?: StringFilter<"Media"> | string
    uploadedName?: StringFilter<"Media"> | string
    enabled?: BoolFilter<"Media"> | boolean
    createdAt?: DateTimeNullableFilter<"Media"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Media"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Media"> | Date | string | null
    Groups?: GroupsListRelationFilter
    Licenses?: LicensesListRelationFilter
    RelationsChoices?: RelationsChoicesListRelationFilter
    RelationsQuestions?: RelationsQuestionsListRelationFilter
    Quizzes?: QuizzesListRelationFilter
  }, "id">

  export type MediaOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    extension?: SortOrder
    url?: SortOrder
    uploadedName?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: MediaCountOrderByAggregateInput
    _avg?: MediaAvgOrderByAggregateInput
    _max?: MediaMaxOrderByAggregateInput
    _min?: MediaMinOrderByAggregateInput
    _sum?: MediaSumOrderByAggregateInput
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    OR?: MediaScalarWhereWithAggregatesInput[]
    NOT?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Media"> | bigint | number
    name?: StringWithAggregatesFilter<"Media"> | string
    extension?: StringWithAggregatesFilter<"Media"> | string
    url?: StringWithAggregatesFilter<"Media"> | string
    uploadedName?: StringWithAggregatesFilter<"Media"> | string
    enabled?: BoolWithAggregatesFilter<"Media"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"Media"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Media"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Media"> | Date | string | null
  }

  export type MigrationsWhereInput = {
    AND?: MigrationsWhereInput | MigrationsWhereInput[]
    OR?: MigrationsWhereInput[]
    NOT?: MigrationsWhereInput | MigrationsWhereInput[]
    id?: IntFilter<"Migrations"> | number
    migration?: StringFilter<"Migrations"> | string
    batch?: IntFilter<"Migrations"> | number
  }

  export type MigrationsOrderByWithRelationInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
  }

  export type MigrationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MigrationsWhereInput | MigrationsWhereInput[]
    OR?: MigrationsWhereInput[]
    NOT?: MigrationsWhereInput | MigrationsWhereInput[]
    migration?: StringFilter<"Migrations"> | string
    batch?: IntFilter<"Migrations"> | number
  }, "id">

  export type MigrationsOrderByWithAggregationInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
    _count?: MigrationsCountOrderByAggregateInput
    _avg?: MigrationsAvgOrderByAggregateInput
    _max?: MigrationsMaxOrderByAggregateInput
    _min?: MigrationsMinOrderByAggregateInput
    _sum?: MigrationsSumOrderByAggregateInput
  }

  export type MigrationsScalarWhereWithAggregatesInput = {
    AND?: MigrationsScalarWhereWithAggregatesInput | MigrationsScalarWhereWithAggregatesInput[]
    OR?: MigrationsScalarWhereWithAggregatesInput[]
    NOT?: MigrationsScalarWhereWithAggregatesInput | MigrationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Migrations"> | number
    migration?: StringWithAggregatesFilter<"Migrations"> | string
    batch?: IntWithAggregatesFilter<"Migrations"> | number
  }

  export type PasswordResetsWhereInput = {
    AND?: PasswordResetsWhereInput | PasswordResetsWhereInput[]
    OR?: PasswordResetsWhereInput[]
    NOT?: PasswordResetsWhereInput | PasswordResetsWhereInput[]
    email?: StringFilter<"PasswordResets"> | string
    token?: StringFilter<"PasswordResets"> | string
    createdAt?: DateTimeNullableFilter<"PasswordResets"> | Date | string | null
  }

  export type PasswordResetsOrderByWithRelationInput = {
    email?: SortOrder
    token?: SortOrder
    createdAt?: SortOrderInput | SortOrder
  }

  export type PasswordResetsWhereUniqueInput = Prisma.AtLeast<{
    email?: string
    AND?: PasswordResetsWhereInput | PasswordResetsWhereInput[]
    OR?: PasswordResetsWhereInput[]
    NOT?: PasswordResetsWhereInput | PasswordResetsWhereInput[]
    token?: StringFilter<"PasswordResets"> | string
    createdAt?: DateTimeNullableFilter<"PasswordResets"> | Date | string | null
  }, "email">

  export type PasswordResetsOrderByWithAggregationInput = {
    email?: SortOrder
    token?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    _count?: PasswordResetsCountOrderByAggregateInput
    _max?: PasswordResetsMaxOrderByAggregateInput
    _min?: PasswordResetsMinOrderByAggregateInput
  }

  export type PasswordResetsScalarWhereWithAggregatesInput = {
    AND?: PasswordResetsScalarWhereWithAggregatesInput | PasswordResetsScalarWhereWithAggregatesInput[]
    OR?: PasswordResetsScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetsScalarWhereWithAggregatesInput | PasswordResetsScalarWhereWithAggregatesInput[]
    email?: StringWithAggregatesFilter<"PasswordResets"> | string
    token?: StringWithAggregatesFilter<"PasswordResets"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"PasswordResets"> | Date | string | null
  }

  export type QuestionsWhereInput = {
    AND?: QuestionsWhereInput | QuestionsWhereInput[]
    OR?: QuestionsWhereInput[]
    NOT?: QuestionsWhereInput | QuestionsWhereInput[]
    id?: BigIntFilter<"Questions"> | bigint | number
    enabled?: BoolFilter<"Questions"> | boolean
    createdAt?: DateTimeNullableFilter<"Questions"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Questions"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Questions"> | Date | string | null
    QuestionsLang?: QuestionsLangListRelationFilter
    RelationsQuestions?: RelationsQuestionsListRelationFilter
  }

  export type QuestionsOrderByWithRelationInput = {
    id?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    QuestionsLang?: QuestionsLangOrderByRelationAggregateInput
    RelationsQuestions?: RelationsQuestionsOrderByRelationAggregateInput
  }

  export type QuestionsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: QuestionsWhereInput | QuestionsWhereInput[]
    OR?: QuestionsWhereInput[]
    NOT?: QuestionsWhereInput | QuestionsWhereInput[]
    enabled?: BoolFilter<"Questions"> | boolean
    createdAt?: DateTimeNullableFilter<"Questions"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Questions"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Questions"> | Date | string | null
    QuestionsLang?: QuestionsLangListRelationFilter
    RelationsQuestions?: RelationsQuestionsListRelationFilter
  }, "id">

  export type QuestionsOrderByWithAggregationInput = {
    id?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: QuestionsCountOrderByAggregateInput
    _avg?: QuestionsAvgOrderByAggregateInput
    _max?: QuestionsMaxOrderByAggregateInput
    _min?: QuestionsMinOrderByAggregateInput
    _sum?: QuestionsSumOrderByAggregateInput
  }

  export type QuestionsScalarWhereWithAggregatesInput = {
    AND?: QuestionsScalarWhereWithAggregatesInput | QuestionsScalarWhereWithAggregatesInput[]
    OR?: QuestionsScalarWhereWithAggregatesInput[]
    NOT?: QuestionsScalarWhereWithAggregatesInput | QuestionsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Questions"> | bigint | number
    enabled?: BoolWithAggregatesFilter<"Questions"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"Questions"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Questions"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Questions"> | Date | string | null
  }

  export type QuestionsLangWhereInput = {
    AND?: QuestionsLangWhereInput | QuestionsLangWhereInput[]
    OR?: QuestionsLangWhereInput[]
    NOT?: QuestionsLangWhereInput | QuestionsLangWhereInput[]
    id?: BigIntFilter<"QuestionsLang"> | bigint | number
    qsId?: BigIntFilter<"QuestionsLang"> | bigint | number
    lang?: BigIntFilter<"QuestionsLang"> | bigint | number
    text?: StringFilter<"QuestionsLang"> | string
    hint?: StringNullableFilter<"QuestionsLang"> | string | null
    audio?: BigIntNullableFilter<"QuestionsLang"> | bigint | number | null
    createdAt?: DateTimeNullableFilter<"QuestionsLang"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"QuestionsLang"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"QuestionsLang"> | Date | string | null
    Questions?: XOR<QuestionsRelationFilter, QuestionsWhereInput>
    Languages?: XOR<LanguagesRelationFilter, LanguagesWhereInput>
    Audio?: XOR<AudioNullableRelationFilter, AudioWhereInput> | null
  }

  export type QuestionsLangOrderByWithRelationInput = {
    id?: SortOrder
    qsId?: SortOrder
    lang?: SortOrder
    text?: SortOrder
    hint?: SortOrderInput | SortOrder
    audio?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    Questions?: QuestionsOrderByWithRelationInput
    Languages?: LanguagesOrderByWithRelationInput
    Audio?: AudioOrderByWithRelationInput
  }

  export type QuestionsLangWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    qsId_lang_deletedAt?: QuestionsLangQsIdLangDeletedAtCompoundUniqueInput
    AND?: QuestionsLangWhereInput | QuestionsLangWhereInput[]
    OR?: QuestionsLangWhereInput[]
    NOT?: QuestionsLangWhereInput | QuestionsLangWhereInput[]
    qsId?: BigIntFilter<"QuestionsLang"> | bigint | number
    lang?: BigIntFilter<"QuestionsLang"> | bigint | number
    text?: StringFilter<"QuestionsLang"> | string
    hint?: StringNullableFilter<"QuestionsLang"> | string | null
    audio?: BigIntNullableFilter<"QuestionsLang"> | bigint | number | null
    createdAt?: DateTimeNullableFilter<"QuestionsLang"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"QuestionsLang"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"QuestionsLang"> | Date | string | null
    Questions?: XOR<QuestionsRelationFilter, QuestionsWhereInput>
    Languages?: XOR<LanguagesRelationFilter, LanguagesWhereInput>
    Audio?: XOR<AudioNullableRelationFilter, AudioWhereInput> | null
  }, "id" | "qsId_lang_deletedAt">

  export type QuestionsLangOrderByWithAggregationInput = {
    id?: SortOrder
    qsId?: SortOrder
    lang?: SortOrder
    text?: SortOrder
    hint?: SortOrderInput | SortOrder
    audio?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: QuestionsLangCountOrderByAggregateInput
    _avg?: QuestionsLangAvgOrderByAggregateInput
    _max?: QuestionsLangMaxOrderByAggregateInput
    _min?: QuestionsLangMinOrderByAggregateInput
    _sum?: QuestionsLangSumOrderByAggregateInput
  }

  export type QuestionsLangScalarWhereWithAggregatesInput = {
    AND?: QuestionsLangScalarWhereWithAggregatesInput | QuestionsLangScalarWhereWithAggregatesInput[]
    OR?: QuestionsLangScalarWhereWithAggregatesInput[]
    NOT?: QuestionsLangScalarWhereWithAggregatesInput | QuestionsLangScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"QuestionsLang"> | bigint | number
    qsId?: BigIntWithAggregatesFilter<"QuestionsLang"> | bigint | number
    lang?: BigIntWithAggregatesFilter<"QuestionsLang"> | bigint | number
    text?: StringWithAggregatesFilter<"QuestionsLang"> | string
    hint?: StringNullableWithAggregatesFilter<"QuestionsLang"> | string | null
    audio?: BigIntNullableWithAggregatesFilter<"QuestionsLang"> | bigint | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"QuestionsLang"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"QuestionsLang"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"QuestionsLang"> | Date | string | null
  }

  export type QuizzesWhereInput = {
    AND?: QuizzesWhereInput | QuizzesWhereInput[]
    OR?: QuizzesWhereInput[]
    NOT?: QuizzesWhereInput | QuizzesWhereInput[]
    id?: BigIntFilter<"Quizzes"> | bigint | number
    code?: StringFilter<"Quizzes"> | string
    duration?: IntFilter<"Quizzes"> | number
    level?: IntFilter<"Quizzes"> | number
    media?: BigIntNullableFilter<"Quizzes"> | bigint | number | null
    enabled?: BoolFilter<"Quizzes"> | boolean
    other?: StringNullableFilter<"Quizzes"> | string | null
    createdAt?: DateTimeNullableFilter<"Quizzes"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Quizzes"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Quizzes"> | Date | string | null
    Media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    QuizzesLang?: QuizzesLangListRelationFilter
    Relations?: RelationsListRelationFilter
  }

  export type QuizzesOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    duration?: SortOrder
    level?: SortOrder
    media?: SortOrderInput | SortOrder
    enabled?: SortOrder
    other?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    Media?: MediaOrderByWithRelationInput
    QuizzesLang?: QuizzesLangOrderByRelationAggregateInput
    Relations?: RelationsOrderByRelationAggregateInput
  }

  export type QuizzesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    code_deletedAt?: QuizzesCodeDeletedAtCompoundUniqueInput
    AND?: QuizzesWhereInput | QuizzesWhereInput[]
    OR?: QuizzesWhereInput[]
    NOT?: QuizzesWhereInput | QuizzesWhereInput[]
    code?: StringFilter<"Quizzes"> | string
    duration?: IntFilter<"Quizzes"> | number
    level?: IntFilter<"Quizzes"> | number
    media?: BigIntNullableFilter<"Quizzes"> | bigint | number | null
    enabled?: BoolFilter<"Quizzes"> | boolean
    other?: StringNullableFilter<"Quizzes"> | string | null
    createdAt?: DateTimeNullableFilter<"Quizzes"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Quizzes"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Quizzes"> | Date | string | null
    Media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    QuizzesLang?: QuizzesLangListRelationFilter
    Relations?: RelationsListRelationFilter
  }, "id" | "code_deletedAt">

  export type QuizzesOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    duration?: SortOrder
    level?: SortOrder
    media?: SortOrderInput | SortOrder
    enabled?: SortOrder
    other?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: QuizzesCountOrderByAggregateInput
    _avg?: QuizzesAvgOrderByAggregateInput
    _max?: QuizzesMaxOrderByAggregateInput
    _min?: QuizzesMinOrderByAggregateInput
    _sum?: QuizzesSumOrderByAggregateInput
  }

  export type QuizzesScalarWhereWithAggregatesInput = {
    AND?: QuizzesScalarWhereWithAggregatesInput | QuizzesScalarWhereWithAggregatesInput[]
    OR?: QuizzesScalarWhereWithAggregatesInput[]
    NOT?: QuizzesScalarWhereWithAggregatesInput | QuizzesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Quizzes"> | bigint | number
    code?: StringWithAggregatesFilter<"Quizzes"> | string
    duration?: IntWithAggregatesFilter<"Quizzes"> | number
    level?: IntWithAggregatesFilter<"Quizzes"> | number
    media?: BigIntNullableWithAggregatesFilter<"Quizzes"> | bigint | number | null
    enabled?: BoolWithAggregatesFilter<"Quizzes"> | boolean
    other?: StringNullableWithAggregatesFilter<"Quizzes"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Quizzes"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Quizzes"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Quizzes"> | Date | string | null
  }

  export type QuizzesLangWhereInput = {
    AND?: QuizzesLangWhereInput | QuizzesLangWhereInput[]
    OR?: QuizzesLangWhereInput[]
    NOT?: QuizzesLangWhereInput | QuizzesLangWhereInput[]
    id?: BigIntFilter<"QuizzesLang"> | bigint | number
    qzId?: BigIntFilter<"QuizzesLang"> | bigint | number
    lang?: BigIntFilter<"QuizzesLang"> | bigint | number
    name?: StringFilter<"QuizzesLang"> | string
    desc?: StringNullableFilter<"QuizzesLang"> | string | null
    audio?: BigIntNullableFilter<"QuizzesLang"> | bigint | number | null
    createdAt?: DateTimeNullableFilter<"QuizzesLang"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"QuizzesLang"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"QuizzesLang"> | Date | string | null
    Quizzes?: XOR<QuizzesRelationFilter, QuizzesWhereInput>
    Languages?: XOR<LanguagesRelationFilter, LanguagesWhereInput>
    Audio?: XOR<AudioNullableRelationFilter, AudioWhereInput> | null
  }

  export type QuizzesLangOrderByWithRelationInput = {
    id?: SortOrder
    qzId?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    desc?: SortOrderInput | SortOrder
    audio?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    Quizzes?: QuizzesOrderByWithRelationInput
    Languages?: LanguagesOrderByWithRelationInput
    Audio?: AudioOrderByWithRelationInput
  }

  export type QuizzesLangWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    qzId_lang_deletedAt?: QuizzesLangQzIdLangDeletedAtCompoundUniqueInput
    AND?: QuizzesLangWhereInput | QuizzesLangWhereInput[]
    OR?: QuizzesLangWhereInput[]
    NOT?: QuizzesLangWhereInput | QuizzesLangWhereInput[]
    qzId?: BigIntFilter<"QuizzesLang"> | bigint | number
    lang?: BigIntFilter<"QuizzesLang"> | bigint | number
    name?: StringFilter<"QuizzesLang"> | string
    desc?: StringNullableFilter<"QuizzesLang"> | string | null
    audio?: BigIntNullableFilter<"QuizzesLang"> | bigint | number | null
    createdAt?: DateTimeNullableFilter<"QuizzesLang"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"QuizzesLang"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"QuizzesLang"> | Date | string | null
    Quizzes?: XOR<QuizzesRelationFilter, QuizzesWhereInput>
    Languages?: XOR<LanguagesRelationFilter, LanguagesWhereInput>
    Audio?: XOR<AudioNullableRelationFilter, AudioWhereInput> | null
  }, "id" | "qzId_lang_deletedAt">

  export type QuizzesLangOrderByWithAggregationInput = {
    id?: SortOrder
    qzId?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    desc?: SortOrderInput | SortOrder
    audio?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: QuizzesLangCountOrderByAggregateInput
    _avg?: QuizzesLangAvgOrderByAggregateInput
    _max?: QuizzesLangMaxOrderByAggregateInput
    _min?: QuizzesLangMinOrderByAggregateInput
    _sum?: QuizzesLangSumOrderByAggregateInput
  }

  export type QuizzesLangScalarWhereWithAggregatesInput = {
    AND?: QuizzesLangScalarWhereWithAggregatesInput | QuizzesLangScalarWhereWithAggregatesInput[]
    OR?: QuizzesLangScalarWhereWithAggregatesInput[]
    NOT?: QuizzesLangScalarWhereWithAggregatesInput | QuizzesLangScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"QuizzesLang"> | bigint | number
    qzId?: BigIntWithAggregatesFilter<"QuizzesLang"> | bigint | number
    lang?: BigIntWithAggregatesFilter<"QuizzesLang"> | bigint | number
    name?: StringWithAggregatesFilter<"QuizzesLang"> | string
    desc?: StringNullableWithAggregatesFilter<"QuizzesLang"> | string | null
    audio?: BigIntNullableWithAggregatesFilter<"QuizzesLang"> | bigint | number | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"QuizzesLang"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"QuizzesLang"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"QuizzesLang"> | Date | string | null
  }

  export type RelationsWhereInput = {
    AND?: RelationsWhereInput | RelationsWhereInput[]
    OR?: RelationsWhereInput[]
    NOT?: RelationsWhereInput | RelationsWhereInput[]
    id?: BigIntFilter<"Relations"> | bigint | number
    liId?: BigIntFilter<"Relations"> | bigint | number
    gpId?: BigIntFilter<"Relations"> | bigint | number
    qzId?: BigIntFilter<"Relations"> | bigint | number
    enabled?: BoolFilter<"Relations"> | boolean
    createdAt?: DateTimeNullableFilter<"Relations"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Relations"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Relations"> | Date | string | null
    Licenses?: XOR<LicensesRelationFilter, LicensesWhereInput>
    Groups?: XOR<GroupsRelationFilter, GroupsWhereInput>
    Quizzes?: XOR<QuizzesRelationFilter, QuizzesWhereInput>
    RelationsChoices?: RelationsChoicesListRelationFilter
    RelationsQuestions?: RelationsQuestionsListRelationFilter
    UsersRelations?: UsersRelationsListRelationFilter
  }

  export type RelationsOrderByWithRelationInput = {
    id?: SortOrder
    liId?: SortOrder
    gpId?: SortOrder
    qzId?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    Licenses?: LicensesOrderByWithRelationInput
    Groups?: GroupsOrderByWithRelationInput
    Quizzes?: QuizzesOrderByWithRelationInput
    RelationsChoices?: RelationsChoicesOrderByRelationAggregateInput
    RelationsQuestions?: RelationsQuestionsOrderByRelationAggregateInput
    UsersRelations?: UsersRelationsOrderByRelationAggregateInput
  }

  export type RelationsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    liId_gpId_qzId_deletedAt?: RelationsLiIdGpIdQzIdDeletedAtCompoundUniqueInput
    AND?: RelationsWhereInput | RelationsWhereInput[]
    OR?: RelationsWhereInput[]
    NOT?: RelationsWhereInput | RelationsWhereInput[]
    liId?: BigIntFilter<"Relations"> | bigint | number
    gpId?: BigIntFilter<"Relations"> | bigint | number
    qzId?: BigIntFilter<"Relations"> | bigint | number
    enabled?: BoolFilter<"Relations"> | boolean
    createdAt?: DateTimeNullableFilter<"Relations"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Relations"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Relations"> | Date | string | null
    Licenses?: XOR<LicensesRelationFilter, LicensesWhereInput>
    Groups?: XOR<GroupsRelationFilter, GroupsWhereInput>
    Quizzes?: XOR<QuizzesRelationFilter, QuizzesWhereInput>
    RelationsChoices?: RelationsChoicesListRelationFilter
    RelationsQuestions?: RelationsQuestionsListRelationFilter
    UsersRelations?: UsersRelationsListRelationFilter
  }, "id" | "liId_gpId_qzId_deletedAt">

  export type RelationsOrderByWithAggregationInput = {
    id?: SortOrder
    liId?: SortOrder
    gpId?: SortOrder
    qzId?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: RelationsCountOrderByAggregateInput
    _avg?: RelationsAvgOrderByAggregateInput
    _max?: RelationsMaxOrderByAggregateInput
    _min?: RelationsMinOrderByAggregateInput
    _sum?: RelationsSumOrderByAggregateInput
  }

  export type RelationsScalarWhereWithAggregatesInput = {
    AND?: RelationsScalarWhereWithAggregatesInput | RelationsScalarWhereWithAggregatesInput[]
    OR?: RelationsScalarWhereWithAggregatesInput[]
    NOT?: RelationsScalarWhereWithAggregatesInput | RelationsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Relations"> | bigint | number
    liId?: BigIntWithAggregatesFilter<"Relations"> | bigint | number
    gpId?: BigIntWithAggregatesFilter<"Relations"> | bigint | number
    qzId?: BigIntWithAggregatesFilter<"Relations"> | bigint | number
    enabled?: BoolWithAggregatesFilter<"Relations"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"Relations"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Relations"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Relations"> | Date | string | null
  }

  export type RelationsChoicesWhereInput = {
    AND?: RelationsChoicesWhereInput | RelationsChoicesWhereInput[]
    OR?: RelationsChoicesWhereInput[]
    NOT?: RelationsChoicesWhereInput | RelationsChoicesWhereInput[]
    id?: BigIntFilter<"RelationsChoices"> | bigint | number
    rqId?: BigIntFilter<"RelationsChoices"> | bigint | number
    chId?: BigIntFilter<"RelationsChoices"> | bigint | number
    mdId?: BigIntNullableFilter<"RelationsChoices"> | bigint | number | null
    correct?: BoolFilter<"RelationsChoices"> | boolean
    ordering?: IntFilter<"RelationsChoices"> | number
    createdAt?: DateTimeNullableFilter<"RelationsChoices"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelationsChoices"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"RelationsChoices"> | Date | string | null
    relationsId?: BigIntNullableFilter<"RelationsChoices"> | bigint | number | null
    Choices?: XOR<ChoicesRelationFilter, ChoicesWhereInput>
    Media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    RelationsQuestions?: XOR<RelationsQuestionsRelationFilter, RelationsQuestionsWhereInput>
    Relations?: XOR<RelationsNullableRelationFilter, RelationsWhereInput> | null
    UsersRelationsDetails?: UsersRelationsDetailsListRelationFilter
  }

  export type RelationsChoicesOrderByWithRelationInput = {
    id?: SortOrder
    rqId?: SortOrder
    chId?: SortOrder
    mdId?: SortOrderInput | SortOrder
    correct?: SortOrder
    ordering?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    relationsId?: SortOrderInput | SortOrder
    Choices?: ChoicesOrderByWithRelationInput
    Media?: MediaOrderByWithRelationInput
    RelationsQuestions?: RelationsQuestionsOrderByWithRelationInput
    Relations?: RelationsOrderByWithRelationInput
    UsersRelationsDetails?: UsersRelationsDetailsOrderByRelationAggregateInput
  }

  export type RelationsChoicesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    rqId_chId_mdId_deletedAt?: RelationsChoicesRqIdChIdMdIdDeletedAtCompoundUniqueInput
    AND?: RelationsChoicesWhereInput | RelationsChoicesWhereInput[]
    OR?: RelationsChoicesWhereInput[]
    NOT?: RelationsChoicesWhereInput | RelationsChoicesWhereInput[]
    rqId?: BigIntFilter<"RelationsChoices"> | bigint | number
    chId?: BigIntFilter<"RelationsChoices"> | bigint | number
    mdId?: BigIntNullableFilter<"RelationsChoices"> | bigint | number | null
    correct?: BoolFilter<"RelationsChoices"> | boolean
    ordering?: IntFilter<"RelationsChoices"> | number
    createdAt?: DateTimeNullableFilter<"RelationsChoices"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelationsChoices"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"RelationsChoices"> | Date | string | null
    relationsId?: BigIntNullableFilter<"RelationsChoices"> | bigint | number | null
    Choices?: XOR<ChoicesRelationFilter, ChoicesWhereInput>
    Media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    RelationsQuestions?: XOR<RelationsQuestionsRelationFilter, RelationsQuestionsWhereInput>
    Relations?: XOR<RelationsNullableRelationFilter, RelationsWhereInput> | null
    UsersRelationsDetails?: UsersRelationsDetailsListRelationFilter
  }, "id" | "rqId_chId_mdId_deletedAt">

  export type RelationsChoicesOrderByWithAggregationInput = {
    id?: SortOrder
    rqId?: SortOrder
    chId?: SortOrder
    mdId?: SortOrderInput | SortOrder
    correct?: SortOrder
    ordering?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    relationsId?: SortOrderInput | SortOrder
    _count?: RelationsChoicesCountOrderByAggregateInput
    _avg?: RelationsChoicesAvgOrderByAggregateInput
    _max?: RelationsChoicesMaxOrderByAggregateInput
    _min?: RelationsChoicesMinOrderByAggregateInput
    _sum?: RelationsChoicesSumOrderByAggregateInput
  }

  export type RelationsChoicesScalarWhereWithAggregatesInput = {
    AND?: RelationsChoicesScalarWhereWithAggregatesInput | RelationsChoicesScalarWhereWithAggregatesInput[]
    OR?: RelationsChoicesScalarWhereWithAggregatesInput[]
    NOT?: RelationsChoicesScalarWhereWithAggregatesInput | RelationsChoicesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"RelationsChoices"> | bigint | number
    rqId?: BigIntWithAggregatesFilter<"RelationsChoices"> | bigint | number
    chId?: BigIntWithAggregatesFilter<"RelationsChoices"> | bigint | number
    mdId?: BigIntNullableWithAggregatesFilter<"RelationsChoices"> | bigint | number | null
    correct?: BoolWithAggregatesFilter<"RelationsChoices"> | boolean
    ordering?: IntWithAggregatesFilter<"RelationsChoices"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"RelationsChoices"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"RelationsChoices"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"RelationsChoices"> | Date | string | null
    relationsId?: BigIntNullableWithAggregatesFilter<"RelationsChoices"> | bigint | number | null
  }

  export type RelationsQuestionsWhereInput = {
    AND?: RelationsQuestionsWhereInput | RelationsQuestionsWhereInput[]
    OR?: RelationsQuestionsWhereInput[]
    NOT?: RelationsQuestionsWhereInput | RelationsQuestionsWhereInput[]
    id?: BigIntFilter<"RelationsQuestions"> | bigint | number
    reId?: BigIntFilter<"RelationsQuestions"> | bigint | number
    qsId?: BigIntFilter<"RelationsQuestions"> | bigint | number
    mdId?: BigIntNullableFilter<"RelationsQuestions"> | bigint | number | null
    ordering?: IntFilter<"RelationsQuestions"> | number
    createdAt?: DateTimeNullableFilter<"RelationsQuestions"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelationsQuestions"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"RelationsQuestions"> | Date | string | null
    Questions?: XOR<QuestionsRelationFilter, QuestionsWhereInput>
    Media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    Relations?: XOR<RelationsRelationFilter, RelationsWhereInput>
    RelationsChoices?: RelationsChoicesListRelationFilter
    UsersRelationsDetails?: UsersRelationsDetailsListRelationFilter
  }

  export type RelationsQuestionsOrderByWithRelationInput = {
    id?: SortOrder
    reId?: SortOrder
    qsId?: SortOrder
    mdId?: SortOrderInput | SortOrder
    ordering?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    Questions?: QuestionsOrderByWithRelationInput
    Media?: MediaOrderByWithRelationInput
    Relations?: RelationsOrderByWithRelationInput
    RelationsChoices?: RelationsChoicesOrderByRelationAggregateInput
    UsersRelationsDetails?: UsersRelationsDetailsOrderByRelationAggregateInput
  }

  export type RelationsQuestionsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    reId_qsId_deletedAt?: RelationsQuestionsReIdQsIdDeletedAtCompoundUniqueInput
    AND?: RelationsQuestionsWhereInput | RelationsQuestionsWhereInput[]
    OR?: RelationsQuestionsWhereInput[]
    NOT?: RelationsQuestionsWhereInput | RelationsQuestionsWhereInput[]
    reId?: BigIntFilter<"RelationsQuestions"> | bigint | number
    qsId?: BigIntFilter<"RelationsQuestions"> | bigint | number
    mdId?: BigIntNullableFilter<"RelationsQuestions"> | bigint | number | null
    ordering?: IntFilter<"RelationsQuestions"> | number
    createdAt?: DateTimeNullableFilter<"RelationsQuestions"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelationsQuestions"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"RelationsQuestions"> | Date | string | null
    Questions?: XOR<QuestionsRelationFilter, QuestionsWhereInput>
    Media?: XOR<MediaNullableRelationFilter, MediaWhereInput> | null
    Relations?: XOR<RelationsRelationFilter, RelationsWhereInput>
    RelationsChoices?: RelationsChoicesListRelationFilter
    UsersRelationsDetails?: UsersRelationsDetailsListRelationFilter
  }, "id" | "reId_qsId_deletedAt">

  export type RelationsQuestionsOrderByWithAggregationInput = {
    id?: SortOrder
    reId?: SortOrder
    qsId?: SortOrder
    mdId?: SortOrderInput | SortOrder
    ordering?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: RelationsQuestionsCountOrderByAggregateInput
    _avg?: RelationsQuestionsAvgOrderByAggregateInput
    _max?: RelationsQuestionsMaxOrderByAggregateInput
    _min?: RelationsQuestionsMinOrderByAggregateInput
    _sum?: RelationsQuestionsSumOrderByAggregateInput
  }

  export type RelationsQuestionsScalarWhereWithAggregatesInput = {
    AND?: RelationsQuestionsScalarWhereWithAggregatesInput | RelationsQuestionsScalarWhereWithAggregatesInput[]
    OR?: RelationsQuestionsScalarWhereWithAggregatesInput[]
    NOT?: RelationsQuestionsScalarWhereWithAggregatesInput | RelationsQuestionsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"RelationsQuestions"> | bigint | number
    reId?: BigIntWithAggregatesFilter<"RelationsQuestions"> | bigint | number
    qsId?: BigIntWithAggregatesFilter<"RelationsQuestions"> | bigint | number
    mdId?: BigIntNullableWithAggregatesFilter<"RelationsQuestions"> | bigint | number | null
    ordering?: IntWithAggregatesFilter<"RelationsQuestions"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"RelationsQuestions"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"RelationsQuestions"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"RelationsQuestions"> | Date | string | null
  }

  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    id?: BigIntFilter<"Users"> | bigint | number
    personalNumber?: StringFilter<"Users"> | string
    name?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    phone?: StringNullableFilter<"Users"> | string | null
    location?: BigIntFilter<"Users"> | bigint | number
    admin?: BoolFilter<"Users"> | boolean
    enabled?: BoolFilter<"Users"> | boolean
    activationDate?: DateTimeFilter<"Users"> | Date | string
    rememberToken?: StringNullableFilter<"Users"> | string | null
    emailVerifiedAt?: DateTimeNullableFilter<"Users"> | Date | string | null
    password?: StringNullableFilter<"Users"> | string | null
    twoFactorSecret?: StringNullableFilter<"Users"> | string | null
    twoFactorRecoveryCodes?: StringNullableFilter<"Users"> | string | null
    createdAt?: DateTimeNullableFilter<"Users"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Users"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Users"> | Date | string | null
    Locations?: XOR<LocationsRelationFilter, LocationsWhereInput>
    UsersAuth?: UsersAuthListRelationFilter
    UsersGroups?: UsersGroupsListRelationFilter
    UsersLogin?: UsersLoginListRelationFilter
    UsersRelations?: UsersRelationsListRelationFilter
  }

  export type UsersOrderByWithRelationInput = {
    id?: SortOrder
    personalNumber?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    location?: SortOrder
    admin?: SortOrder
    enabled?: SortOrder
    activationDate?: SortOrder
    rememberToken?: SortOrderInput | SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorRecoveryCodes?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    Locations?: LocationsOrderByWithRelationInput
    UsersAuth?: UsersAuthOrderByRelationAggregateInput
    UsersGroups?: UsersGroupsOrderByRelationAggregateInput
    UsersLogin?: UsersLoginOrderByRelationAggregateInput
    UsersRelations?: UsersRelationsOrderByRelationAggregateInput
  }

  export type UsersWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    personalNumber?: string
    email?: string
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    name?: StringFilter<"Users"> | string
    phone?: StringNullableFilter<"Users"> | string | null
    location?: BigIntFilter<"Users"> | bigint | number
    admin?: BoolFilter<"Users"> | boolean
    enabled?: BoolFilter<"Users"> | boolean
    activationDate?: DateTimeFilter<"Users"> | Date | string
    rememberToken?: StringNullableFilter<"Users"> | string | null
    emailVerifiedAt?: DateTimeNullableFilter<"Users"> | Date | string | null
    password?: StringNullableFilter<"Users"> | string | null
    twoFactorSecret?: StringNullableFilter<"Users"> | string | null
    twoFactorRecoveryCodes?: StringNullableFilter<"Users"> | string | null
    createdAt?: DateTimeNullableFilter<"Users"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Users"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Users"> | Date | string | null
    Locations?: XOR<LocationsRelationFilter, LocationsWhereInput>
    UsersAuth?: UsersAuthListRelationFilter
    UsersGroups?: UsersGroupsListRelationFilter
    UsersLogin?: UsersLoginListRelationFilter
    UsersRelations?: UsersRelationsListRelationFilter
  }, "id" | "personalNumber" | "email">

  export type UsersOrderByWithAggregationInput = {
    id?: SortOrder
    personalNumber?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    location?: SortOrder
    admin?: SortOrder
    enabled?: SortOrder
    activationDate?: SortOrder
    rememberToken?: SortOrderInput | SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    twoFactorRecoveryCodes?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UsersCountOrderByAggregateInput
    _avg?: UsersAvgOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
    _sum?: UsersSumOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    OR?: UsersScalarWhereWithAggregatesInput[]
    NOT?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Users"> | bigint | number
    personalNumber?: StringWithAggregatesFilter<"Users"> | string
    name?: StringWithAggregatesFilter<"Users"> | string
    email?: StringWithAggregatesFilter<"Users"> | string
    phone?: StringNullableWithAggregatesFilter<"Users"> | string | null
    location?: BigIntWithAggregatesFilter<"Users"> | bigint | number
    admin?: BoolWithAggregatesFilter<"Users"> | boolean
    enabled?: BoolWithAggregatesFilter<"Users"> | boolean
    activationDate?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    rememberToken?: StringNullableWithAggregatesFilter<"Users"> | string | null
    emailVerifiedAt?: DateTimeNullableWithAggregatesFilter<"Users"> | Date | string | null
    password?: StringNullableWithAggregatesFilter<"Users"> | string | null
    twoFactorSecret?: StringNullableWithAggregatesFilter<"Users"> | string | null
    twoFactorRecoveryCodes?: StringNullableWithAggregatesFilter<"Users"> | string | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Users"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Users"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Users"> | Date | string | null
  }

  export type UsersAuthWhereInput = {
    AND?: UsersAuthWhereInput | UsersAuthWhereInput[]
    OR?: UsersAuthWhereInput[]
    NOT?: UsersAuthWhereInput | UsersAuthWhereInput[]
    id?: BigIntFilter<"UsersAuth"> | bigint | number
    usId?: BigIntFilter<"UsersAuth"> | bigint | number
    auId?: BigIntFilter<"UsersAuth"> | bigint | number
    createdAt?: DateTimeNullableFilter<"UsersAuth"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"UsersAuth"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"UsersAuth"> | Date | string | null
    Authorizations?: XOR<AuthorizationsRelationFilter, AuthorizationsWhereInput>
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }

  export type UsersAuthOrderByWithRelationInput = {
    id?: SortOrder
    usId?: SortOrder
    auId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    Authorizations?: AuthorizationsOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type UsersAuthWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    usId_auId_deletedAt?: UsersAuthUsIdAuIdDeletedAtCompoundUniqueInput
    AND?: UsersAuthWhereInput | UsersAuthWhereInput[]
    OR?: UsersAuthWhereInput[]
    NOT?: UsersAuthWhereInput | UsersAuthWhereInput[]
    usId?: BigIntFilter<"UsersAuth"> | bigint | number
    auId?: BigIntFilter<"UsersAuth"> | bigint | number
    createdAt?: DateTimeNullableFilter<"UsersAuth"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"UsersAuth"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"UsersAuth"> | Date | string | null
    Authorizations?: XOR<AuthorizationsRelationFilter, AuthorizationsWhereInput>
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }, "id" | "usId_auId_deletedAt">

  export type UsersAuthOrderByWithAggregationInput = {
    id?: SortOrder
    usId?: SortOrder
    auId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UsersAuthCountOrderByAggregateInput
    _avg?: UsersAuthAvgOrderByAggregateInput
    _max?: UsersAuthMaxOrderByAggregateInput
    _min?: UsersAuthMinOrderByAggregateInput
    _sum?: UsersAuthSumOrderByAggregateInput
  }

  export type UsersAuthScalarWhereWithAggregatesInput = {
    AND?: UsersAuthScalarWhereWithAggregatesInput | UsersAuthScalarWhereWithAggregatesInput[]
    OR?: UsersAuthScalarWhereWithAggregatesInput[]
    NOT?: UsersAuthScalarWhereWithAggregatesInput | UsersAuthScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"UsersAuth"> | bigint | number
    usId?: BigIntWithAggregatesFilter<"UsersAuth"> | bigint | number
    auId?: BigIntWithAggregatesFilter<"UsersAuth"> | bigint | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"UsersAuth"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"UsersAuth"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"UsersAuth"> | Date | string | null
  }

  export type UsersGroupsWhereInput = {
    AND?: UsersGroupsWhereInput | UsersGroupsWhereInput[]
    OR?: UsersGroupsWhereInput[]
    NOT?: UsersGroupsWhereInput | UsersGroupsWhereInput[]
    id?: BigIntFilter<"UsersGroups"> | bigint | number
    usId?: BigIntFilter<"UsersGroups"> | bigint | number
    gpId?: BigIntFilter<"UsersGroups"> | bigint | number
    createdAt?: DateTimeNullableFilter<"UsersGroups"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"UsersGroups"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"UsersGroups"> | Date | string | null
    Groups?: XOR<GroupsRelationFilter, GroupsWhereInput>
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }

  export type UsersGroupsOrderByWithRelationInput = {
    id?: SortOrder
    usId?: SortOrder
    gpId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    Groups?: GroupsOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
  }

  export type UsersGroupsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    usId_gpId_deletedAt?: UsersGroupsUsIdGpIdDeletedAtCompoundUniqueInput
    AND?: UsersGroupsWhereInput | UsersGroupsWhereInput[]
    OR?: UsersGroupsWhereInput[]
    NOT?: UsersGroupsWhereInput | UsersGroupsWhereInput[]
    usId?: BigIntFilter<"UsersGroups"> | bigint | number
    gpId?: BigIntFilter<"UsersGroups"> | bigint | number
    createdAt?: DateTimeNullableFilter<"UsersGroups"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"UsersGroups"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"UsersGroups"> | Date | string | null
    Groups?: XOR<GroupsRelationFilter, GroupsWhereInput>
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }, "id" | "usId_gpId_deletedAt">

  export type UsersGroupsOrderByWithAggregationInput = {
    id?: SortOrder
    usId?: SortOrder
    gpId?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UsersGroupsCountOrderByAggregateInput
    _avg?: UsersGroupsAvgOrderByAggregateInput
    _max?: UsersGroupsMaxOrderByAggregateInput
    _min?: UsersGroupsMinOrderByAggregateInput
    _sum?: UsersGroupsSumOrderByAggregateInput
  }

  export type UsersGroupsScalarWhereWithAggregatesInput = {
    AND?: UsersGroupsScalarWhereWithAggregatesInput | UsersGroupsScalarWhereWithAggregatesInput[]
    OR?: UsersGroupsScalarWhereWithAggregatesInput[]
    NOT?: UsersGroupsScalarWhereWithAggregatesInput | UsersGroupsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"UsersGroups"> | bigint | number
    usId?: BigIntWithAggregatesFilter<"UsersGroups"> | bigint | number
    gpId?: BigIntWithAggregatesFilter<"UsersGroups"> | bigint | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"UsersGroups"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"UsersGroups"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"UsersGroups"> | Date | string | null
  }

  export type UsersLoginWhereInput = {
    AND?: UsersLoginWhereInput | UsersLoginWhereInput[]
    OR?: UsersLoginWhereInput[]
    NOT?: UsersLoginWhereInput | UsersLoginWhereInput[]
    id?: BigIntFilter<"UsersLogin"> | bigint | number
    usId?: BigIntFilter<"UsersLogin"> | bigint | number
    action?: BoolFilter<"UsersLogin"> | boolean
    createdAt?: DateTimeNullableFilter<"UsersLogin"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"UsersLogin"> | Date | string | null
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }

  export type UsersLoginOrderByWithRelationInput = {
    id?: SortOrder
    usId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    Users?: UsersOrderByWithRelationInput
  }

  export type UsersLoginWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: UsersLoginWhereInput | UsersLoginWhereInput[]
    OR?: UsersLoginWhereInput[]
    NOT?: UsersLoginWhereInput | UsersLoginWhereInput[]
    usId?: BigIntFilter<"UsersLogin"> | bigint | number
    action?: BoolFilter<"UsersLogin"> | boolean
    createdAt?: DateTimeNullableFilter<"UsersLogin"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"UsersLogin"> | Date | string | null
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
  }, "id">

  export type UsersLoginOrderByWithAggregationInput = {
    id?: SortOrder
    usId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: UsersLoginCountOrderByAggregateInput
    _avg?: UsersLoginAvgOrderByAggregateInput
    _max?: UsersLoginMaxOrderByAggregateInput
    _min?: UsersLoginMinOrderByAggregateInput
    _sum?: UsersLoginSumOrderByAggregateInput
  }

  export type UsersLoginScalarWhereWithAggregatesInput = {
    AND?: UsersLoginScalarWhereWithAggregatesInput | UsersLoginScalarWhereWithAggregatesInput[]
    OR?: UsersLoginScalarWhereWithAggregatesInput[]
    NOT?: UsersLoginScalarWhereWithAggregatesInput | UsersLoginScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"UsersLogin"> | bigint | number
    usId?: BigIntWithAggregatesFilter<"UsersLogin"> | bigint | number
    action?: BoolWithAggregatesFilter<"UsersLogin"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"UsersLogin"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"UsersLogin"> | Date | string | null
  }

  export type UsersRelationsWhereInput = {
    AND?: UsersRelationsWhereInput | UsersRelationsWhereInput[]
    OR?: UsersRelationsWhereInput[]
    NOT?: UsersRelationsWhereInput | UsersRelationsWhereInput[]
    id?: BigIntFilter<"UsersRelations"> | bigint | number
    usId?: BigIntFilter<"UsersRelations"> | bigint | number
    reId?: BigIntFilter<"UsersRelations"> | bigint | number
    correct?: IntFilter<"UsersRelations"> | number
    wrong?: IntFilter<"UsersRelations"> | number
    createdAt?: DateTimeNullableFilter<"UsersRelations"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"UsersRelations"> | Date | string | null
    Relations?: XOR<RelationsRelationFilter, RelationsWhereInput>
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
    UsersRelationsDetails?: UsersRelationsDetailsListRelationFilter
  }

  export type UsersRelationsOrderByWithRelationInput = {
    id?: SortOrder
    usId?: SortOrder
    reId?: SortOrder
    correct?: SortOrder
    wrong?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    Relations?: RelationsOrderByWithRelationInput
    Users?: UsersOrderByWithRelationInput
    UsersRelationsDetails?: UsersRelationsDetailsOrderByRelationAggregateInput
  }

  export type UsersRelationsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: UsersRelationsWhereInput | UsersRelationsWhereInput[]
    OR?: UsersRelationsWhereInput[]
    NOT?: UsersRelationsWhereInput | UsersRelationsWhereInput[]
    usId?: BigIntFilter<"UsersRelations"> | bigint | number
    reId?: BigIntFilter<"UsersRelations"> | bigint | number
    correct?: IntFilter<"UsersRelations"> | number
    wrong?: IntFilter<"UsersRelations"> | number
    createdAt?: DateTimeNullableFilter<"UsersRelations"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"UsersRelations"> | Date | string | null
    Relations?: XOR<RelationsRelationFilter, RelationsWhereInput>
    Users?: XOR<UsersRelationFilter, UsersWhereInput>
    UsersRelationsDetails?: UsersRelationsDetailsListRelationFilter
  }, "id">

  export type UsersRelationsOrderByWithAggregationInput = {
    id?: SortOrder
    usId?: SortOrder
    reId?: SortOrder
    correct?: SortOrder
    wrong?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: UsersRelationsCountOrderByAggregateInput
    _avg?: UsersRelationsAvgOrderByAggregateInput
    _max?: UsersRelationsMaxOrderByAggregateInput
    _min?: UsersRelationsMinOrderByAggregateInput
    _sum?: UsersRelationsSumOrderByAggregateInput
  }

  export type UsersRelationsScalarWhereWithAggregatesInput = {
    AND?: UsersRelationsScalarWhereWithAggregatesInput | UsersRelationsScalarWhereWithAggregatesInput[]
    OR?: UsersRelationsScalarWhereWithAggregatesInput[]
    NOT?: UsersRelationsScalarWhereWithAggregatesInput | UsersRelationsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"UsersRelations"> | bigint | number
    usId?: BigIntWithAggregatesFilter<"UsersRelations"> | bigint | number
    reId?: BigIntWithAggregatesFilter<"UsersRelations"> | bigint | number
    correct?: IntWithAggregatesFilter<"UsersRelations"> | number
    wrong?: IntWithAggregatesFilter<"UsersRelations"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"UsersRelations"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"UsersRelations"> | Date | string | null
  }

  export type UsersRelationsDetailsWhereInput = {
    AND?: UsersRelationsDetailsWhereInput | UsersRelationsDetailsWhereInput[]
    OR?: UsersRelationsDetailsWhereInput[]
    NOT?: UsersRelationsDetailsWhereInput | UsersRelationsDetailsWhereInput[]
    id?: BigIntFilter<"UsersRelationsDetails"> | bigint | number
    urId?: BigIntFilter<"UsersRelationsDetails"> | bigint | number
    rqId?: BigIntFilter<"UsersRelationsDetails"> | bigint | number
    rcId?: BigIntFilter<"UsersRelationsDetails"> | bigint | number
    observed?: BoolFilter<"UsersRelationsDetails"> | boolean
    createdAt?: DateTimeNullableFilter<"UsersRelationsDetails"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"UsersRelationsDetails"> | Date | string | null
    UsersRelations?: XOR<UsersRelationsRelationFilter, UsersRelationsWhereInput>
    RelationsChoices?: XOR<RelationsChoicesRelationFilter, RelationsChoicesWhereInput>
    RelationsQuestions?: XOR<RelationsQuestionsRelationFilter, RelationsQuestionsWhereInput>
  }

  export type UsersRelationsDetailsOrderByWithRelationInput = {
    id?: SortOrder
    urId?: SortOrder
    rqId?: SortOrder
    rcId?: SortOrder
    observed?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    UsersRelations?: UsersRelationsOrderByWithRelationInput
    RelationsChoices?: RelationsChoicesOrderByWithRelationInput
    RelationsQuestions?: RelationsQuestionsOrderByWithRelationInput
  }

  export type UsersRelationsDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: UsersRelationsDetailsWhereInput | UsersRelationsDetailsWhereInput[]
    OR?: UsersRelationsDetailsWhereInput[]
    NOT?: UsersRelationsDetailsWhereInput | UsersRelationsDetailsWhereInput[]
    urId?: BigIntFilter<"UsersRelationsDetails"> | bigint | number
    rqId?: BigIntFilter<"UsersRelationsDetails"> | bigint | number
    rcId?: BigIntFilter<"UsersRelationsDetails"> | bigint | number
    observed?: BoolFilter<"UsersRelationsDetails"> | boolean
    createdAt?: DateTimeNullableFilter<"UsersRelationsDetails"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"UsersRelationsDetails"> | Date | string | null
    UsersRelations?: XOR<UsersRelationsRelationFilter, UsersRelationsWhereInput>
    RelationsChoices?: XOR<RelationsChoicesRelationFilter, RelationsChoicesWhereInput>
    RelationsQuestions?: XOR<RelationsQuestionsRelationFilter, RelationsQuestionsWhereInput>
  }, "id">

  export type UsersRelationsDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    urId?: SortOrder
    rqId?: SortOrder
    rcId?: SortOrder
    observed?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: UsersRelationsDetailsCountOrderByAggregateInput
    _avg?: UsersRelationsDetailsAvgOrderByAggregateInput
    _max?: UsersRelationsDetailsMaxOrderByAggregateInput
    _min?: UsersRelationsDetailsMinOrderByAggregateInput
    _sum?: UsersRelationsDetailsSumOrderByAggregateInput
  }

  export type UsersRelationsDetailsScalarWhereWithAggregatesInput = {
    AND?: UsersRelationsDetailsScalarWhereWithAggregatesInput | UsersRelationsDetailsScalarWhereWithAggregatesInput[]
    OR?: UsersRelationsDetailsScalarWhereWithAggregatesInput[]
    NOT?: UsersRelationsDetailsScalarWhereWithAggregatesInput | UsersRelationsDetailsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"UsersRelationsDetails"> | bigint | number
    urId?: BigIntWithAggregatesFilter<"UsersRelationsDetails"> | bigint | number
    rqId?: BigIntWithAggregatesFilter<"UsersRelationsDetails"> | bigint | number
    rcId?: BigIntWithAggregatesFilter<"UsersRelationsDetails"> | bigint | number
    observed?: BoolWithAggregatesFilter<"UsersRelationsDetails"> | boolean
    createdAt?: DateTimeNullableWithAggregatesFilter<"UsersRelationsDetails"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"UsersRelationsDetails"> | Date | string | null
  }

  export type LocationsWhereInput = {
    AND?: LocationsWhereInput | LocationsWhereInput[]
    OR?: LocationsWhereInput[]
    NOT?: LocationsWhereInput | LocationsWhereInput[]
    id?: BigIntFilter<"Locations"> | bigint | number
    location?: StringFilter<"Locations"> | string
    createdAt?: DateTimeNullableFilter<"Locations"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Locations"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Locations"> | Date | string | null
    Users?: UsersListRelationFilter
  }

  export type LocationsOrderByWithRelationInput = {
    id?: SortOrder
    location?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    Users?: UsersOrderByRelationAggregateInput
  }

  export type LocationsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: LocationsWhereInput | LocationsWhereInput[]
    OR?: LocationsWhereInput[]
    NOT?: LocationsWhereInput | LocationsWhereInput[]
    location?: StringFilter<"Locations"> | string
    createdAt?: DateTimeNullableFilter<"Locations"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Locations"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Locations"> | Date | string | null
    Users?: UsersListRelationFilter
  }, "id">

  export type LocationsOrderByWithAggregationInput = {
    id?: SortOrder
    location?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: LocationsCountOrderByAggregateInput
    _avg?: LocationsAvgOrderByAggregateInput
    _max?: LocationsMaxOrderByAggregateInput
    _min?: LocationsMinOrderByAggregateInput
    _sum?: LocationsSumOrderByAggregateInput
  }

  export type LocationsScalarWhereWithAggregatesInput = {
    AND?: LocationsScalarWhereWithAggregatesInput | LocationsScalarWhereWithAggregatesInput[]
    OR?: LocationsScalarWhereWithAggregatesInput[]
    NOT?: LocationsScalarWhereWithAggregatesInput | LocationsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"Locations"> | bigint | number
    location?: StringWithAggregatesFilter<"Locations"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Locations"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Locations"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Locations"> | Date | string | null
  }

  export type AudioCreateInput = {
    id?: bigint | number
    name: string
    url: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    ChoicesLang?: ChoicesLangCreateNestedManyWithoutAudioInput
    GroupsLang?: GroupsLangCreateNestedManyWithoutAudioInput
    LicensesLang?: LicensesLangCreateNestedManyWithoutAudioInput
    QuizzesLang?: QuizzesLangCreateNestedManyWithoutAudioInput
    QuestionsLang?: QuestionsLangCreateNestedManyWithoutAudioInput
  }

  export type AudioUncheckedCreateInput = {
    id?: bigint | number
    name: string
    url: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    ChoicesLang?: ChoicesLangUncheckedCreateNestedManyWithoutAudioInput
    GroupsLang?: GroupsLangUncheckedCreateNestedManyWithoutAudioInput
    LicensesLang?: LicensesLangUncheckedCreateNestedManyWithoutAudioInput
    QuizzesLang?: QuizzesLangUncheckedCreateNestedManyWithoutAudioInput
    QuestionsLang?: QuestionsLangUncheckedCreateNestedManyWithoutAudioInput
  }

  export type AudioUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ChoicesLang?: ChoicesLangUpdateManyWithoutAudioNestedInput
    GroupsLang?: GroupsLangUpdateManyWithoutAudioNestedInput
    LicensesLang?: LicensesLangUpdateManyWithoutAudioNestedInput
    QuizzesLang?: QuizzesLangUpdateManyWithoutAudioNestedInput
    QuestionsLang?: QuestionsLangUpdateManyWithoutAudioNestedInput
  }

  export type AudioUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ChoicesLang?: ChoicesLangUncheckedUpdateManyWithoutAudioNestedInput
    GroupsLang?: GroupsLangUncheckedUpdateManyWithoutAudioNestedInput
    LicensesLang?: LicensesLangUncheckedUpdateManyWithoutAudioNestedInput
    QuizzesLang?: QuizzesLangUncheckedUpdateManyWithoutAudioNestedInput
    QuestionsLang?: QuestionsLangUncheckedUpdateManyWithoutAudioNestedInput
  }

  export type AudioCreateManyInput = {
    id?: bigint | number
    name: string
    url: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type AudioUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AudioUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuthorizationsCreateInput = {
    id?: bigint | number
    name: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    UsersAuth?: UsersAuthCreateNestedManyWithoutAuthorizationsInput
  }

  export type AuthorizationsUncheckedCreateInput = {
    id?: bigint | number
    name: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    UsersAuth?: UsersAuthUncheckedCreateNestedManyWithoutAuthorizationsInput
  }

  export type AuthorizationsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UsersAuth?: UsersAuthUpdateManyWithoutAuthorizationsNestedInput
  }

  export type AuthorizationsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UsersAuth?: UsersAuthUncheckedUpdateManyWithoutAuthorizationsNestedInput
  }

  export type AuthorizationsCreateManyInput = {
    id?: bigint | number
    name: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AuthorizationsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuthorizationsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChoicesCreateInput = {
    id?: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    ChoicesLang?: ChoicesLangCreateNestedManyWithoutChoicesInput
    RelationsChoices?: RelationsChoicesCreateNestedManyWithoutChoicesInput
  }

  export type ChoicesUncheckedCreateInput = {
    id?: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    ChoicesLang?: ChoicesLangUncheckedCreateNestedManyWithoutChoicesInput
    RelationsChoices?: RelationsChoicesUncheckedCreateNestedManyWithoutChoicesInput
  }

  export type ChoicesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ChoicesLang?: ChoicesLangUpdateManyWithoutChoicesNestedInput
    RelationsChoices?: RelationsChoicesUpdateManyWithoutChoicesNestedInput
  }

  export type ChoicesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ChoicesLang?: ChoicesLangUncheckedUpdateManyWithoutChoicesNestedInput
    RelationsChoices?: RelationsChoicesUncheckedUpdateManyWithoutChoicesNestedInput
  }

  export type ChoicesCreateManyInput = {
    id?: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type ChoicesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChoicesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChoicesLangCreateInput = {
    id?: bigint | number
    text: string
    hint?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Choices: ChoicesCreateNestedOneWithoutChoicesLangInput
    Languages: LanguagesCreateNestedOneWithoutChoicesLangInput
    Audio?: AudioCreateNestedOneWithoutChoicesLangInput
  }

  export type ChoicesLangUncheckedCreateInput = {
    id?: bigint | number
    chId: bigint | number
    lang: bigint | number
    text: string
    hint?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type ChoicesLangUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Choices?: ChoicesUpdateOneRequiredWithoutChoicesLangNestedInput
    Languages?: LanguagesUpdateOneRequiredWithoutChoicesLangNestedInput
    Audio?: AudioUpdateOneWithoutChoicesLangNestedInput
  }

  export type ChoicesLangUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chId?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChoicesLangCreateManyInput = {
    id?: bigint | number
    chId: bigint | number
    lang: bigint | number
    text: string
    hint?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type ChoicesLangUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChoicesLangUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chId?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FailedJobsCreateInput = {
    id?: bigint | number
    uuid: string
    connection: string
    queue: string
    payload: string
    exception: string
    failedAt?: Date | string
  }

  export type FailedJobsUncheckedCreateInput = {
    id?: bigint | number
    uuid: string
    connection: string
    queue: string
    payload: string
    exception: string
    failedAt?: Date | string
  }

  export type FailedJobsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    uuid?: StringFieldUpdateOperationsInput | string
    connection?: StringFieldUpdateOperationsInput | string
    queue?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    exception?: StringFieldUpdateOperationsInput | string
    failedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FailedJobsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    uuid?: StringFieldUpdateOperationsInput | string
    connection?: StringFieldUpdateOperationsInput | string
    queue?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    exception?: StringFieldUpdateOperationsInput | string
    failedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FailedJobsCreateManyInput = {
    id?: bigint | number
    uuid: string
    connection: string
    queue: string
    payload: string
    exception: string
    failedAt?: Date | string
  }

  export type FailedJobsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    uuid?: StringFieldUpdateOperationsInput | string
    connection?: StringFieldUpdateOperationsInput | string
    queue?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    exception?: StringFieldUpdateOperationsInput | string
    failedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FailedJobsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    uuid?: StringFieldUpdateOperationsInput | string
    connection?: StringFieldUpdateOperationsInput | string
    queue?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    exception?: StringFieldUpdateOperationsInput | string
    failedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GroupsCreateInput = {
    id?: bigint | number
    code: string
    level?: number
    randCount?: number
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Media?: MediaCreateNestedOneWithoutGroupsInput
    GroupsLang?: GroupsLangCreateNestedManyWithoutGroupsInput
    Relations?: RelationsCreateNestedManyWithoutGroupsInput
    UsersGroups?: UsersGroupsCreateNestedManyWithoutGroupsInput
  }

  export type GroupsUncheckedCreateInput = {
    id?: bigint | number
    code: string
    level?: number
    media?: bigint | number | null
    randCount?: number
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    GroupsLang?: GroupsLangUncheckedCreateNestedManyWithoutGroupsInput
    Relations?: RelationsUncheckedCreateNestedManyWithoutGroupsInput
    UsersGroups?: UsersGroupsUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    randCount?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Media?: MediaUpdateOneWithoutGroupsNestedInput
    GroupsLang?: GroupsLangUpdateManyWithoutGroupsNestedInput
    Relations?: RelationsUpdateManyWithoutGroupsNestedInput
    UsersGroups?: UsersGroupsUpdateManyWithoutGroupsNestedInput
  }

  export type GroupsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    media?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    randCount?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GroupsLang?: GroupsLangUncheckedUpdateManyWithoutGroupsNestedInput
    Relations?: RelationsUncheckedUpdateManyWithoutGroupsNestedInput
    UsersGroups?: UsersGroupsUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type GroupsCreateManyInput = {
    id?: bigint | number
    code: string
    level?: number
    media?: bigint | number | null
    randCount?: number
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type GroupsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    randCount?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    media?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    randCount?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupsLangCreateInput = {
    id?: bigint | number
    name: string
    desc?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Groups: GroupsCreateNestedOneWithoutGroupsLangInput
    Languages: LanguagesCreateNestedOneWithoutGroupsLangInput
    Audio?: AudioCreateNestedOneWithoutGroupsLangInput
  }

  export type GroupsLangUncheckedCreateInput = {
    id?: bigint | number
    gpId: bigint | number
    lang: bigint | number
    name: string
    desc?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type GroupsLangUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Groups?: GroupsUpdateOneRequiredWithoutGroupsLangNestedInput
    Languages?: LanguagesUpdateOneRequiredWithoutGroupsLangNestedInput
    Audio?: AudioUpdateOneWithoutGroupsLangNestedInput
  }

  export type GroupsLangUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gpId?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupsLangCreateManyInput = {
    id?: bigint | number
    gpId: bigint | number
    lang: bigint | number
    name: string
    desc?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type GroupsLangUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupsLangUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gpId?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LanguagesCreateInput = {
    id?: bigint | number
    name: string
    code: string
    voiceCode: string
    voiceType: string
    voiceName: string
    voiceGender: string
    voiceProfile: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    ChoicesLang?: ChoicesLangCreateNestedManyWithoutLanguagesInput
    GroupsLang?: GroupsLangCreateNestedManyWithoutLanguagesInput
    LicensesLang?: LicensesLangCreateNestedManyWithoutLanguagesInput
    QuestionsLang?: QuestionsLangCreateNestedManyWithoutLanguagesInput
    QuizzesLang?: QuizzesLangCreateNestedManyWithoutLanguagesInput
  }

  export type LanguagesUncheckedCreateInput = {
    id?: bigint | number
    name: string
    code: string
    voiceCode: string
    voiceType: string
    voiceName: string
    voiceGender: string
    voiceProfile: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    ChoicesLang?: ChoicesLangUncheckedCreateNestedManyWithoutLanguagesInput
    GroupsLang?: GroupsLangUncheckedCreateNestedManyWithoutLanguagesInput
    LicensesLang?: LicensesLangUncheckedCreateNestedManyWithoutLanguagesInput
    QuestionsLang?: QuestionsLangUncheckedCreateNestedManyWithoutLanguagesInput
    QuizzesLang?: QuizzesLangUncheckedCreateNestedManyWithoutLanguagesInput
  }

  export type LanguagesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    voiceCode?: StringFieldUpdateOperationsInput | string
    voiceType?: StringFieldUpdateOperationsInput | string
    voiceName?: StringFieldUpdateOperationsInput | string
    voiceGender?: StringFieldUpdateOperationsInput | string
    voiceProfile?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ChoicesLang?: ChoicesLangUpdateManyWithoutLanguagesNestedInput
    GroupsLang?: GroupsLangUpdateManyWithoutLanguagesNestedInput
    LicensesLang?: LicensesLangUpdateManyWithoutLanguagesNestedInput
    QuestionsLang?: QuestionsLangUpdateManyWithoutLanguagesNestedInput
    QuizzesLang?: QuizzesLangUpdateManyWithoutLanguagesNestedInput
  }

  export type LanguagesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    voiceCode?: StringFieldUpdateOperationsInput | string
    voiceType?: StringFieldUpdateOperationsInput | string
    voiceName?: StringFieldUpdateOperationsInput | string
    voiceGender?: StringFieldUpdateOperationsInput | string
    voiceProfile?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ChoicesLang?: ChoicesLangUncheckedUpdateManyWithoutLanguagesNestedInput
    GroupsLang?: GroupsLangUncheckedUpdateManyWithoutLanguagesNestedInput
    LicensesLang?: LicensesLangUncheckedUpdateManyWithoutLanguagesNestedInput
    QuestionsLang?: QuestionsLangUncheckedUpdateManyWithoutLanguagesNestedInput
    QuizzesLang?: QuizzesLangUncheckedUpdateManyWithoutLanguagesNestedInput
  }

  export type LanguagesCreateManyInput = {
    id?: bigint | number
    name: string
    code: string
    voiceCode: string
    voiceType: string
    voiceName: string
    voiceGender: string
    voiceProfile: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type LanguagesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    voiceCode?: StringFieldUpdateOperationsInput | string
    voiceType?: StringFieldUpdateOperationsInput | string
    voiceName?: StringFieldUpdateOperationsInput | string
    voiceGender?: StringFieldUpdateOperationsInput | string
    voiceProfile?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LanguagesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    voiceCode?: StringFieldUpdateOperationsInput | string
    voiceType?: StringFieldUpdateOperationsInput | string
    voiceName?: StringFieldUpdateOperationsInput | string
    voiceGender?: StringFieldUpdateOperationsInput | string
    voiceProfile?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LicensesCreateInput = {
    id?: bigint | number
    code: string
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Media?: MediaCreateNestedOneWithoutLicensesInput
    LicensesLang?: LicensesLangCreateNestedManyWithoutLicensesInput
    Relations?: RelationsCreateNestedManyWithoutLicensesInput
  }

  export type LicensesUncheckedCreateInput = {
    id?: bigint | number
    code: string
    media?: bigint | number | null
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    LicensesLang?: LicensesLangUncheckedCreateNestedManyWithoutLicensesInput
    Relations?: RelationsUncheckedCreateNestedManyWithoutLicensesInput
  }

  export type LicensesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Media?: MediaUpdateOneWithoutLicensesNestedInput
    LicensesLang?: LicensesLangUpdateManyWithoutLicensesNestedInput
    Relations?: RelationsUpdateManyWithoutLicensesNestedInput
  }

  export type LicensesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    media?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LicensesLang?: LicensesLangUncheckedUpdateManyWithoutLicensesNestedInput
    Relations?: RelationsUncheckedUpdateManyWithoutLicensesNestedInput
  }

  export type LicensesCreateManyInput = {
    id?: bigint | number
    code: string
    media?: bigint | number | null
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type LicensesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LicensesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    media?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LicensesLangCreateInput = {
    id?: bigint | number
    name: string
    desc?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Licenses: LicensesCreateNestedOneWithoutLicensesLangInput
    Languages: LanguagesCreateNestedOneWithoutLicensesLangInput
    Audio?: AudioCreateNestedOneWithoutLicensesLangInput
  }

  export type LicensesLangUncheckedCreateInput = {
    id?: bigint | number
    liId: bigint | number
    lang: bigint | number
    name: string
    desc?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type LicensesLangUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Licenses?: LicensesUpdateOneRequiredWithoutLicensesLangNestedInput
    Languages?: LanguagesUpdateOneRequiredWithoutLicensesLangNestedInput
    Audio?: AudioUpdateOneWithoutLicensesLangNestedInput
  }

  export type LicensesLangUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    liId?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LicensesLangCreateManyInput = {
    id?: bigint | number
    liId: bigint | number
    lang: bigint | number
    name: string
    desc?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type LicensesLangUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LicensesLangUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    liId?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MediaCreateInput = {
    id?: bigint | number
    name: string
    extension: string
    url: string
    uploadedName: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Groups?: GroupsCreateNestedManyWithoutMediaInput
    Licenses?: LicensesCreateNestedManyWithoutMediaInput
    RelationsChoices?: RelationsChoicesCreateNestedManyWithoutMediaInput
    RelationsQuestions?: RelationsQuestionsCreateNestedManyWithoutMediaInput
    Quizzes?: QuizzesCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateInput = {
    id?: bigint | number
    name: string
    extension: string
    url: string
    uploadedName: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Groups?: GroupsUncheckedCreateNestedManyWithoutMediaInput
    Licenses?: LicensesUncheckedCreateNestedManyWithoutMediaInput
    RelationsChoices?: RelationsChoicesUncheckedCreateNestedManyWithoutMediaInput
    RelationsQuestions?: RelationsQuestionsUncheckedCreateNestedManyWithoutMediaInput
    Quizzes?: QuizzesUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedName?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Groups?: GroupsUpdateManyWithoutMediaNestedInput
    Licenses?: LicensesUpdateManyWithoutMediaNestedInput
    RelationsChoices?: RelationsChoicesUpdateManyWithoutMediaNestedInput
    RelationsQuestions?: RelationsQuestionsUpdateManyWithoutMediaNestedInput
    Quizzes?: QuizzesUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedName?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Groups?: GroupsUncheckedUpdateManyWithoutMediaNestedInput
    Licenses?: LicensesUncheckedUpdateManyWithoutMediaNestedInput
    RelationsChoices?: RelationsChoicesUncheckedUpdateManyWithoutMediaNestedInput
    RelationsQuestions?: RelationsQuestionsUncheckedUpdateManyWithoutMediaNestedInput
    Quizzes?: QuizzesUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type MediaCreateManyInput = {
    id?: bigint | number
    name: string
    extension: string
    url: string
    uploadedName: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type MediaUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedName?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MediaUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedName?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MigrationsCreateInput = {
    migration: string
    batch: number
  }

  export type MigrationsUncheckedCreateInput = {
    id?: number
    migration: string
    batch: number
  }

  export type MigrationsUpdateInput = {
    migration?: StringFieldUpdateOperationsInput | string
    batch?: IntFieldUpdateOperationsInput | number
  }

  export type MigrationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    migration?: StringFieldUpdateOperationsInput | string
    batch?: IntFieldUpdateOperationsInput | number
  }

  export type MigrationsCreateManyInput = {
    id?: number
    migration: string
    batch: number
  }

  export type MigrationsUpdateManyMutationInput = {
    migration?: StringFieldUpdateOperationsInput | string
    batch?: IntFieldUpdateOperationsInput | number
  }

  export type MigrationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    migration?: StringFieldUpdateOperationsInput | string
    batch?: IntFieldUpdateOperationsInput | number
  }

  export type PasswordResetsCreateInput = {
    email: string
    token: string
    createdAt?: Date | string | null
  }

  export type PasswordResetsUncheckedCreateInput = {
    email: string
    token: string
    createdAt?: Date | string | null
  }

  export type PasswordResetsUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordResetsUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordResetsCreateManyInput = {
    email: string
    token: string
    createdAt?: Date | string | null
  }

  export type PasswordResetsUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PasswordResetsUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuestionsCreateInput = {
    id?: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    QuestionsLang?: QuestionsLangCreateNestedManyWithoutQuestionsInput
    RelationsQuestions?: RelationsQuestionsCreateNestedManyWithoutQuestionsInput
  }

  export type QuestionsUncheckedCreateInput = {
    id?: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    QuestionsLang?: QuestionsLangUncheckedCreateNestedManyWithoutQuestionsInput
    RelationsQuestions?: RelationsQuestionsUncheckedCreateNestedManyWithoutQuestionsInput
  }

  export type QuestionsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    QuestionsLang?: QuestionsLangUpdateManyWithoutQuestionsNestedInput
    RelationsQuestions?: RelationsQuestionsUpdateManyWithoutQuestionsNestedInput
  }

  export type QuestionsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    QuestionsLang?: QuestionsLangUncheckedUpdateManyWithoutQuestionsNestedInput
    RelationsQuestions?: RelationsQuestionsUncheckedUpdateManyWithoutQuestionsNestedInput
  }

  export type QuestionsCreateManyInput = {
    id?: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type QuestionsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuestionsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuestionsLangCreateInput = {
    id?: bigint | number
    text: string
    hint?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Questions: QuestionsCreateNestedOneWithoutQuestionsLangInput
    Languages: LanguagesCreateNestedOneWithoutQuestionsLangInput
    Audio?: AudioCreateNestedOneWithoutQuestionsLangInput
  }

  export type QuestionsLangUncheckedCreateInput = {
    id?: bigint | number
    qsId: bigint | number
    lang: bigint | number
    text: string
    hint?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type QuestionsLangUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Questions?: QuestionsUpdateOneRequiredWithoutQuestionsLangNestedInput
    Languages?: LanguagesUpdateOneRequiredWithoutQuestionsLangNestedInput
    Audio?: AudioUpdateOneWithoutQuestionsLangNestedInput
  }

  export type QuestionsLangUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    qsId?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuestionsLangCreateManyInput = {
    id?: bigint | number
    qsId: bigint | number
    lang: bigint | number
    text: string
    hint?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type QuestionsLangUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuestionsLangUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    qsId?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizzesCreateInput = {
    id?: bigint | number
    code: string
    duration?: number
    level?: number
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Media?: MediaCreateNestedOneWithoutQuizzesInput
    QuizzesLang?: QuizzesLangCreateNestedManyWithoutQuizzesInput
    Relations?: RelationsCreateNestedManyWithoutQuizzesInput
  }

  export type QuizzesUncheckedCreateInput = {
    id?: bigint | number
    code: string
    duration?: number
    level?: number
    media?: bigint | number | null
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    QuizzesLang?: QuizzesLangUncheckedCreateNestedManyWithoutQuizzesInput
    Relations?: RelationsUncheckedCreateNestedManyWithoutQuizzesInput
  }

  export type QuizzesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Media?: MediaUpdateOneWithoutQuizzesNestedInput
    QuizzesLang?: QuizzesLangUpdateManyWithoutQuizzesNestedInput
    Relations?: RelationsUpdateManyWithoutQuizzesNestedInput
  }

  export type QuizzesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    media?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    QuizzesLang?: QuizzesLangUncheckedUpdateManyWithoutQuizzesNestedInput
    Relations?: RelationsUncheckedUpdateManyWithoutQuizzesNestedInput
  }

  export type QuizzesCreateManyInput = {
    id?: bigint | number
    code: string
    duration?: number
    level?: number
    media?: bigint | number | null
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type QuizzesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizzesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    media?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizzesLangCreateInput = {
    id?: bigint | number
    name: string
    desc?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Quizzes: QuizzesCreateNestedOneWithoutQuizzesLangInput
    Languages: LanguagesCreateNestedOneWithoutQuizzesLangInput
    Audio?: AudioCreateNestedOneWithoutQuizzesLangInput
  }

  export type QuizzesLangUncheckedCreateInput = {
    id?: bigint | number
    qzId: bigint | number
    lang: bigint | number
    name: string
    desc?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type QuizzesLangUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Quizzes?: QuizzesUpdateOneRequiredWithoutQuizzesLangNestedInput
    Languages?: LanguagesUpdateOneRequiredWithoutQuizzesLangNestedInput
    Audio?: AudioUpdateOneWithoutQuizzesLangNestedInput
  }

  export type QuizzesLangUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    qzId?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizzesLangCreateManyInput = {
    id?: bigint | number
    qzId: bigint | number
    lang: bigint | number
    name: string
    desc?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type QuizzesLangUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizzesLangUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    qzId?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelationsCreateInput = {
    id?: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Licenses: LicensesCreateNestedOneWithoutRelationsInput
    Groups: GroupsCreateNestedOneWithoutRelationsInput
    Quizzes: QuizzesCreateNestedOneWithoutRelationsInput
    RelationsChoices?: RelationsChoicesCreateNestedManyWithoutRelationsInput
    RelationsQuestions?: RelationsQuestionsCreateNestedManyWithoutRelationsInput
    UsersRelations?: UsersRelationsCreateNestedManyWithoutRelationsInput
  }

  export type RelationsUncheckedCreateInput = {
    id?: bigint | number
    liId: bigint | number
    gpId: bigint | number
    qzId: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    RelationsChoices?: RelationsChoicesUncheckedCreateNestedManyWithoutRelationsInput
    RelationsQuestions?: RelationsQuestionsUncheckedCreateNestedManyWithoutRelationsInput
    UsersRelations?: UsersRelationsUncheckedCreateNestedManyWithoutRelationsInput
  }

  export type RelationsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Licenses?: LicensesUpdateOneRequiredWithoutRelationsNestedInput
    Groups?: GroupsUpdateOneRequiredWithoutRelationsNestedInput
    Quizzes?: QuizzesUpdateOneRequiredWithoutRelationsNestedInput
    RelationsChoices?: RelationsChoicesUpdateManyWithoutRelationsNestedInput
    RelationsQuestions?: RelationsQuestionsUpdateManyWithoutRelationsNestedInput
    UsersRelations?: UsersRelationsUpdateManyWithoutRelationsNestedInput
  }

  export type RelationsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    liId?: BigIntFieldUpdateOperationsInput | bigint | number
    gpId?: BigIntFieldUpdateOperationsInput | bigint | number
    qzId?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RelationsChoices?: RelationsChoicesUncheckedUpdateManyWithoutRelationsNestedInput
    RelationsQuestions?: RelationsQuestionsUncheckedUpdateManyWithoutRelationsNestedInput
    UsersRelations?: UsersRelationsUncheckedUpdateManyWithoutRelationsNestedInput
  }

  export type RelationsCreateManyInput = {
    id?: bigint | number
    liId: bigint | number
    gpId: bigint | number
    qzId: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type RelationsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelationsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    liId?: BigIntFieldUpdateOperationsInput | bigint | number
    gpId?: BigIntFieldUpdateOperationsInput | bigint | number
    qzId?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelationsChoicesCreateInput = {
    id?: bigint | number
    correct?: boolean
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Choices: ChoicesCreateNestedOneWithoutRelationsChoicesInput
    Media?: MediaCreateNestedOneWithoutRelationsChoicesInput
    RelationsQuestions: RelationsQuestionsCreateNestedOneWithoutRelationsChoicesInput
    Relations?: RelationsCreateNestedOneWithoutRelationsChoicesInput
    UsersRelationsDetails?: UsersRelationsDetailsCreateNestedManyWithoutRelationsChoicesInput
  }

  export type RelationsChoicesUncheckedCreateInput = {
    id?: bigint | number
    rqId: bigint | number
    chId: bigint | number
    mdId?: bigint | number | null
    correct?: boolean
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    relationsId?: bigint | number | null
    UsersRelationsDetails?: UsersRelationsDetailsUncheckedCreateNestedManyWithoutRelationsChoicesInput
  }

  export type RelationsChoicesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    correct?: BoolFieldUpdateOperationsInput | boolean
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Choices?: ChoicesUpdateOneRequiredWithoutRelationsChoicesNestedInput
    Media?: MediaUpdateOneWithoutRelationsChoicesNestedInput
    RelationsQuestions?: RelationsQuestionsUpdateOneRequiredWithoutRelationsChoicesNestedInput
    Relations?: RelationsUpdateOneWithoutRelationsChoicesNestedInput
    UsersRelationsDetails?: UsersRelationsDetailsUpdateManyWithoutRelationsChoicesNestedInput
  }

  export type RelationsChoicesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rqId?: BigIntFieldUpdateOperationsInput | bigint | number
    chId?: BigIntFieldUpdateOperationsInput | bigint | number
    mdId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    correct?: BoolFieldUpdateOperationsInput | boolean
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    relationsId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    UsersRelationsDetails?: UsersRelationsDetailsUncheckedUpdateManyWithoutRelationsChoicesNestedInput
  }

  export type RelationsChoicesCreateManyInput = {
    id?: bigint | number
    rqId: bigint | number
    chId: bigint | number
    mdId?: bigint | number | null
    correct?: boolean
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    relationsId?: bigint | number | null
  }

  export type RelationsChoicesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    correct?: BoolFieldUpdateOperationsInput | boolean
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelationsChoicesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rqId?: BigIntFieldUpdateOperationsInput | bigint | number
    chId?: BigIntFieldUpdateOperationsInput | bigint | number
    mdId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    correct?: BoolFieldUpdateOperationsInput | boolean
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    relationsId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type RelationsQuestionsCreateInput = {
    id?: bigint | number
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Questions: QuestionsCreateNestedOneWithoutRelationsQuestionsInput
    Media?: MediaCreateNestedOneWithoutRelationsQuestionsInput
    Relations: RelationsCreateNestedOneWithoutRelationsQuestionsInput
    RelationsChoices?: RelationsChoicesCreateNestedManyWithoutRelationsQuestionsInput
    UsersRelationsDetails?: UsersRelationsDetailsCreateNestedManyWithoutRelationsQuestionsInput
  }

  export type RelationsQuestionsUncheckedCreateInput = {
    id?: bigint | number
    reId: bigint | number
    qsId: bigint | number
    mdId?: bigint | number | null
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    RelationsChoices?: RelationsChoicesUncheckedCreateNestedManyWithoutRelationsQuestionsInput
    UsersRelationsDetails?: UsersRelationsDetailsUncheckedCreateNestedManyWithoutRelationsQuestionsInput
  }

  export type RelationsQuestionsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Questions?: QuestionsUpdateOneRequiredWithoutRelationsQuestionsNestedInput
    Media?: MediaUpdateOneWithoutRelationsQuestionsNestedInput
    Relations?: RelationsUpdateOneRequiredWithoutRelationsQuestionsNestedInput
    RelationsChoices?: RelationsChoicesUpdateManyWithoutRelationsQuestionsNestedInput
    UsersRelationsDetails?: UsersRelationsDetailsUpdateManyWithoutRelationsQuestionsNestedInput
  }

  export type RelationsQuestionsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    reId?: BigIntFieldUpdateOperationsInput | bigint | number
    qsId?: BigIntFieldUpdateOperationsInput | bigint | number
    mdId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RelationsChoices?: RelationsChoicesUncheckedUpdateManyWithoutRelationsQuestionsNestedInput
    UsersRelationsDetails?: UsersRelationsDetailsUncheckedUpdateManyWithoutRelationsQuestionsNestedInput
  }

  export type RelationsQuestionsCreateManyInput = {
    id?: bigint | number
    reId: bigint | number
    qsId: bigint | number
    mdId?: bigint | number | null
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type RelationsQuestionsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelationsQuestionsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    reId?: BigIntFieldUpdateOperationsInput | bigint | number
    qsId?: BigIntFieldUpdateOperationsInput | bigint | number
    mdId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersCreateInput = {
    id?: bigint | number
    personalNumber: string
    name: string
    email: string
    phone?: string | null
    admin?: boolean
    enabled?: boolean
    activationDate?: Date | string
    rememberToken?: string | null
    emailVerifiedAt?: Date | string | null
    password?: string | null
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Locations: LocationsCreateNestedOneWithoutUsersInput
    UsersAuth?: UsersAuthCreateNestedManyWithoutUsersInput
    UsersGroups?: UsersGroupsCreateNestedManyWithoutUsersInput
    UsersLogin?: UsersLoginCreateNestedManyWithoutUsersInput
    UsersRelations?: UsersRelationsCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateInput = {
    id?: bigint | number
    personalNumber: string
    name: string
    email: string
    phone?: string | null
    location: bigint | number
    admin?: boolean
    enabled?: boolean
    activationDate?: Date | string
    rememberToken?: string | null
    emailVerifiedAt?: Date | string | null
    password?: string | null
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    UsersAuth?: UsersAuthUncheckedCreateNestedManyWithoutUsersInput
    UsersGroups?: UsersGroupsUncheckedCreateNestedManyWithoutUsersInput
    UsersLogin?: UsersLoginUncheckedCreateNestedManyWithoutUsersInput
    UsersRelations?: UsersRelationsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    personalNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    activationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Locations?: LocationsUpdateOneRequiredWithoutUsersNestedInput
    UsersAuth?: UsersAuthUpdateManyWithoutUsersNestedInput
    UsersGroups?: UsersGroupsUpdateManyWithoutUsersNestedInput
    UsersLogin?: UsersLoginUpdateManyWithoutUsersNestedInput
    UsersRelations?: UsersRelationsUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    personalNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: BigIntFieldUpdateOperationsInput | bigint | number
    admin?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    activationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UsersAuth?: UsersAuthUncheckedUpdateManyWithoutUsersNestedInput
    UsersGroups?: UsersGroupsUncheckedUpdateManyWithoutUsersNestedInput
    UsersLogin?: UsersLoginUncheckedUpdateManyWithoutUsersNestedInput
    UsersRelations?: UsersRelationsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersCreateManyInput = {
    id?: bigint | number
    personalNumber: string
    name: string
    email: string
    phone?: string | null
    location: bigint | number
    admin?: boolean
    enabled?: boolean
    activationDate?: Date | string
    rememberToken?: string | null
    emailVerifiedAt?: Date | string | null
    password?: string | null
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type UsersUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    personalNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    activationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    personalNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: BigIntFieldUpdateOperationsInput | bigint | number
    admin?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    activationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersAuthCreateInput = {
    id?: bigint | number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Authorizations: AuthorizationsCreateNestedOneWithoutUsersAuthInput
    Users: UsersCreateNestedOneWithoutUsersAuthInput
  }

  export type UsersAuthUncheckedCreateInput = {
    id?: bigint | number
    usId: bigint | number
    auId: bigint | number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type UsersAuthUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Authorizations?: AuthorizationsUpdateOneRequiredWithoutUsersAuthNestedInput
    Users?: UsersUpdateOneRequiredWithoutUsersAuthNestedInput
  }

  export type UsersAuthUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    usId?: BigIntFieldUpdateOperationsInput | bigint | number
    auId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersAuthCreateManyInput = {
    id?: bigint | number
    usId: bigint | number
    auId: bigint | number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type UsersAuthUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersAuthUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    usId?: BigIntFieldUpdateOperationsInput | bigint | number
    auId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersGroupsCreateInput = {
    id?: bigint | number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Groups: GroupsCreateNestedOneWithoutUsersGroupsInput
    Users: UsersCreateNestedOneWithoutUsersGroupsInput
  }

  export type UsersGroupsUncheckedCreateInput = {
    id?: bigint | number
    usId: bigint | number
    gpId: bigint | number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type UsersGroupsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Groups?: GroupsUpdateOneRequiredWithoutUsersGroupsNestedInput
    Users?: UsersUpdateOneRequiredWithoutUsersGroupsNestedInput
  }

  export type UsersGroupsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    usId?: BigIntFieldUpdateOperationsInput | bigint | number
    gpId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersGroupsCreateManyInput = {
    id?: bigint | number
    usId: bigint | number
    gpId: bigint | number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type UsersGroupsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersGroupsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    usId?: BigIntFieldUpdateOperationsInput | bigint | number
    gpId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersLoginCreateInput = {
    id?: bigint | number
    action?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Users: UsersCreateNestedOneWithoutUsersLoginInput
  }

  export type UsersLoginUncheckedCreateInput = {
    id?: bigint | number
    usId: bigint | number
    action?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UsersLoginUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    action?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users?: UsersUpdateOneRequiredWithoutUsersLoginNestedInput
  }

  export type UsersLoginUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    usId?: BigIntFieldUpdateOperationsInput | bigint | number
    action?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersLoginCreateManyInput = {
    id?: bigint | number
    usId: bigint | number
    action?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UsersLoginUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    action?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersLoginUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    usId?: BigIntFieldUpdateOperationsInput | bigint | number
    action?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersRelationsCreateInput = {
    id?: bigint | number
    correct: number
    wrong: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Relations: RelationsCreateNestedOneWithoutUsersRelationsInput
    Users: UsersCreateNestedOneWithoutUsersRelationsInput
    UsersRelationsDetails?: UsersRelationsDetailsCreateNestedManyWithoutUsersRelationsInput
  }

  export type UsersRelationsUncheckedCreateInput = {
    id?: bigint | number
    usId: bigint | number
    reId: bigint | number
    correct: number
    wrong: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    UsersRelationsDetails?: UsersRelationsDetailsUncheckedCreateNestedManyWithoutUsersRelationsInput
  }

  export type UsersRelationsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    correct?: IntFieldUpdateOperationsInput | number
    wrong?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Relations?: RelationsUpdateOneRequiredWithoutUsersRelationsNestedInput
    Users?: UsersUpdateOneRequiredWithoutUsersRelationsNestedInput
    UsersRelationsDetails?: UsersRelationsDetailsUpdateManyWithoutUsersRelationsNestedInput
  }

  export type UsersRelationsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    usId?: BigIntFieldUpdateOperationsInput | bigint | number
    reId?: BigIntFieldUpdateOperationsInput | bigint | number
    correct?: IntFieldUpdateOperationsInput | number
    wrong?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UsersRelationsDetails?: UsersRelationsDetailsUncheckedUpdateManyWithoutUsersRelationsNestedInput
  }

  export type UsersRelationsCreateManyInput = {
    id?: bigint | number
    usId: bigint | number
    reId: bigint | number
    correct: number
    wrong: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UsersRelationsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    correct?: IntFieldUpdateOperationsInput | number
    wrong?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersRelationsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    usId?: BigIntFieldUpdateOperationsInput | bigint | number
    reId?: BigIntFieldUpdateOperationsInput | bigint | number
    correct?: IntFieldUpdateOperationsInput | number
    wrong?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersRelationsDetailsCreateInput = {
    id?: bigint | number
    observed?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    UsersRelations: UsersRelationsCreateNestedOneWithoutUsersRelationsDetailsInput
    RelationsChoices: RelationsChoicesCreateNestedOneWithoutUsersRelationsDetailsInput
    RelationsQuestions: RelationsQuestionsCreateNestedOneWithoutUsersRelationsDetailsInput
  }

  export type UsersRelationsDetailsUncheckedCreateInput = {
    id?: bigint | number
    urId: bigint | number
    rqId: bigint | number
    rcId: bigint | number
    observed?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UsersRelationsDetailsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    observed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UsersRelations?: UsersRelationsUpdateOneRequiredWithoutUsersRelationsDetailsNestedInput
    RelationsChoices?: RelationsChoicesUpdateOneRequiredWithoutUsersRelationsDetailsNestedInput
    RelationsQuestions?: RelationsQuestionsUpdateOneRequiredWithoutUsersRelationsDetailsNestedInput
  }

  export type UsersRelationsDetailsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    urId?: BigIntFieldUpdateOperationsInput | bigint | number
    rqId?: BigIntFieldUpdateOperationsInput | bigint | number
    rcId?: BigIntFieldUpdateOperationsInput | bigint | number
    observed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersRelationsDetailsCreateManyInput = {
    id?: bigint | number
    urId: bigint | number
    rqId: bigint | number
    rcId: bigint | number
    observed?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UsersRelationsDetailsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    observed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersRelationsDetailsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    urId?: BigIntFieldUpdateOperationsInput | bigint | number
    rqId?: BigIntFieldUpdateOperationsInput | bigint | number
    rcId?: BigIntFieldUpdateOperationsInput | bigint | number
    observed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LocationsCreateInput = {
    id?: bigint | number
    location: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Users?: UsersCreateNestedManyWithoutLocationsInput
  }

  export type LocationsUncheckedCreateInput = {
    id?: bigint | number
    location: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Users?: UsersUncheckedCreateNestedManyWithoutLocationsInput
  }

  export type LocationsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users?: UsersUpdateManyWithoutLocationsNestedInput
  }

  export type LocationsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users?: UsersUncheckedUpdateManyWithoutLocationsNestedInput
  }

  export type LocationsCreateManyInput = {
    id?: bigint | number
    location: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type LocationsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LocationsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ChoicesLangListRelationFilter = {
    every?: ChoicesLangWhereInput
    some?: ChoicesLangWhereInput
    none?: ChoicesLangWhereInput
  }

  export type GroupsLangListRelationFilter = {
    every?: GroupsLangWhereInput
    some?: GroupsLangWhereInput
    none?: GroupsLangWhereInput
  }

  export type LicensesLangListRelationFilter = {
    every?: LicensesLangWhereInput
    some?: LicensesLangWhereInput
    none?: LicensesLangWhereInput
  }

  export type QuizzesLangListRelationFilter = {
    every?: QuizzesLangWhereInput
    some?: QuizzesLangWhereInput
    none?: QuizzesLangWhereInput
  }

  export type QuestionsLangListRelationFilter = {
    every?: QuestionsLangWhereInput
    some?: QuestionsLangWhereInput
    none?: QuestionsLangWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ChoicesLangOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupsLangOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LicensesLangOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizzesLangOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionsLangOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AudioCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AudioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AudioMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AudioMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AudioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UsersAuthListRelationFilter = {
    every?: UsersAuthWhereInput
    some?: UsersAuthWhereInput
    none?: UsersAuthWhereInput
  }

  export type UsersAuthOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuthorizationsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthorizationsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AuthorizationsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthorizationsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthorizationsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RelationsChoicesListRelationFilter = {
    every?: RelationsChoicesWhereInput
    some?: RelationsChoicesWhereInput
    none?: RelationsChoicesWhereInput
  }

  export type RelationsChoicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChoicesCountOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChoicesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ChoicesMaxOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChoicesMinOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChoicesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type ChoicesRelationFilter = {
    is?: ChoicesWhereInput
    isNot?: ChoicesWhereInput
  }

  export type LanguagesRelationFilter = {
    is?: LanguagesWhereInput
    isNot?: LanguagesWhereInput
  }

  export type AudioNullableRelationFilter = {
    is?: AudioWhereInput | null
    isNot?: AudioWhereInput | null
  }

  export type ChoicesLangChIdLangDeletedAtCompoundUniqueInput = {
    chId: bigint | number
    lang: bigint | number
    deletedAt: Date | string
  }

  export type ChoicesLangCountOrderByAggregateInput = {
    id?: SortOrder
    chId?: SortOrder
    lang?: SortOrder
    text?: SortOrder
    hint?: SortOrder
    audio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChoicesLangAvgOrderByAggregateInput = {
    id?: SortOrder
    chId?: SortOrder
    lang?: SortOrder
    audio?: SortOrder
  }

  export type ChoicesLangMaxOrderByAggregateInput = {
    id?: SortOrder
    chId?: SortOrder
    lang?: SortOrder
    text?: SortOrder
    hint?: SortOrder
    audio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChoicesLangMinOrderByAggregateInput = {
    id?: SortOrder
    chId?: SortOrder
    lang?: SortOrder
    text?: SortOrder
    hint?: SortOrder
    audio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChoicesLangSumOrderByAggregateInput = {
    id?: SortOrder
    chId?: SortOrder
    lang?: SortOrder
    audio?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type FailedJobsCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    connection?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    exception?: SortOrder
    failedAt?: SortOrder
  }

  export type FailedJobsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FailedJobsMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    connection?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    exception?: SortOrder
    failedAt?: SortOrder
  }

  export type FailedJobsMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    connection?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    exception?: SortOrder
    failedAt?: SortOrder
  }

  export type FailedJobsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type MediaNullableRelationFilter = {
    is?: MediaWhereInput | null
    isNot?: MediaWhereInput | null
  }

  export type RelationsListRelationFilter = {
    every?: RelationsWhereInput
    some?: RelationsWhereInput
    none?: RelationsWhereInput
  }

  export type UsersGroupsListRelationFilter = {
    every?: UsersGroupsWhereInput
    some?: UsersGroupsWhereInput
    none?: UsersGroupsWhereInput
  }

  export type RelationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersGroupsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GroupsCodeDeletedAtCompoundUniqueInput = {
    code: string
    deletedAt: Date | string
  }

  export type GroupsCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    level?: SortOrder
    media?: SortOrder
    randCount?: SortOrder
    enabled?: SortOrder
    other?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type GroupsAvgOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    media?: SortOrder
    randCount?: SortOrder
  }

  export type GroupsMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    level?: SortOrder
    media?: SortOrder
    randCount?: SortOrder
    enabled?: SortOrder
    other?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type GroupsMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    level?: SortOrder
    media?: SortOrder
    randCount?: SortOrder
    enabled?: SortOrder
    other?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type GroupsSumOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    media?: SortOrder
    randCount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type GroupsRelationFilter = {
    is?: GroupsWhereInput
    isNot?: GroupsWhereInput
  }

  export type GroupsLangGpIdLangDeletedAtCompoundUniqueInput = {
    gpId: bigint | number
    lang: bigint | number
    deletedAt: Date | string
  }

  export type GroupsLangCountOrderByAggregateInput = {
    id?: SortOrder
    gpId?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    desc?: SortOrder
    audio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type GroupsLangAvgOrderByAggregateInput = {
    id?: SortOrder
    gpId?: SortOrder
    lang?: SortOrder
    audio?: SortOrder
  }

  export type GroupsLangMaxOrderByAggregateInput = {
    id?: SortOrder
    gpId?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    desc?: SortOrder
    audio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type GroupsLangMinOrderByAggregateInput = {
    id?: SortOrder
    gpId?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    desc?: SortOrder
    audio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type GroupsLangSumOrderByAggregateInput = {
    id?: SortOrder
    gpId?: SortOrder
    lang?: SortOrder
    audio?: SortOrder
  }

  export type LanguagesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    voiceCode?: SortOrder
    voiceType?: SortOrder
    voiceName?: SortOrder
    voiceGender?: SortOrder
    voiceProfile?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LanguagesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LanguagesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    voiceCode?: SortOrder
    voiceType?: SortOrder
    voiceName?: SortOrder
    voiceGender?: SortOrder
    voiceProfile?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LanguagesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    voiceCode?: SortOrder
    voiceType?: SortOrder
    voiceName?: SortOrder
    voiceGender?: SortOrder
    voiceProfile?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LanguagesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LicensesCodeDeletedAtCompoundUniqueInput = {
    code: string
    deletedAt: Date | string
  }

  export type LicensesCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    media?: SortOrder
    enabled?: SortOrder
    other?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LicensesAvgOrderByAggregateInput = {
    id?: SortOrder
    media?: SortOrder
  }

  export type LicensesMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    media?: SortOrder
    enabled?: SortOrder
    other?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LicensesMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    media?: SortOrder
    enabled?: SortOrder
    other?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LicensesSumOrderByAggregateInput = {
    id?: SortOrder
    media?: SortOrder
  }

  export type LicensesRelationFilter = {
    is?: LicensesWhereInput
    isNot?: LicensesWhereInput
  }

  export type LicensesLangLiIdLangDeletedAtCompoundUniqueInput = {
    liId: bigint | number
    lang: bigint | number
    deletedAt: Date | string
  }

  export type LicensesLangCountOrderByAggregateInput = {
    id?: SortOrder
    liId?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    desc?: SortOrder
    audio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LicensesLangAvgOrderByAggregateInput = {
    id?: SortOrder
    liId?: SortOrder
    lang?: SortOrder
    audio?: SortOrder
  }

  export type LicensesLangMaxOrderByAggregateInput = {
    id?: SortOrder
    liId?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    desc?: SortOrder
    audio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LicensesLangMinOrderByAggregateInput = {
    id?: SortOrder
    liId?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    desc?: SortOrder
    audio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LicensesLangSumOrderByAggregateInput = {
    id?: SortOrder
    liId?: SortOrder
    lang?: SortOrder
    audio?: SortOrder
  }

  export type GroupsListRelationFilter = {
    every?: GroupsWhereInput
    some?: GroupsWhereInput
    none?: GroupsWhereInput
  }

  export type LicensesListRelationFilter = {
    every?: LicensesWhereInput
    some?: LicensesWhereInput
    none?: LicensesWhereInput
  }

  export type RelationsQuestionsListRelationFilter = {
    every?: RelationsQuestionsWhereInput
    some?: RelationsQuestionsWhereInput
    none?: RelationsQuestionsWhereInput
  }

  export type QuizzesListRelationFilter = {
    every?: QuizzesWhereInput
    some?: QuizzesWhereInput
    none?: QuizzesWhereInput
  }

  export type GroupsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LicensesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RelationsQuestionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizzesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    extension?: SortOrder
    url?: SortOrder
    uploadedName?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type MediaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MediaMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    extension?: SortOrder
    url?: SortOrder
    uploadedName?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type MediaMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    extension?: SortOrder
    url?: SortOrder
    uploadedName?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type MediaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MigrationsCountOrderByAggregateInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
  }

  export type MigrationsAvgOrderByAggregateInput = {
    id?: SortOrder
    batch?: SortOrder
  }

  export type MigrationsMaxOrderByAggregateInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
  }

  export type MigrationsMinOrderByAggregateInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
  }

  export type MigrationsSumOrderByAggregateInput = {
    id?: SortOrder
    batch?: SortOrder
  }

  export type PasswordResetsCountOrderByAggregateInput = {
    email?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetsMaxOrderByAggregateInput = {
    email?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetsMinOrderByAggregateInput = {
    email?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
  }

  export type QuestionsCountOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuestionsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type QuestionsMaxOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuestionsMinOrderByAggregateInput = {
    id?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuestionsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type QuestionsRelationFilter = {
    is?: QuestionsWhereInput
    isNot?: QuestionsWhereInput
  }

  export type QuestionsLangQsIdLangDeletedAtCompoundUniqueInput = {
    qsId: bigint | number
    lang: bigint | number
    deletedAt: Date | string
  }

  export type QuestionsLangCountOrderByAggregateInput = {
    id?: SortOrder
    qsId?: SortOrder
    lang?: SortOrder
    text?: SortOrder
    hint?: SortOrder
    audio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuestionsLangAvgOrderByAggregateInput = {
    id?: SortOrder
    qsId?: SortOrder
    lang?: SortOrder
    audio?: SortOrder
  }

  export type QuestionsLangMaxOrderByAggregateInput = {
    id?: SortOrder
    qsId?: SortOrder
    lang?: SortOrder
    text?: SortOrder
    hint?: SortOrder
    audio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuestionsLangMinOrderByAggregateInput = {
    id?: SortOrder
    qsId?: SortOrder
    lang?: SortOrder
    text?: SortOrder
    hint?: SortOrder
    audio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuestionsLangSumOrderByAggregateInput = {
    id?: SortOrder
    qsId?: SortOrder
    lang?: SortOrder
    audio?: SortOrder
  }

  export type QuizzesCodeDeletedAtCompoundUniqueInput = {
    code: string
    deletedAt: Date | string
  }

  export type QuizzesCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    duration?: SortOrder
    level?: SortOrder
    media?: SortOrder
    enabled?: SortOrder
    other?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuizzesAvgOrderByAggregateInput = {
    id?: SortOrder
    duration?: SortOrder
    level?: SortOrder
    media?: SortOrder
  }

  export type QuizzesMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    duration?: SortOrder
    level?: SortOrder
    media?: SortOrder
    enabled?: SortOrder
    other?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuizzesMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    duration?: SortOrder
    level?: SortOrder
    media?: SortOrder
    enabled?: SortOrder
    other?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuizzesSumOrderByAggregateInput = {
    id?: SortOrder
    duration?: SortOrder
    level?: SortOrder
    media?: SortOrder
  }

  export type QuizzesRelationFilter = {
    is?: QuizzesWhereInput
    isNot?: QuizzesWhereInput
  }

  export type QuizzesLangQzIdLangDeletedAtCompoundUniqueInput = {
    qzId: bigint | number
    lang: bigint | number
    deletedAt: Date | string
  }

  export type QuizzesLangCountOrderByAggregateInput = {
    id?: SortOrder
    qzId?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    desc?: SortOrder
    audio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuizzesLangAvgOrderByAggregateInput = {
    id?: SortOrder
    qzId?: SortOrder
    lang?: SortOrder
    audio?: SortOrder
  }

  export type QuizzesLangMaxOrderByAggregateInput = {
    id?: SortOrder
    qzId?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    desc?: SortOrder
    audio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuizzesLangMinOrderByAggregateInput = {
    id?: SortOrder
    qzId?: SortOrder
    lang?: SortOrder
    name?: SortOrder
    desc?: SortOrder
    audio?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuizzesLangSumOrderByAggregateInput = {
    id?: SortOrder
    qzId?: SortOrder
    lang?: SortOrder
    audio?: SortOrder
  }

  export type UsersRelationsListRelationFilter = {
    every?: UsersRelationsWhereInput
    some?: UsersRelationsWhereInput
    none?: UsersRelationsWhereInput
  }

  export type UsersRelationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RelationsLiIdGpIdQzIdDeletedAtCompoundUniqueInput = {
    liId: bigint | number
    gpId: bigint | number
    qzId: bigint | number
    deletedAt: Date | string
  }

  export type RelationsCountOrderByAggregateInput = {
    id?: SortOrder
    liId?: SortOrder
    gpId?: SortOrder
    qzId?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RelationsAvgOrderByAggregateInput = {
    id?: SortOrder
    liId?: SortOrder
    gpId?: SortOrder
    qzId?: SortOrder
  }

  export type RelationsMaxOrderByAggregateInput = {
    id?: SortOrder
    liId?: SortOrder
    gpId?: SortOrder
    qzId?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RelationsMinOrderByAggregateInput = {
    id?: SortOrder
    liId?: SortOrder
    gpId?: SortOrder
    qzId?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RelationsSumOrderByAggregateInput = {
    id?: SortOrder
    liId?: SortOrder
    gpId?: SortOrder
    qzId?: SortOrder
  }

  export type RelationsQuestionsRelationFilter = {
    is?: RelationsQuestionsWhereInput
    isNot?: RelationsQuestionsWhereInput
  }

  export type RelationsNullableRelationFilter = {
    is?: RelationsWhereInput | null
    isNot?: RelationsWhereInput | null
  }

  export type UsersRelationsDetailsListRelationFilter = {
    every?: UsersRelationsDetailsWhereInput
    some?: UsersRelationsDetailsWhereInput
    none?: UsersRelationsDetailsWhereInput
  }

  export type UsersRelationsDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RelationsChoicesRqIdChIdMdIdDeletedAtCompoundUniqueInput = {
    rqId: bigint | number
    chId: bigint | number
    mdId: bigint | number
    deletedAt: Date | string
  }

  export type RelationsChoicesCountOrderByAggregateInput = {
    id?: SortOrder
    rqId?: SortOrder
    chId?: SortOrder
    mdId?: SortOrder
    correct?: SortOrder
    ordering?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    relationsId?: SortOrder
  }

  export type RelationsChoicesAvgOrderByAggregateInput = {
    id?: SortOrder
    rqId?: SortOrder
    chId?: SortOrder
    mdId?: SortOrder
    ordering?: SortOrder
    relationsId?: SortOrder
  }

  export type RelationsChoicesMaxOrderByAggregateInput = {
    id?: SortOrder
    rqId?: SortOrder
    chId?: SortOrder
    mdId?: SortOrder
    correct?: SortOrder
    ordering?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    relationsId?: SortOrder
  }

  export type RelationsChoicesMinOrderByAggregateInput = {
    id?: SortOrder
    rqId?: SortOrder
    chId?: SortOrder
    mdId?: SortOrder
    correct?: SortOrder
    ordering?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    relationsId?: SortOrder
  }

  export type RelationsChoicesSumOrderByAggregateInput = {
    id?: SortOrder
    rqId?: SortOrder
    chId?: SortOrder
    mdId?: SortOrder
    ordering?: SortOrder
    relationsId?: SortOrder
  }

  export type RelationsRelationFilter = {
    is?: RelationsWhereInput
    isNot?: RelationsWhereInput
  }

  export type RelationsQuestionsReIdQsIdDeletedAtCompoundUniqueInput = {
    reId: bigint | number
    qsId: bigint | number
    deletedAt: Date | string
  }

  export type RelationsQuestionsCountOrderByAggregateInput = {
    id?: SortOrder
    reId?: SortOrder
    qsId?: SortOrder
    mdId?: SortOrder
    ordering?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RelationsQuestionsAvgOrderByAggregateInput = {
    id?: SortOrder
    reId?: SortOrder
    qsId?: SortOrder
    mdId?: SortOrder
    ordering?: SortOrder
  }

  export type RelationsQuestionsMaxOrderByAggregateInput = {
    id?: SortOrder
    reId?: SortOrder
    qsId?: SortOrder
    mdId?: SortOrder
    ordering?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RelationsQuestionsMinOrderByAggregateInput = {
    id?: SortOrder
    reId?: SortOrder
    qsId?: SortOrder
    mdId?: SortOrder
    ordering?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RelationsQuestionsSumOrderByAggregateInput = {
    id?: SortOrder
    reId?: SortOrder
    qsId?: SortOrder
    mdId?: SortOrder
    ordering?: SortOrder
  }

  export type LocationsRelationFilter = {
    is?: LocationsWhereInput
    isNot?: LocationsWhereInput
  }

  export type UsersLoginListRelationFilter = {
    every?: UsersLoginWhereInput
    some?: UsersLoginWhereInput
    none?: UsersLoginWhereInput
  }

  export type UsersLoginOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersCountOrderByAggregateInput = {
    id?: SortOrder
    personalNumber?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    location?: SortOrder
    admin?: SortOrder
    enabled?: SortOrder
    activationDate?: SortOrder
    rememberToken?: SortOrder
    emailVerifiedAt?: SortOrder
    password?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorRecoveryCodes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UsersAvgOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    id?: SortOrder
    personalNumber?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    location?: SortOrder
    admin?: SortOrder
    enabled?: SortOrder
    activationDate?: SortOrder
    rememberToken?: SortOrder
    emailVerifiedAt?: SortOrder
    password?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorRecoveryCodes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    id?: SortOrder
    personalNumber?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    location?: SortOrder
    admin?: SortOrder
    enabled?: SortOrder
    activationDate?: SortOrder
    rememberToken?: SortOrder
    emailVerifiedAt?: SortOrder
    password?: SortOrder
    twoFactorSecret?: SortOrder
    twoFactorRecoveryCodes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UsersSumOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
  }

  export type AuthorizationsRelationFilter = {
    is?: AuthorizationsWhereInput
    isNot?: AuthorizationsWhereInput
  }

  export type UsersRelationFilter = {
    is?: UsersWhereInput
    isNot?: UsersWhereInput
  }

  export type UsersAuthUsIdAuIdDeletedAtCompoundUniqueInput = {
    usId: bigint | number
    auId: bigint | number
    deletedAt: Date | string
  }

  export type UsersAuthCountOrderByAggregateInput = {
    id?: SortOrder
    usId?: SortOrder
    auId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UsersAuthAvgOrderByAggregateInput = {
    id?: SortOrder
    usId?: SortOrder
    auId?: SortOrder
  }

  export type UsersAuthMaxOrderByAggregateInput = {
    id?: SortOrder
    usId?: SortOrder
    auId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UsersAuthMinOrderByAggregateInput = {
    id?: SortOrder
    usId?: SortOrder
    auId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UsersAuthSumOrderByAggregateInput = {
    id?: SortOrder
    usId?: SortOrder
    auId?: SortOrder
  }

  export type UsersGroupsUsIdGpIdDeletedAtCompoundUniqueInput = {
    usId: bigint | number
    gpId: bigint | number
    deletedAt: Date | string
  }

  export type UsersGroupsCountOrderByAggregateInput = {
    id?: SortOrder
    usId?: SortOrder
    gpId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UsersGroupsAvgOrderByAggregateInput = {
    id?: SortOrder
    usId?: SortOrder
    gpId?: SortOrder
  }

  export type UsersGroupsMaxOrderByAggregateInput = {
    id?: SortOrder
    usId?: SortOrder
    gpId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UsersGroupsMinOrderByAggregateInput = {
    id?: SortOrder
    usId?: SortOrder
    gpId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UsersGroupsSumOrderByAggregateInput = {
    id?: SortOrder
    usId?: SortOrder
    gpId?: SortOrder
  }

  export type UsersLoginCountOrderByAggregateInput = {
    id?: SortOrder
    usId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersLoginAvgOrderByAggregateInput = {
    id?: SortOrder
    usId?: SortOrder
  }

  export type UsersLoginMaxOrderByAggregateInput = {
    id?: SortOrder
    usId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersLoginMinOrderByAggregateInput = {
    id?: SortOrder
    usId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersLoginSumOrderByAggregateInput = {
    id?: SortOrder
    usId?: SortOrder
  }

  export type UsersRelationsCountOrderByAggregateInput = {
    id?: SortOrder
    usId?: SortOrder
    reId?: SortOrder
    correct?: SortOrder
    wrong?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersRelationsAvgOrderByAggregateInput = {
    id?: SortOrder
    usId?: SortOrder
    reId?: SortOrder
    correct?: SortOrder
    wrong?: SortOrder
  }

  export type UsersRelationsMaxOrderByAggregateInput = {
    id?: SortOrder
    usId?: SortOrder
    reId?: SortOrder
    correct?: SortOrder
    wrong?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersRelationsMinOrderByAggregateInput = {
    id?: SortOrder
    usId?: SortOrder
    reId?: SortOrder
    correct?: SortOrder
    wrong?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersRelationsSumOrderByAggregateInput = {
    id?: SortOrder
    usId?: SortOrder
    reId?: SortOrder
    correct?: SortOrder
    wrong?: SortOrder
  }

  export type UsersRelationsRelationFilter = {
    is?: UsersRelationsWhereInput
    isNot?: UsersRelationsWhereInput
  }

  export type RelationsChoicesRelationFilter = {
    is?: RelationsChoicesWhereInput
    isNot?: RelationsChoicesWhereInput
  }

  export type UsersRelationsDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    urId?: SortOrder
    rqId?: SortOrder
    rcId?: SortOrder
    observed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersRelationsDetailsAvgOrderByAggregateInput = {
    id?: SortOrder
    urId?: SortOrder
    rqId?: SortOrder
    rcId?: SortOrder
  }

  export type UsersRelationsDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    urId?: SortOrder
    rqId?: SortOrder
    rcId?: SortOrder
    observed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersRelationsDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    urId?: SortOrder
    rqId?: SortOrder
    rcId?: SortOrder
    observed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersRelationsDetailsSumOrderByAggregateInput = {
    id?: SortOrder
    urId?: SortOrder
    rqId?: SortOrder
    rcId?: SortOrder
  }

  export type UsersListRelationFilter = {
    every?: UsersWhereInput
    some?: UsersWhereInput
    none?: UsersWhereInput
  }

  export type UsersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationsCountOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LocationsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LocationsMaxOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LocationsMinOrderByAggregateInput = {
    id?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LocationsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ChoicesLangCreateNestedManyWithoutAudioInput = {
    create?: XOR<ChoicesLangCreateWithoutAudioInput, ChoicesLangUncheckedCreateWithoutAudioInput> | ChoicesLangCreateWithoutAudioInput[] | ChoicesLangUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: ChoicesLangCreateOrConnectWithoutAudioInput | ChoicesLangCreateOrConnectWithoutAudioInput[]
    createMany?: ChoicesLangCreateManyAudioInputEnvelope
    connect?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
  }

  export type GroupsLangCreateNestedManyWithoutAudioInput = {
    create?: XOR<GroupsLangCreateWithoutAudioInput, GroupsLangUncheckedCreateWithoutAudioInput> | GroupsLangCreateWithoutAudioInput[] | GroupsLangUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: GroupsLangCreateOrConnectWithoutAudioInput | GroupsLangCreateOrConnectWithoutAudioInput[]
    createMany?: GroupsLangCreateManyAudioInputEnvelope
    connect?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
  }

  export type LicensesLangCreateNestedManyWithoutAudioInput = {
    create?: XOR<LicensesLangCreateWithoutAudioInput, LicensesLangUncheckedCreateWithoutAudioInput> | LicensesLangCreateWithoutAudioInput[] | LicensesLangUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: LicensesLangCreateOrConnectWithoutAudioInput | LicensesLangCreateOrConnectWithoutAudioInput[]
    createMany?: LicensesLangCreateManyAudioInputEnvelope
    connect?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
  }

  export type QuizzesLangCreateNestedManyWithoutAudioInput = {
    create?: XOR<QuizzesLangCreateWithoutAudioInput, QuizzesLangUncheckedCreateWithoutAudioInput> | QuizzesLangCreateWithoutAudioInput[] | QuizzesLangUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: QuizzesLangCreateOrConnectWithoutAudioInput | QuizzesLangCreateOrConnectWithoutAudioInput[]
    createMany?: QuizzesLangCreateManyAudioInputEnvelope
    connect?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
  }

  export type QuestionsLangCreateNestedManyWithoutAudioInput = {
    create?: XOR<QuestionsLangCreateWithoutAudioInput, QuestionsLangUncheckedCreateWithoutAudioInput> | QuestionsLangCreateWithoutAudioInput[] | QuestionsLangUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: QuestionsLangCreateOrConnectWithoutAudioInput | QuestionsLangCreateOrConnectWithoutAudioInput[]
    createMany?: QuestionsLangCreateManyAudioInputEnvelope
    connect?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
  }

  export type ChoicesLangUncheckedCreateNestedManyWithoutAudioInput = {
    create?: XOR<ChoicesLangCreateWithoutAudioInput, ChoicesLangUncheckedCreateWithoutAudioInput> | ChoicesLangCreateWithoutAudioInput[] | ChoicesLangUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: ChoicesLangCreateOrConnectWithoutAudioInput | ChoicesLangCreateOrConnectWithoutAudioInput[]
    createMany?: ChoicesLangCreateManyAudioInputEnvelope
    connect?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
  }

  export type GroupsLangUncheckedCreateNestedManyWithoutAudioInput = {
    create?: XOR<GroupsLangCreateWithoutAudioInput, GroupsLangUncheckedCreateWithoutAudioInput> | GroupsLangCreateWithoutAudioInput[] | GroupsLangUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: GroupsLangCreateOrConnectWithoutAudioInput | GroupsLangCreateOrConnectWithoutAudioInput[]
    createMany?: GroupsLangCreateManyAudioInputEnvelope
    connect?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
  }

  export type LicensesLangUncheckedCreateNestedManyWithoutAudioInput = {
    create?: XOR<LicensesLangCreateWithoutAudioInput, LicensesLangUncheckedCreateWithoutAudioInput> | LicensesLangCreateWithoutAudioInput[] | LicensesLangUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: LicensesLangCreateOrConnectWithoutAudioInput | LicensesLangCreateOrConnectWithoutAudioInput[]
    createMany?: LicensesLangCreateManyAudioInputEnvelope
    connect?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
  }

  export type QuizzesLangUncheckedCreateNestedManyWithoutAudioInput = {
    create?: XOR<QuizzesLangCreateWithoutAudioInput, QuizzesLangUncheckedCreateWithoutAudioInput> | QuizzesLangCreateWithoutAudioInput[] | QuizzesLangUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: QuizzesLangCreateOrConnectWithoutAudioInput | QuizzesLangCreateOrConnectWithoutAudioInput[]
    createMany?: QuizzesLangCreateManyAudioInputEnvelope
    connect?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
  }

  export type QuestionsLangUncheckedCreateNestedManyWithoutAudioInput = {
    create?: XOR<QuestionsLangCreateWithoutAudioInput, QuestionsLangUncheckedCreateWithoutAudioInput> | QuestionsLangCreateWithoutAudioInput[] | QuestionsLangUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: QuestionsLangCreateOrConnectWithoutAudioInput | QuestionsLangCreateOrConnectWithoutAudioInput[]
    createMany?: QuestionsLangCreateManyAudioInputEnvelope
    connect?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ChoicesLangUpdateManyWithoutAudioNestedInput = {
    create?: XOR<ChoicesLangCreateWithoutAudioInput, ChoicesLangUncheckedCreateWithoutAudioInput> | ChoicesLangCreateWithoutAudioInput[] | ChoicesLangUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: ChoicesLangCreateOrConnectWithoutAudioInput | ChoicesLangCreateOrConnectWithoutAudioInput[]
    upsert?: ChoicesLangUpsertWithWhereUniqueWithoutAudioInput | ChoicesLangUpsertWithWhereUniqueWithoutAudioInput[]
    createMany?: ChoicesLangCreateManyAudioInputEnvelope
    set?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
    disconnect?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
    delete?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
    connect?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
    update?: ChoicesLangUpdateWithWhereUniqueWithoutAudioInput | ChoicesLangUpdateWithWhereUniqueWithoutAudioInput[]
    updateMany?: ChoicesLangUpdateManyWithWhereWithoutAudioInput | ChoicesLangUpdateManyWithWhereWithoutAudioInput[]
    deleteMany?: ChoicesLangScalarWhereInput | ChoicesLangScalarWhereInput[]
  }

  export type GroupsLangUpdateManyWithoutAudioNestedInput = {
    create?: XOR<GroupsLangCreateWithoutAudioInput, GroupsLangUncheckedCreateWithoutAudioInput> | GroupsLangCreateWithoutAudioInput[] | GroupsLangUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: GroupsLangCreateOrConnectWithoutAudioInput | GroupsLangCreateOrConnectWithoutAudioInput[]
    upsert?: GroupsLangUpsertWithWhereUniqueWithoutAudioInput | GroupsLangUpsertWithWhereUniqueWithoutAudioInput[]
    createMany?: GroupsLangCreateManyAudioInputEnvelope
    set?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
    disconnect?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
    delete?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
    connect?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
    update?: GroupsLangUpdateWithWhereUniqueWithoutAudioInput | GroupsLangUpdateWithWhereUniqueWithoutAudioInput[]
    updateMany?: GroupsLangUpdateManyWithWhereWithoutAudioInput | GroupsLangUpdateManyWithWhereWithoutAudioInput[]
    deleteMany?: GroupsLangScalarWhereInput | GroupsLangScalarWhereInput[]
  }

  export type LicensesLangUpdateManyWithoutAudioNestedInput = {
    create?: XOR<LicensesLangCreateWithoutAudioInput, LicensesLangUncheckedCreateWithoutAudioInput> | LicensesLangCreateWithoutAudioInput[] | LicensesLangUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: LicensesLangCreateOrConnectWithoutAudioInput | LicensesLangCreateOrConnectWithoutAudioInput[]
    upsert?: LicensesLangUpsertWithWhereUniqueWithoutAudioInput | LicensesLangUpsertWithWhereUniqueWithoutAudioInput[]
    createMany?: LicensesLangCreateManyAudioInputEnvelope
    set?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
    disconnect?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
    delete?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
    connect?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
    update?: LicensesLangUpdateWithWhereUniqueWithoutAudioInput | LicensesLangUpdateWithWhereUniqueWithoutAudioInput[]
    updateMany?: LicensesLangUpdateManyWithWhereWithoutAudioInput | LicensesLangUpdateManyWithWhereWithoutAudioInput[]
    deleteMany?: LicensesLangScalarWhereInput | LicensesLangScalarWhereInput[]
  }

  export type QuizzesLangUpdateManyWithoutAudioNestedInput = {
    create?: XOR<QuizzesLangCreateWithoutAudioInput, QuizzesLangUncheckedCreateWithoutAudioInput> | QuizzesLangCreateWithoutAudioInput[] | QuizzesLangUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: QuizzesLangCreateOrConnectWithoutAudioInput | QuizzesLangCreateOrConnectWithoutAudioInput[]
    upsert?: QuizzesLangUpsertWithWhereUniqueWithoutAudioInput | QuizzesLangUpsertWithWhereUniqueWithoutAudioInput[]
    createMany?: QuizzesLangCreateManyAudioInputEnvelope
    set?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
    disconnect?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
    delete?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
    connect?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
    update?: QuizzesLangUpdateWithWhereUniqueWithoutAudioInput | QuizzesLangUpdateWithWhereUniqueWithoutAudioInput[]
    updateMany?: QuizzesLangUpdateManyWithWhereWithoutAudioInput | QuizzesLangUpdateManyWithWhereWithoutAudioInput[]
    deleteMany?: QuizzesLangScalarWhereInput | QuizzesLangScalarWhereInput[]
  }

  export type QuestionsLangUpdateManyWithoutAudioNestedInput = {
    create?: XOR<QuestionsLangCreateWithoutAudioInput, QuestionsLangUncheckedCreateWithoutAudioInput> | QuestionsLangCreateWithoutAudioInput[] | QuestionsLangUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: QuestionsLangCreateOrConnectWithoutAudioInput | QuestionsLangCreateOrConnectWithoutAudioInput[]
    upsert?: QuestionsLangUpsertWithWhereUniqueWithoutAudioInput | QuestionsLangUpsertWithWhereUniqueWithoutAudioInput[]
    createMany?: QuestionsLangCreateManyAudioInputEnvelope
    set?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
    disconnect?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
    delete?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
    connect?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
    update?: QuestionsLangUpdateWithWhereUniqueWithoutAudioInput | QuestionsLangUpdateWithWhereUniqueWithoutAudioInput[]
    updateMany?: QuestionsLangUpdateManyWithWhereWithoutAudioInput | QuestionsLangUpdateManyWithWhereWithoutAudioInput[]
    deleteMany?: QuestionsLangScalarWhereInput | QuestionsLangScalarWhereInput[]
  }

  export type ChoicesLangUncheckedUpdateManyWithoutAudioNestedInput = {
    create?: XOR<ChoicesLangCreateWithoutAudioInput, ChoicesLangUncheckedCreateWithoutAudioInput> | ChoicesLangCreateWithoutAudioInput[] | ChoicesLangUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: ChoicesLangCreateOrConnectWithoutAudioInput | ChoicesLangCreateOrConnectWithoutAudioInput[]
    upsert?: ChoicesLangUpsertWithWhereUniqueWithoutAudioInput | ChoicesLangUpsertWithWhereUniqueWithoutAudioInput[]
    createMany?: ChoicesLangCreateManyAudioInputEnvelope
    set?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
    disconnect?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
    delete?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
    connect?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
    update?: ChoicesLangUpdateWithWhereUniqueWithoutAudioInput | ChoicesLangUpdateWithWhereUniqueWithoutAudioInput[]
    updateMany?: ChoicesLangUpdateManyWithWhereWithoutAudioInput | ChoicesLangUpdateManyWithWhereWithoutAudioInput[]
    deleteMany?: ChoicesLangScalarWhereInput | ChoicesLangScalarWhereInput[]
  }

  export type GroupsLangUncheckedUpdateManyWithoutAudioNestedInput = {
    create?: XOR<GroupsLangCreateWithoutAudioInput, GroupsLangUncheckedCreateWithoutAudioInput> | GroupsLangCreateWithoutAudioInput[] | GroupsLangUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: GroupsLangCreateOrConnectWithoutAudioInput | GroupsLangCreateOrConnectWithoutAudioInput[]
    upsert?: GroupsLangUpsertWithWhereUniqueWithoutAudioInput | GroupsLangUpsertWithWhereUniqueWithoutAudioInput[]
    createMany?: GroupsLangCreateManyAudioInputEnvelope
    set?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
    disconnect?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
    delete?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
    connect?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
    update?: GroupsLangUpdateWithWhereUniqueWithoutAudioInput | GroupsLangUpdateWithWhereUniqueWithoutAudioInput[]
    updateMany?: GroupsLangUpdateManyWithWhereWithoutAudioInput | GroupsLangUpdateManyWithWhereWithoutAudioInput[]
    deleteMany?: GroupsLangScalarWhereInput | GroupsLangScalarWhereInput[]
  }

  export type LicensesLangUncheckedUpdateManyWithoutAudioNestedInput = {
    create?: XOR<LicensesLangCreateWithoutAudioInput, LicensesLangUncheckedCreateWithoutAudioInput> | LicensesLangCreateWithoutAudioInput[] | LicensesLangUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: LicensesLangCreateOrConnectWithoutAudioInput | LicensesLangCreateOrConnectWithoutAudioInput[]
    upsert?: LicensesLangUpsertWithWhereUniqueWithoutAudioInput | LicensesLangUpsertWithWhereUniqueWithoutAudioInput[]
    createMany?: LicensesLangCreateManyAudioInputEnvelope
    set?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
    disconnect?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
    delete?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
    connect?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
    update?: LicensesLangUpdateWithWhereUniqueWithoutAudioInput | LicensesLangUpdateWithWhereUniqueWithoutAudioInput[]
    updateMany?: LicensesLangUpdateManyWithWhereWithoutAudioInput | LicensesLangUpdateManyWithWhereWithoutAudioInput[]
    deleteMany?: LicensesLangScalarWhereInput | LicensesLangScalarWhereInput[]
  }

  export type QuizzesLangUncheckedUpdateManyWithoutAudioNestedInput = {
    create?: XOR<QuizzesLangCreateWithoutAudioInput, QuizzesLangUncheckedCreateWithoutAudioInput> | QuizzesLangCreateWithoutAudioInput[] | QuizzesLangUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: QuizzesLangCreateOrConnectWithoutAudioInput | QuizzesLangCreateOrConnectWithoutAudioInput[]
    upsert?: QuizzesLangUpsertWithWhereUniqueWithoutAudioInput | QuizzesLangUpsertWithWhereUniqueWithoutAudioInput[]
    createMany?: QuizzesLangCreateManyAudioInputEnvelope
    set?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
    disconnect?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
    delete?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
    connect?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
    update?: QuizzesLangUpdateWithWhereUniqueWithoutAudioInput | QuizzesLangUpdateWithWhereUniqueWithoutAudioInput[]
    updateMany?: QuizzesLangUpdateManyWithWhereWithoutAudioInput | QuizzesLangUpdateManyWithWhereWithoutAudioInput[]
    deleteMany?: QuizzesLangScalarWhereInput | QuizzesLangScalarWhereInput[]
  }

  export type QuestionsLangUncheckedUpdateManyWithoutAudioNestedInput = {
    create?: XOR<QuestionsLangCreateWithoutAudioInput, QuestionsLangUncheckedCreateWithoutAudioInput> | QuestionsLangCreateWithoutAudioInput[] | QuestionsLangUncheckedCreateWithoutAudioInput[]
    connectOrCreate?: QuestionsLangCreateOrConnectWithoutAudioInput | QuestionsLangCreateOrConnectWithoutAudioInput[]
    upsert?: QuestionsLangUpsertWithWhereUniqueWithoutAudioInput | QuestionsLangUpsertWithWhereUniqueWithoutAudioInput[]
    createMany?: QuestionsLangCreateManyAudioInputEnvelope
    set?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
    disconnect?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
    delete?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
    connect?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
    update?: QuestionsLangUpdateWithWhereUniqueWithoutAudioInput | QuestionsLangUpdateWithWhereUniqueWithoutAudioInput[]
    updateMany?: QuestionsLangUpdateManyWithWhereWithoutAudioInput | QuestionsLangUpdateManyWithWhereWithoutAudioInput[]
    deleteMany?: QuestionsLangScalarWhereInput | QuestionsLangScalarWhereInput[]
  }

  export type UsersAuthCreateNestedManyWithoutAuthorizationsInput = {
    create?: XOR<UsersAuthCreateWithoutAuthorizationsInput, UsersAuthUncheckedCreateWithoutAuthorizationsInput> | UsersAuthCreateWithoutAuthorizationsInput[] | UsersAuthUncheckedCreateWithoutAuthorizationsInput[]
    connectOrCreate?: UsersAuthCreateOrConnectWithoutAuthorizationsInput | UsersAuthCreateOrConnectWithoutAuthorizationsInput[]
    createMany?: UsersAuthCreateManyAuthorizationsInputEnvelope
    connect?: UsersAuthWhereUniqueInput | UsersAuthWhereUniqueInput[]
  }

  export type UsersAuthUncheckedCreateNestedManyWithoutAuthorizationsInput = {
    create?: XOR<UsersAuthCreateWithoutAuthorizationsInput, UsersAuthUncheckedCreateWithoutAuthorizationsInput> | UsersAuthCreateWithoutAuthorizationsInput[] | UsersAuthUncheckedCreateWithoutAuthorizationsInput[]
    connectOrCreate?: UsersAuthCreateOrConnectWithoutAuthorizationsInput | UsersAuthCreateOrConnectWithoutAuthorizationsInput[]
    createMany?: UsersAuthCreateManyAuthorizationsInputEnvelope
    connect?: UsersAuthWhereUniqueInput | UsersAuthWhereUniqueInput[]
  }

  export type UsersAuthUpdateManyWithoutAuthorizationsNestedInput = {
    create?: XOR<UsersAuthCreateWithoutAuthorizationsInput, UsersAuthUncheckedCreateWithoutAuthorizationsInput> | UsersAuthCreateWithoutAuthorizationsInput[] | UsersAuthUncheckedCreateWithoutAuthorizationsInput[]
    connectOrCreate?: UsersAuthCreateOrConnectWithoutAuthorizationsInput | UsersAuthCreateOrConnectWithoutAuthorizationsInput[]
    upsert?: UsersAuthUpsertWithWhereUniqueWithoutAuthorizationsInput | UsersAuthUpsertWithWhereUniqueWithoutAuthorizationsInput[]
    createMany?: UsersAuthCreateManyAuthorizationsInputEnvelope
    set?: UsersAuthWhereUniqueInput | UsersAuthWhereUniqueInput[]
    disconnect?: UsersAuthWhereUniqueInput | UsersAuthWhereUniqueInput[]
    delete?: UsersAuthWhereUniqueInput | UsersAuthWhereUniqueInput[]
    connect?: UsersAuthWhereUniqueInput | UsersAuthWhereUniqueInput[]
    update?: UsersAuthUpdateWithWhereUniqueWithoutAuthorizationsInput | UsersAuthUpdateWithWhereUniqueWithoutAuthorizationsInput[]
    updateMany?: UsersAuthUpdateManyWithWhereWithoutAuthorizationsInput | UsersAuthUpdateManyWithWhereWithoutAuthorizationsInput[]
    deleteMany?: UsersAuthScalarWhereInput | UsersAuthScalarWhereInput[]
  }

  export type UsersAuthUncheckedUpdateManyWithoutAuthorizationsNestedInput = {
    create?: XOR<UsersAuthCreateWithoutAuthorizationsInput, UsersAuthUncheckedCreateWithoutAuthorizationsInput> | UsersAuthCreateWithoutAuthorizationsInput[] | UsersAuthUncheckedCreateWithoutAuthorizationsInput[]
    connectOrCreate?: UsersAuthCreateOrConnectWithoutAuthorizationsInput | UsersAuthCreateOrConnectWithoutAuthorizationsInput[]
    upsert?: UsersAuthUpsertWithWhereUniqueWithoutAuthorizationsInput | UsersAuthUpsertWithWhereUniqueWithoutAuthorizationsInput[]
    createMany?: UsersAuthCreateManyAuthorizationsInputEnvelope
    set?: UsersAuthWhereUniqueInput | UsersAuthWhereUniqueInput[]
    disconnect?: UsersAuthWhereUniqueInput | UsersAuthWhereUniqueInput[]
    delete?: UsersAuthWhereUniqueInput | UsersAuthWhereUniqueInput[]
    connect?: UsersAuthWhereUniqueInput | UsersAuthWhereUniqueInput[]
    update?: UsersAuthUpdateWithWhereUniqueWithoutAuthorizationsInput | UsersAuthUpdateWithWhereUniqueWithoutAuthorizationsInput[]
    updateMany?: UsersAuthUpdateManyWithWhereWithoutAuthorizationsInput | UsersAuthUpdateManyWithWhereWithoutAuthorizationsInput[]
    deleteMany?: UsersAuthScalarWhereInput | UsersAuthScalarWhereInput[]
  }

  export type ChoicesLangCreateNestedManyWithoutChoicesInput = {
    create?: XOR<ChoicesLangCreateWithoutChoicesInput, ChoicesLangUncheckedCreateWithoutChoicesInput> | ChoicesLangCreateWithoutChoicesInput[] | ChoicesLangUncheckedCreateWithoutChoicesInput[]
    connectOrCreate?: ChoicesLangCreateOrConnectWithoutChoicesInput | ChoicesLangCreateOrConnectWithoutChoicesInput[]
    createMany?: ChoicesLangCreateManyChoicesInputEnvelope
    connect?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
  }

  export type RelationsChoicesCreateNestedManyWithoutChoicesInput = {
    create?: XOR<RelationsChoicesCreateWithoutChoicesInput, RelationsChoicesUncheckedCreateWithoutChoicesInput> | RelationsChoicesCreateWithoutChoicesInput[] | RelationsChoicesUncheckedCreateWithoutChoicesInput[]
    connectOrCreate?: RelationsChoicesCreateOrConnectWithoutChoicesInput | RelationsChoicesCreateOrConnectWithoutChoicesInput[]
    createMany?: RelationsChoicesCreateManyChoicesInputEnvelope
    connect?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
  }

  export type ChoicesLangUncheckedCreateNestedManyWithoutChoicesInput = {
    create?: XOR<ChoicesLangCreateWithoutChoicesInput, ChoicesLangUncheckedCreateWithoutChoicesInput> | ChoicesLangCreateWithoutChoicesInput[] | ChoicesLangUncheckedCreateWithoutChoicesInput[]
    connectOrCreate?: ChoicesLangCreateOrConnectWithoutChoicesInput | ChoicesLangCreateOrConnectWithoutChoicesInput[]
    createMany?: ChoicesLangCreateManyChoicesInputEnvelope
    connect?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
  }

  export type RelationsChoicesUncheckedCreateNestedManyWithoutChoicesInput = {
    create?: XOR<RelationsChoicesCreateWithoutChoicesInput, RelationsChoicesUncheckedCreateWithoutChoicesInput> | RelationsChoicesCreateWithoutChoicesInput[] | RelationsChoicesUncheckedCreateWithoutChoicesInput[]
    connectOrCreate?: RelationsChoicesCreateOrConnectWithoutChoicesInput | RelationsChoicesCreateOrConnectWithoutChoicesInput[]
    createMany?: RelationsChoicesCreateManyChoicesInputEnvelope
    connect?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
  }

  export type ChoicesLangUpdateManyWithoutChoicesNestedInput = {
    create?: XOR<ChoicesLangCreateWithoutChoicesInput, ChoicesLangUncheckedCreateWithoutChoicesInput> | ChoicesLangCreateWithoutChoicesInput[] | ChoicesLangUncheckedCreateWithoutChoicesInput[]
    connectOrCreate?: ChoicesLangCreateOrConnectWithoutChoicesInput | ChoicesLangCreateOrConnectWithoutChoicesInput[]
    upsert?: ChoicesLangUpsertWithWhereUniqueWithoutChoicesInput | ChoicesLangUpsertWithWhereUniqueWithoutChoicesInput[]
    createMany?: ChoicesLangCreateManyChoicesInputEnvelope
    set?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
    disconnect?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
    delete?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
    connect?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
    update?: ChoicesLangUpdateWithWhereUniqueWithoutChoicesInput | ChoicesLangUpdateWithWhereUniqueWithoutChoicesInput[]
    updateMany?: ChoicesLangUpdateManyWithWhereWithoutChoicesInput | ChoicesLangUpdateManyWithWhereWithoutChoicesInput[]
    deleteMany?: ChoicesLangScalarWhereInput | ChoicesLangScalarWhereInput[]
  }

  export type RelationsChoicesUpdateManyWithoutChoicesNestedInput = {
    create?: XOR<RelationsChoicesCreateWithoutChoicesInput, RelationsChoicesUncheckedCreateWithoutChoicesInput> | RelationsChoicesCreateWithoutChoicesInput[] | RelationsChoicesUncheckedCreateWithoutChoicesInput[]
    connectOrCreate?: RelationsChoicesCreateOrConnectWithoutChoicesInput | RelationsChoicesCreateOrConnectWithoutChoicesInput[]
    upsert?: RelationsChoicesUpsertWithWhereUniqueWithoutChoicesInput | RelationsChoicesUpsertWithWhereUniqueWithoutChoicesInput[]
    createMany?: RelationsChoicesCreateManyChoicesInputEnvelope
    set?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    disconnect?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    delete?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    connect?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    update?: RelationsChoicesUpdateWithWhereUniqueWithoutChoicesInput | RelationsChoicesUpdateWithWhereUniqueWithoutChoicesInput[]
    updateMany?: RelationsChoicesUpdateManyWithWhereWithoutChoicesInput | RelationsChoicesUpdateManyWithWhereWithoutChoicesInput[]
    deleteMany?: RelationsChoicesScalarWhereInput | RelationsChoicesScalarWhereInput[]
  }

  export type ChoicesLangUncheckedUpdateManyWithoutChoicesNestedInput = {
    create?: XOR<ChoicesLangCreateWithoutChoicesInput, ChoicesLangUncheckedCreateWithoutChoicesInput> | ChoicesLangCreateWithoutChoicesInput[] | ChoicesLangUncheckedCreateWithoutChoicesInput[]
    connectOrCreate?: ChoicesLangCreateOrConnectWithoutChoicesInput | ChoicesLangCreateOrConnectWithoutChoicesInput[]
    upsert?: ChoicesLangUpsertWithWhereUniqueWithoutChoicesInput | ChoicesLangUpsertWithWhereUniqueWithoutChoicesInput[]
    createMany?: ChoicesLangCreateManyChoicesInputEnvelope
    set?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
    disconnect?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
    delete?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
    connect?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
    update?: ChoicesLangUpdateWithWhereUniqueWithoutChoicesInput | ChoicesLangUpdateWithWhereUniqueWithoutChoicesInput[]
    updateMany?: ChoicesLangUpdateManyWithWhereWithoutChoicesInput | ChoicesLangUpdateManyWithWhereWithoutChoicesInput[]
    deleteMany?: ChoicesLangScalarWhereInput | ChoicesLangScalarWhereInput[]
  }

  export type RelationsChoicesUncheckedUpdateManyWithoutChoicesNestedInput = {
    create?: XOR<RelationsChoicesCreateWithoutChoicesInput, RelationsChoicesUncheckedCreateWithoutChoicesInput> | RelationsChoicesCreateWithoutChoicesInput[] | RelationsChoicesUncheckedCreateWithoutChoicesInput[]
    connectOrCreate?: RelationsChoicesCreateOrConnectWithoutChoicesInput | RelationsChoicesCreateOrConnectWithoutChoicesInput[]
    upsert?: RelationsChoicesUpsertWithWhereUniqueWithoutChoicesInput | RelationsChoicesUpsertWithWhereUniqueWithoutChoicesInput[]
    createMany?: RelationsChoicesCreateManyChoicesInputEnvelope
    set?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    disconnect?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    delete?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    connect?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    update?: RelationsChoicesUpdateWithWhereUniqueWithoutChoicesInput | RelationsChoicesUpdateWithWhereUniqueWithoutChoicesInput[]
    updateMany?: RelationsChoicesUpdateManyWithWhereWithoutChoicesInput | RelationsChoicesUpdateManyWithWhereWithoutChoicesInput[]
    deleteMany?: RelationsChoicesScalarWhereInput | RelationsChoicesScalarWhereInput[]
  }

  export type ChoicesCreateNestedOneWithoutChoicesLangInput = {
    create?: XOR<ChoicesCreateWithoutChoicesLangInput, ChoicesUncheckedCreateWithoutChoicesLangInput>
    connectOrCreate?: ChoicesCreateOrConnectWithoutChoicesLangInput
    connect?: ChoicesWhereUniqueInput
  }

  export type LanguagesCreateNestedOneWithoutChoicesLangInput = {
    create?: XOR<LanguagesCreateWithoutChoicesLangInput, LanguagesUncheckedCreateWithoutChoicesLangInput>
    connectOrCreate?: LanguagesCreateOrConnectWithoutChoicesLangInput
    connect?: LanguagesWhereUniqueInput
  }

  export type AudioCreateNestedOneWithoutChoicesLangInput = {
    create?: XOR<AudioCreateWithoutChoicesLangInput, AudioUncheckedCreateWithoutChoicesLangInput>
    connectOrCreate?: AudioCreateOrConnectWithoutChoicesLangInput
    connect?: AudioWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ChoicesUpdateOneRequiredWithoutChoicesLangNestedInput = {
    create?: XOR<ChoicesCreateWithoutChoicesLangInput, ChoicesUncheckedCreateWithoutChoicesLangInput>
    connectOrCreate?: ChoicesCreateOrConnectWithoutChoicesLangInput
    upsert?: ChoicesUpsertWithoutChoicesLangInput
    connect?: ChoicesWhereUniqueInput
    update?: XOR<XOR<ChoicesUpdateToOneWithWhereWithoutChoicesLangInput, ChoicesUpdateWithoutChoicesLangInput>, ChoicesUncheckedUpdateWithoutChoicesLangInput>
  }

  export type LanguagesUpdateOneRequiredWithoutChoicesLangNestedInput = {
    create?: XOR<LanguagesCreateWithoutChoicesLangInput, LanguagesUncheckedCreateWithoutChoicesLangInput>
    connectOrCreate?: LanguagesCreateOrConnectWithoutChoicesLangInput
    upsert?: LanguagesUpsertWithoutChoicesLangInput
    connect?: LanguagesWhereUniqueInput
    update?: XOR<XOR<LanguagesUpdateToOneWithWhereWithoutChoicesLangInput, LanguagesUpdateWithoutChoicesLangInput>, LanguagesUncheckedUpdateWithoutChoicesLangInput>
  }

  export type AudioUpdateOneWithoutChoicesLangNestedInput = {
    create?: XOR<AudioCreateWithoutChoicesLangInput, AudioUncheckedCreateWithoutChoicesLangInput>
    connectOrCreate?: AudioCreateOrConnectWithoutChoicesLangInput
    upsert?: AudioUpsertWithoutChoicesLangInput
    disconnect?: AudioWhereInput | boolean
    delete?: AudioWhereInput | boolean
    connect?: AudioWhereUniqueInput
    update?: XOR<XOR<AudioUpdateToOneWithWhereWithoutChoicesLangInput, AudioUpdateWithoutChoicesLangInput>, AudioUncheckedUpdateWithoutChoicesLangInput>
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type MediaCreateNestedOneWithoutGroupsInput = {
    create?: XOR<MediaCreateWithoutGroupsInput, MediaUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutGroupsInput
    connect?: MediaWhereUniqueInput
  }

  export type GroupsLangCreateNestedManyWithoutGroupsInput = {
    create?: XOR<GroupsLangCreateWithoutGroupsInput, GroupsLangUncheckedCreateWithoutGroupsInput> | GroupsLangCreateWithoutGroupsInput[] | GroupsLangUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: GroupsLangCreateOrConnectWithoutGroupsInput | GroupsLangCreateOrConnectWithoutGroupsInput[]
    createMany?: GroupsLangCreateManyGroupsInputEnvelope
    connect?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
  }

  export type RelationsCreateNestedManyWithoutGroupsInput = {
    create?: XOR<RelationsCreateWithoutGroupsInput, RelationsUncheckedCreateWithoutGroupsInput> | RelationsCreateWithoutGroupsInput[] | RelationsUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: RelationsCreateOrConnectWithoutGroupsInput | RelationsCreateOrConnectWithoutGroupsInput[]
    createMany?: RelationsCreateManyGroupsInputEnvelope
    connect?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
  }

  export type UsersGroupsCreateNestedManyWithoutGroupsInput = {
    create?: XOR<UsersGroupsCreateWithoutGroupsInput, UsersGroupsUncheckedCreateWithoutGroupsInput> | UsersGroupsCreateWithoutGroupsInput[] | UsersGroupsUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: UsersGroupsCreateOrConnectWithoutGroupsInput | UsersGroupsCreateOrConnectWithoutGroupsInput[]
    createMany?: UsersGroupsCreateManyGroupsInputEnvelope
    connect?: UsersGroupsWhereUniqueInput | UsersGroupsWhereUniqueInput[]
  }

  export type GroupsLangUncheckedCreateNestedManyWithoutGroupsInput = {
    create?: XOR<GroupsLangCreateWithoutGroupsInput, GroupsLangUncheckedCreateWithoutGroupsInput> | GroupsLangCreateWithoutGroupsInput[] | GroupsLangUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: GroupsLangCreateOrConnectWithoutGroupsInput | GroupsLangCreateOrConnectWithoutGroupsInput[]
    createMany?: GroupsLangCreateManyGroupsInputEnvelope
    connect?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
  }

  export type RelationsUncheckedCreateNestedManyWithoutGroupsInput = {
    create?: XOR<RelationsCreateWithoutGroupsInput, RelationsUncheckedCreateWithoutGroupsInput> | RelationsCreateWithoutGroupsInput[] | RelationsUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: RelationsCreateOrConnectWithoutGroupsInput | RelationsCreateOrConnectWithoutGroupsInput[]
    createMany?: RelationsCreateManyGroupsInputEnvelope
    connect?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
  }

  export type UsersGroupsUncheckedCreateNestedManyWithoutGroupsInput = {
    create?: XOR<UsersGroupsCreateWithoutGroupsInput, UsersGroupsUncheckedCreateWithoutGroupsInput> | UsersGroupsCreateWithoutGroupsInput[] | UsersGroupsUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: UsersGroupsCreateOrConnectWithoutGroupsInput | UsersGroupsCreateOrConnectWithoutGroupsInput[]
    createMany?: UsersGroupsCreateManyGroupsInputEnvelope
    connect?: UsersGroupsWhereUniqueInput | UsersGroupsWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type MediaUpdateOneWithoutGroupsNestedInput = {
    create?: XOR<MediaCreateWithoutGroupsInput, MediaUncheckedCreateWithoutGroupsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutGroupsInput
    upsert?: MediaUpsertWithoutGroupsInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutGroupsInput, MediaUpdateWithoutGroupsInput>, MediaUncheckedUpdateWithoutGroupsInput>
  }

  export type GroupsLangUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<GroupsLangCreateWithoutGroupsInput, GroupsLangUncheckedCreateWithoutGroupsInput> | GroupsLangCreateWithoutGroupsInput[] | GroupsLangUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: GroupsLangCreateOrConnectWithoutGroupsInput | GroupsLangCreateOrConnectWithoutGroupsInput[]
    upsert?: GroupsLangUpsertWithWhereUniqueWithoutGroupsInput | GroupsLangUpsertWithWhereUniqueWithoutGroupsInput[]
    createMany?: GroupsLangCreateManyGroupsInputEnvelope
    set?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
    disconnect?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
    delete?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
    connect?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
    update?: GroupsLangUpdateWithWhereUniqueWithoutGroupsInput | GroupsLangUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: GroupsLangUpdateManyWithWhereWithoutGroupsInput | GroupsLangUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: GroupsLangScalarWhereInput | GroupsLangScalarWhereInput[]
  }

  export type RelationsUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<RelationsCreateWithoutGroupsInput, RelationsUncheckedCreateWithoutGroupsInput> | RelationsCreateWithoutGroupsInput[] | RelationsUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: RelationsCreateOrConnectWithoutGroupsInput | RelationsCreateOrConnectWithoutGroupsInput[]
    upsert?: RelationsUpsertWithWhereUniqueWithoutGroupsInput | RelationsUpsertWithWhereUniqueWithoutGroupsInput[]
    createMany?: RelationsCreateManyGroupsInputEnvelope
    set?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
    disconnect?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
    delete?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
    connect?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
    update?: RelationsUpdateWithWhereUniqueWithoutGroupsInput | RelationsUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: RelationsUpdateManyWithWhereWithoutGroupsInput | RelationsUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: RelationsScalarWhereInput | RelationsScalarWhereInput[]
  }

  export type UsersGroupsUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<UsersGroupsCreateWithoutGroupsInput, UsersGroupsUncheckedCreateWithoutGroupsInput> | UsersGroupsCreateWithoutGroupsInput[] | UsersGroupsUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: UsersGroupsCreateOrConnectWithoutGroupsInput | UsersGroupsCreateOrConnectWithoutGroupsInput[]
    upsert?: UsersGroupsUpsertWithWhereUniqueWithoutGroupsInput | UsersGroupsUpsertWithWhereUniqueWithoutGroupsInput[]
    createMany?: UsersGroupsCreateManyGroupsInputEnvelope
    set?: UsersGroupsWhereUniqueInput | UsersGroupsWhereUniqueInput[]
    disconnect?: UsersGroupsWhereUniqueInput | UsersGroupsWhereUniqueInput[]
    delete?: UsersGroupsWhereUniqueInput | UsersGroupsWhereUniqueInput[]
    connect?: UsersGroupsWhereUniqueInput | UsersGroupsWhereUniqueInput[]
    update?: UsersGroupsUpdateWithWhereUniqueWithoutGroupsInput | UsersGroupsUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: UsersGroupsUpdateManyWithWhereWithoutGroupsInput | UsersGroupsUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: UsersGroupsScalarWhereInput | UsersGroupsScalarWhereInput[]
  }

  export type GroupsLangUncheckedUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<GroupsLangCreateWithoutGroupsInput, GroupsLangUncheckedCreateWithoutGroupsInput> | GroupsLangCreateWithoutGroupsInput[] | GroupsLangUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: GroupsLangCreateOrConnectWithoutGroupsInput | GroupsLangCreateOrConnectWithoutGroupsInput[]
    upsert?: GroupsLangUpsertWithWhereUniqueWithoutGroupsInput | GroupsLangUpsertWithWhereUniqueWithoutGroupsInput[]
    createMany?: GroupsLangCreateManyGroupsInputEnvelope
    set?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
    disconnect?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
    delete?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
    connect?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
    update?: GroupsLangUpdateWithWhereUniqueWithoutGroupsInput | GroupsLangUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: GroupsLangUpdateManyWithWhereWithoutGroupsInput | GroupsLangUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: GroupsLangScalarWhereInput | GroupsLangScalarWhereInput[]
  }

  export type RelationsUncheckedUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<RelationsCreateWithoutGroupsInput, RelationsUncheckedCreateWithoutGroupsInput> | RelationsCreateWithoutGroupsInput[] | RelationsUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: RelationsCreateOrConnectWithoutGroupsInput | RelationsCreateOrConnectWithoutGroupsInput[]
    upsert?: RelationsUpsertWithWhereUniqueWithoutGroupsInput | RelationsUpsertWithWhereUniqueWithoutGroupsInput[]
    createMany?: RelationsCreateManyGroupsInputEnvelope
    set?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
    disconnect?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
    delete?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
    connect?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
    update?: RelationsUpdateWithWhereUniqueWithoutGroupsInput | RelationsUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: RelationsUpdateManyWithWhereWithoutGroupsInput | RelationsUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: RelationsScalarWhereInput | RelationsScalarWhereInput[]
  }

  export type UsersGroupsUncheckedUpdateManyWithoutGroupsNestedInput = {
    create?: XOR<UsersGroupsCreateWithoutGroupsInput, UsersGroupsUncheckedCreateWithoutGroupsInput> | UsersGroupsCreateWithoutGroupsInput[] | UsersGroupsUncheckedCreateWithoutGroupsInput[]
    connectOrCreate?: UsersGroupsCreateOrConnectWithoutGroupsInput | UsersGroupsCreateOrConnectWithoutGroupsInput[]
    upsert?: UsersGroupsUpsertWithWhereUniqueWithoutGroupsInput | UsersGroupsUpsertWithWhereUniqueWithoutGroupsInput[]
    createMany?: UsersGroupsCreateManyGroupsInputEnvelope
    set?: UsersGroupsWhereUniqueInput | UsersGroupsWhereUniqueInput[]
    disconnect?: UsersGroupsWhereUniqueInput | UsersGroupsWhereUniqueInput[]
    delete?: UsersGroupsWhereUniqueInput | UsersGroupsWhereUniqueInput[]
    connect?: UsersGroupsWhereUniqueInput | UsersGroupsWhereUniqueInput[]
    update?: UsersGroupsUpdateWithWhereUniqueWithoutGroupsInput | UsersGroupsUpdateWithWhereUniqueWithoutGroupsInput[]
    updateMany?: UsersGroupsUpdateManyWithWhereWithoutGroupsInput | UsersGroupsUpdateManyWithWhereWithoutGroupsInput[]
    deleteMany?: UsersGroupsScalarWhereInput | UsersGroupsScalarWhereInput[]
  }

  export type GroupsCreateNestedOneWithoutGroupsLangInput = {
    create?: XOR<GroupsCreateWithoutGroupsLangInput, GroupsUncheckedCreateWithoutGroupsLangInput>
    connectOrCreate?: GroupsCreateOrConnectWithoutGroupsLangInput
    connect?: GroupsWhereUniqueInput
  }

  export type LanguagesCreateNestedOneWithoutGroupsLangInput = {
    create?: XOR<LanguagesCreateWithoutGroupsLangInput, LanguagesUncheckedCreateWithoutGroupsLangInput>
    connectOrCreate?: LanguagesCreateOrConnectWithoutGroupsLangInput
    connect?: LanguagesWhereUniqueInput
  }

  export type AudioCreateNestedOneWithoutGroupsLangInput = {
    create?: XOR<AudioCreateWithoutGroupsLangInput, AudioUncheckedCreateWithoutGroupsLangInput>
    connectOrCreate?: AudioCreateOrConnectWithoutGroupsLangInput
    connect?: AudioWhereUniqueInput
  }

  export type GroupsUpdateOneRequiredWithoutGroupsLangNestedInput = {
    create?: XOR<GroupsCreateWithoutGroupsLangInput, GroupsUncheckedCreateWithoutGroupsLangInput>
    connectOrCreate?: GroupsCreateOrConnectWithoutGroupsLangInput
    upsert?: GroupsUpsertWithoutGroupsLangInput
    connect?: GroupsWhereUniqueInput
    update?: XOR<XOR<GroupsUpdateToOneWithWhereWithoutGroupsLangInput, GroupsUpdateWithoutGroupsLangInput>, GroupsUncheckedUpdateWithoutGroupsLangInput>
  }

  export type LanguagesUpdateOneRequiredWithoutGroupsLangNestedInput = {
    create?: XOR<LanguagesCreateWithoutGroupsLangInput, LanguagesUncheckedCreateWithoutGroupsLangInput>
    connectOrCreate?: LanguagesCreateOrConnectWithoutGroupsLangInput
    upsert?: LanguagesUpsertWithoutGroupsLangInput
    connect?: LanguagesWhereUniqueInput
    update?: XOR<XOR<LanguagesUpdateToOneWithWhereWithoutGroupsLangInput, LanguagesUpdateWithoutGroupsLangInput>, LanguagesUncheckedUpdateWithoutGroupsLangInput>
  }

  export type AudioUpdateOneWithoutGroupsLangNestedInput = {
    create?: XOR<AudioCreateWithoutGroupsLangInput, AudioUncheckedCreateWithoutGroupsLangInput>
    connectOrCreate?: AudioCreateOrConnectWithoutGroupsLangInput
    upsert?: AudioUpsertWithoutGroupsLangInput
    disconnect?: AudioWhereInput | boolean
    delete?: AudioWhereInput | boolean
    connect?: AudioWhereUniqueInput
    update?: XOR<XOR<AudioUpdateToOneWithWhereWithoutGroupsLangInput, AudioUpdateWithoutGroupsLangInput>, AudioUncheckedUpdateWithoutGroupsLangInput>
  }

  export type ChoicesLangCreateNestedManyWithoutLanguagesInput = {
    create?: XOR<ChoicesLangCreateWithoutLanguagesInput, ChoicesLangUncheckedCreateWithoutLanguagesInput> | ChoicesLangCreateWithoutLanguagesInput[] | ChoicesLangUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: ChoicesLangCreateOrConnectWithoutLanguagesInput | ChoicesLangCreateOrConnectWithoutLanguagesInput[]
    createMany?: ChoicesLangCreateManyLanguagesInputEnvelope
    connect?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
  }

  export type GroupsLangCreateNestedManyWithoutLanguagesInput = {
    create?: XOR<GroupsLangCreateWithoutLanguagesInput, GroupsLangUncheckedCreateWithoutLanguagesInput> | GroupsLangCreateWithoutLanguagesInput[] | GroupsLangUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: GroupsLangCreateOrConnectWithoutLanguagesInput | GroupsLangCreateOrConnectWithoutLanguagesInput[]
    createMany?: GroupsLangCreateManyLanguagesInputEnvelope
    connect?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
  }

  export type LicensesLangCreateNestedManyWithoutLanguagesInput = {
    create?: XOR<LicensesLangCreateWithoutLanguagesInput, LicensesLangUncheckedCreateWithoutLanguagesInput> | LicensesLangCreateWithoutLanguagesInput[] | LicensesLangUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: LicensesLangCreateOrConnectWithoutLanguagesInput | LicensesLangCreateOrConnectWithoutLanguagesInput[]
    createMany?: LicensesLangCreateManyLanguagesInputEnvelope
    connect?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
  }

  export type QuestionsLangCreateNestedManyWithoutLanguagesInput = {
    create?: XOR<QuestionsLangCreateWithoutLanguagesInput, QuestionsLangUncheckedCreateWithoutLanguagesInput> | QuestionsLangCreateWithoutLanguagesInput[] | QuestionsLangUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: QuestionsLangCreateOrConnectWithoutLanguagesInput | QuestionsLangCreateOrConnectWithoutLanguagesInput[]
    createMany?: QuestionsLangCreateManyLanguagesInputEnvelope
    connect?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
  }

  export type QuizzesLangCreateNestedManyWithoutLanguagesInput = {
    create?: XOR<QuizzesLangCreateWithoutLanguagesInput, QuizzesLangUncheckedCreateWithoutLanguagesInput> | QuizzesLangCreateWithoutLanguagesInput[] | QuizzesLangUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: QuizzesLangCreateOrConnectWithoutLanguagesInput | QuizzesLangCreateOrConnectWithoutLanguagesInput[]
    createMany?: QuizzesLangCreateManyLanguagesInputEnvelope
    connect?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
  }

  export type ChoicesLangUncheckedCreateNestedManyWithoutLanguagesInput = {
    create?: XOR<ChoicesLangCreateWithoutLanguagesInput, ChoicesLangUncheckedCreateWithoutLanguagesInput> | ChoicesLangCreateWithoutLanguagesInput[] | ChoicesLangUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: ChoicesLangCreateOrConnectWithoutLanguagesInput | ChoicesLangCreateOrConnectWithoutLanguagesInput[]
    createMany?: ChoicesLangCreateManyLanguagesInputEnvelope
    connect?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
  }

  export type GroupsLangUncheckedCreateNestedManyWithoutLanguagesInput = {
    create?: XOR<GroupsLangCreateWithoutLanguagesInput, GroupsLangUncheckedCreateWithoutLanguagesInput> | GroupsLangCreateWithoutLanguagesInput[] | GroupsLangUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: GroupsLangCreateOrConnectWithoutLanguagesInput | GroupsLangCreateOrConnectWithoutLanguagesInput[]
    createMany?: GroupsLangCreateManyLanguagesInputEnvelope
    connect?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
  }

  export type LicensesLangUncheckedCreateNestedManyWithoutLanguagesInput = {
    create?: XOR<LicensesLangCreateWithoutLanguagesInput, LicensesLangUncheckedCreateWithoutLanguagesInput> | LicensesLangCreateWithoutLanguagesInput[] | LicensesLangUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: LicensesLangCreateOrConnectWithoutLanguagesInput | LicensesLangCreateOrConnectWithoutLanguagesInput[]
    createMany?: LicensesLangCreateManyLanguagesInputEnvelope
    connect?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
  }

  export type QuestionsLangUncheckedCreateNestedManyWithoutLanguagesInput = {
    create?: XOR<QuestionsLangCreateWithoutLanguagesInput, QuestionsLangUncheckedCreateWithoutLanguagesInput> | QuestionsLangCreateWithoutLanguagesInput[] | QuestionsLangUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: QuestionsLangCreateOrConnectWithoutLanguagesInput | QuestionsLangCreateOrConnectWithoutLanguagesInput[]
    createMany?: QuestionsLangCreateManyLanguagesInputEnvelope
    connect?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
  }

  export type QuizzesLangUncheckedCreateNestedManyWithoutLanguagesInput = {
    create?: XOR<QuizzesLangCreateWithoutLanguagesInput, QuizzesLangUncheckedCreateWithoutLanguagesInput> | QuizzesLangCreateWithoutLanguagesInput[] | QuizzesLangUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: QuizzesLangCreateOrConnectWithoutLanguagesInput | QuizzesLangCreateOrConnectWithoutLanguagesInput[]
    createMany?: QuizzesLangCreateManyLanguagesInputEnvelope
    connect?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
  }

  export type ChoicesLangUpdateManyWithoutLanguagesNestedInput = {
    create?: XOR<ChoicesLangCreateWithoutLanguagesInput, ChoicesLangUncheckedCreateWithoutLanguagesInput> | ChoicesLangCreateWithoutLanguagesInput[] | ChoicesLangUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: ChoicesLangCreateOrConnectWithoutLanguagesInput | ChoicesLangCreateOrConnectWithoutLanguagesInput[]
    upsert?: ChoicesLangUpsertWithWhereUniqueWithoutLanguagesInput | ChoicesLangUpsertWithWhereUniqueWithoutLanguagesInput[]
    createMany?: ChoicesLangCreateManyLanguagesInputEnvelope
    set?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
    disconnect?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
    delete?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
    connect?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
    update?: ChoicesLangUpdateWithWhereUniqueWithoutLanguagesInput | ChoicesLangUpdateWithWhereUniqueWithoutLanguagesInput[]
    updateMany?: ChoicesLangUpdateManyWithWhereWithoutLanguagesInput | ChoicesLangUpdateManyWithWhereWithoutLanguagesInput[]
    deleteMany?: ChoicesLangScalarWhereInput | ChoicesLangScalarWhereInput[]
  }

  export type GroupsLangUpdateManyWithoutLanguagesNestedInput = {
    create?: XOR<GroupsLangCreateWithoutLanguagesInput, GroupsLangUncheckedCreateWithoutLanguagesInput> | GroupsLangCreateWithoutLanguagesInput[] | GroupsLangUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: GroupsLangCreateOrConnectWithoutLanguagesInput | GroupsLangCreateOrConnectWithoutLanguagesInput[]
    upsert?: GroupsLangUpsertWithWhereUniqueWithoutLanguagesInput | GroupsLangUpsertWithWhereUniqueWithoutLanguagesInput[]
    createMany?: GroupsLangCreateManyLanguagesInputEnvelope
    set?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
    disconnect?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
    delete?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
    connect?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
    update?: GroupsLangUpdateWithWhereUniqueWithoutLanguagesInput | GroupsLangUpdateWithWhereUniqueWithoutLanguagesInput[]
    updateMany?: GroupsLangUpdateManyWithWhereWithoutLanguagesInput | GroupsLangUpdateManyWithWhereWithoutLanguagesInput[]
    deleteMany?: GroupsLangScalarWhereInput | GroupsLangScalarWhereInput[]
  }

  export type LicensesLangUpdateManyWithoutLanguagesNestedInput = {
    create?: XOR<LicensesLangCreateWithoutLanguagesInput, LicensesLangUncheckedCreateWithoutLanguagesInput> | LicensesLangCreateWithoutLanguagesInput[] | LicensesLangUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: LicensesLangCreateOrConnectWithoutLanguagesInput | LicensesLangCreateOrConnectWithoutLanguagesInput[]
    upsert?: LicensesLangUpsertWithWhereUniqueWithoutLanguagesInput | LicensesLangUpsertWithWhereUniqueWithoutLanguagesInput[]
    createMany?: LicensesLangCreateManyLanguagesInputEnvelope
    set?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
    disconnect?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
    delete?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
    connect?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
    update?: LicensesLangUpdateWithWhereUniqueWithoutLanguagesInput | LicensesLangUpdateWithWhereUniqueWithoutLanguagesInput[]
    updateMany?: LicensesLangUpdateManyWithWhereWithoutLanguagesInput | LicensesLangUpdateManyWithWhereWithoutLanguagesInput[]
    deleteMany?: LicensesLangScalarWhereInput | LicensesLangScalarWhereInput[]
  }

  export type QuestionsLangUpdateManyWithoutLanguagesNestedInput = {
    create?: XOR<QuestionsLangCreateWithoutLanguagesInput, QuestionsLangUncheckedCreateWithoutLanguagesInput> | QuestionsLangCreateWithoutLanguagesInput[] | QuestionsLangUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: QuestionsLangCreateOrConnectWithoutLanguagesInput | QuestionsLangCreateOrConnectWithoutLanguagesInput[]
    upsert?: QuestionsLangUpsertWithWhereUniqueWithoutLanguagesInput | QuestionsLangUpsertWithWhereUniqueWithoutLanguagesInput[]
    createMany?: QuestionsLangCreateManyLanguagesInputEnvelope
    set?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
    disconnect?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
    delete?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
    connect?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
    update?: QuestionsLangUpdateWithWhereUniqueWithoutLanguagesInput | QuestionsLangUpdateWithWhereUniqueWithoutLanguagesInput[]
    updateMany?: QuestionsLangUpdateManyWithWhereWithoutLanguagesInput | QuestionsLangUpdateManyWithWhereWithoutLanguagesInput[]
    deleteMany?: QuestionsLangScalarWhereInput | QuestionsLangScalarWhereInput[]
  }

  export type QuizzesLangUpdateManyWithoutLanguagesNestedInput = {
    create?: XOR<QuizzesLangCreateWithoutLanguagesInput, QuizzesLangUncheckedCreateWithoutLanguagesInput> | QuizzesLangCreateWithoutLanguagesInput[] | QuizzesLangUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: QuizzesLangCreateOrConnectWithoutLanguagesInput | QuizzesLangCreateOrConnectWithoutLanguagesInput[]
    upsert?: QuizzesLangUpsertWithWhereUniqueWithoutLanguagesInput | QuizzesLangUpsertWithWhereUniqueWithoutLanguagesInput[]
    createMany?: QuizzesLangCreateManyLanguagesInputEnvelope
    set?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
    disconnect?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
    delete?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
    connect?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
    update?: QuizzesLangUpdateWithWhereUniqueWithoutLanguagesInput | QuizzesLangUpdateWithWhereUniqueWithoutLanguagesInput[]
    updateMany?: QuizzesLangUpdateManyWithWhereWithoutLanguagesInput | QuizzesLangUpdateManyWithWhereWithoutLanguagesInput[]
    deleteMany?: QuizzesLangScalarWhereInput | QuizzesLangScalarWhereInput[]
  }

  export type ChoicesLangUncheckedUpdateManyWithoutLanguagesNestedInput = {
    create?: XOR<ChoicesLangCreateWithoutLanguagesInput, ChoicesLangUncheckedCreateWithoutLanguagesInput> | ChoicesLangCreateWithoutLanguagesInput[] | ChoicesLangUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: ChoicesLangCreateOrConnectWithoutLanguagesInput | ChoicesLangCreateOrConnectWithoutLanguagesInput[]
    upsert?: ChoicesLangUpsertWithWhereUniqueWithoutLanguagesInput | ChoicesLangUpsertWithWhereUniqueWithoutLanguagesInput[]
    createMany?: ChoicesLangCreateManyLanguagesInputEnvelope
    set?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
    disconnect?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
    delete?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
    connect?: ChoicesLangWhereUniqueInput | ChoicesLangWhereUniqueInput[]
    update?: ChoicesLangUpdateWithWhereUniqueWithoutLanguagesInput | ChoicesLangUpdateWithWhereUniqueWithoutLanguagesInput[]
    updateMany?: ChoicesLangUpdateManyWithWhereWithoutLanguagesInput | ChoicesLangUpdateManyWithWhereWithoutLanguagesInput[]
    deleteMany?: ChoicesLangScalarWhereInput | ChoicesLangScalarWhereInput[]
  }

  export type GroupsLangUncheckedUpdateManyWithoutLanguagesNestedInput = {
    create?: XOR<GroupsLangCreateWithoutLanguagesInput, GroupsLangUncheckedCreateWithoutLanguagesInput> | GroupsLangCreateWithoutLanguagesInput[] | GroupsLangUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: GroupsLangCreateOrConnectWithoutLanguagesInput | GroupsLangCreateOrConnectWithoutLanguagesInput[]
    upsert?: GroupsLangUpsertWithWhereUniqueWithoutLanguagesInput | GroupsLangUpsertWithWhereUniqueWithoutLanguagesInput[]
    createMany?: GroupsLangCreateManyLanguagesInputEnvelope
    set?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
    disconnect?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
    delete?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
    connect?: GroupsLangWhereUniqueInput | GroupsLangWhereUniqueInput[]
    update?: GroupsLangUpdateWithWhereUniqueWithoutLanguagesInput | GroupsLangUpdateWithWhereUniqueWithoutLanguagesInput[]
    updateMany?: GroupsLangUpdateManyWithWhereWithoutLanguagesInput | GroupsLangUpdateManyWithWhereWithoutLanguagesInput[]
    deleteMany?: GroupsLangScalarWhereInput | GroupsLangScalarWhereInput[]
  }

  export type LicensesLangUncheckedUpdateManyWithoutLanguagesNestedInput = {
    create?: XOR<LicensesLangCreateWithoutLanguagesInput, LicensesLangUncheckedCreateWithoutLanguagesInput> | LicensesLangCreateWithoutLanguagesInput[] | LicensesLangUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: LicensesLangCreateOrConnectWithoutLanguagesInput | LicensesLangCreateOrConnectWithoutLanguagesInput[]
    upsert?: LicensesLangUpsertWithWhereUniqueWithoutLanguagesInput | LicensesLangUpsertWithWhereUniqueWithoutLanguagesInput[]
    createMany?: LicensesLangCreateManyLanguagesInputEnvelope
    set?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
    disconnect?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
    delete?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
    connect?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
    update?: LicensesLangUpdateWithWhereUniqueWithoutLanguagesInput | LicensesLangUpdateWithWhereUniqueWithoutLanguagesInput[]
    updateMany?: LicensesLangUpdateManyWithWhereWithoutLanguagesInput | LicensesLangUpdateManyWithWhereWithoutLanguagesInput[]
    deleteMany?: LicensesLangScalarWhereInput | LicensesLangScalarWhereInput[]
  }

  export type QuestionsLangUncheckedUpdateManyWithoutLanguagesNestedInput = {
    create?: XOR<QuestionsLangCreateWithoutLanguagesInput, QuestionsLangUncheckedCreateWithoutLanguagesInput> | QuestionsLangCreateWithoutLanguagesInput[] | QuestionsLangUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: QuestionsLangCreateOrConnectWithoutLanguagesInput | QuestionsLangCreateOrConnectWithoutLanguagesInput[]
    upsert?: QuestionsLangUpsertWithWhereUniqueWithoutLanguagesInput | QuestionsLangUpsertWithWhereUniqueWithoutLanguagesInput[]
    createMany?: QuestionsLangCreateManyLanguagesInputEnvelope
    set?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
    disconnect?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
    delete?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
    connect?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
    update?: QuestionsLangUpdateWithWhereUniqueWithoutLanguagesInput | QuestionsLangUpdateWithWhereUniqueWithoutLanguagesInput[]
    updateMany?: QuestionsLangUpdateManyWithWhereWithoutLanguagesInput | QuestionsLangUpdateManyWithWhereWithoutLanguagesInput[]
    deleteMany?: QuestionsLangScalarWhereInput | QuestionsLangScalarWhereInput[]
  }

  export type QuizzesLangUncheckedUpdateManyWithoutLanguagesNestedInput = {
    create?: XOR<QuizzesLangCreateWithoutLanguagesInput, QuizzesLangUncheckedCreateWithoutLanguagesInput> | QuizzesLangCreateWithoutLanguagesInput[] | QuizzesLangUncheckedCreateWithoutLanguagesInput[]
    connectOrCreate?: QuizzesLangCreateOrConnectWithoutLanguagesInput | QuizzesLangCreateOrConnectWithoutLanguagesInput[]
    upsert?: QuizzesLangUpsertWithWhereUniqueWithoutLanguagesInput | QuizzesLangUpsertWithWhereUniqueWithoutLanguagesInput[]
    createMany?: QuizzesLangCreateManyLanguagesInputEnvelope
    set?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
    disconnect?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
    delete?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
    connect?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
    update?: QuizzesLangUpdateWithWhereUniqueWithoutLanguagesInput | QuizzesLangUpdateWithWhereUniqueWithoutLanguagesInput[]
    updateMany?: QuizzesLangUpdateManyWithWhereWithoutLanguagesInput | QuizzesLangUpdateManyWithWhereWithoutLanguagesInput[]
    deleteMany?: QuizzesLangScalarWhereInput | QuizzesLangScalarWhereInput[]
  }

  export type MediaCreateNestedOneWithoutLicensesInput = {
    create?: XOR<MediaCreateWithoutLicensesInput, MediaUncheckedCreateWithoutLicensesInput>
    connectOrCreate?: MediaCreateOrConnectWithoutLicensesInput
    connect?: MediaWhereUniqueInput
  }

  export type LicensesLangCreateNestedManyWithoutLicensesInput = {
    create?: XOR<LicensesLangCreateWithoutLicensesInput, LicensesLangUncheckedCreateWithoutLicensesInput> | LicensesLangCreateWithoutLicensesInput[] | LicensesLangUncheckedCreateWithoutLicensesInput[]
    connectOrCreate?: LicensesLangCreateOrConnectWithoutLicensesInput | LicensesLangCreateOrConnectWithoutLicensesInput[]
    createMany?: LicensesLangCreateManyLicensesInputEnvelope
    connect?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
  }

  export type RelationsCreateNestedManyWithoutLicensesInput = {
    create?: XOR<RelationsCreateWithoutLicensesInput, RelationsUncheckedCreateWithoutLicensesInput> | RelationsCreateWithoutLicensesInput[] | RelationsUncheckedCreateWithoutLicensesInput[]
    connectOrCreate?: RelationsCreateOrConnectWithoutLicensesInput | RelationsCreateOrConnectWithoutLicensesInput[]
    createMany?: RelationsCreateManyLicensesInputEnvelope
    connect?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
  }

  export type LicensesLangUncheckedCreateNestedManyWithoutLicensesInput = {
    create?: XOR<LicensesLangCreateWithoutLicensesInput, LicensesLangUncheckedCreateWithoutLicensesInput> | LicensesLangCreateWithoutLicensesInput[] | LicensesLangUncheckedCreateWithoutLicensesInput[]
    connectOrCreate?: LicensesLangCreateOrConnectWithoutLicensesInput | LicensesLangCreateOrConnectWithoutLicensesInput[]
    createMany?: LicensesLangCreateManyLicensesInputEnvelope
    connect?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
  }

  export type RelationsUncheckedCreateNestedManyWithoutLicensesInput = {
    create?: XOR<RelationsCreateWithoutLicensesInput, RelationsUncheckedCreateWithoutLicensesInput> | RelationsCreateWithoutLicensesInput[] | RelationsUncheckedCreateWithoutLicensesInput[]
    connectOrCreate?: RelationsCreateOrConnectWithoutLicensesInput | RelationsCreateOrConnectWithoutLicensesInput[]
    createMany?: RelationsCreateManyLicensesInputEnvelope
    connect?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
  }

  export type MediaUpdateOneWithoutLicensesNestedInput = {
    create?: XOR<MediaCreateWithoutLicensesInput, MediaUncheckedCreateWithoutLicensesInput>
    connectOrCreate?: MediaCreateOrConnectWithoutLicensesInput
    upsert?: MediaUpsertWithoutLicensesInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutLicensesInput, MediaUpdateWithoutLicensesInput>, MediaUncheckedUpdateWithoutLicensesInput>
  }

  export type LicensesLangUpdateManyWithoutLicensesNestedInput = {
    create?: XOR<LicensesLangCreateWithoutLicensesInput, LicensesLangUncheckedCreateWithoutLicensesInput> | LicensesLangCreateWithoutLicensesInput[] | LicensesLangUncheckedCreateWithoutLicensesInput[]
    connectOrCreate?: LicensesLangCreateOrConnectWithoutLicensesInput | LicensesLangCreateOrConnectWithoutLicensesInput[]
    upsert?: LicensesLangUpsertWithWhereUniqueWithoutLicensesInput | LicensesLangUpsertWithWhereUniqueWithoutLicensesInput[]
    createMany?: LicensesLangCreateManyLicensesInputEnvelope
    set?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
    disconnect?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
    delete?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
    connect?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
    update?: LicensesLangUpdateWithWhereUniqueWithoutLicensesInput | LicensesLangUpdateWithWhereUniqueWithoutLicensesInput[]
    updateMany?: LicensesLangUpdateManyWithWhereWithoutLicensesInput | LicensesLangUpdateManyWithWhereWithoutLicensesInput[]
    deleteMany?: LicensesLangScalarWhereInput | LicensesLangScalarWhereInput[]
  }

  export type RelationsUpdateManyWithoutLicensesNestedInput = {
    create?: XOR<RelationsCreateWithoutLicensesInput, RelationsUncheckedCreateWithoutLicensesInput> | RelationsCreateWithoutLicensesInput[] | RelationsUncheckedCreateWithoutLicensesInput[]
    connectOrCreate?: RelationsCreateOrConnectWithoutLicensesInput | RelationsCreateOrConnectWithoutLicensesInput[]
    upsert?: RelationsUpsertWithWhereUniqueWithoutLicensesInput | RelationsUpsertWithWhereUniqueWithoutLicensesInput[]
    createMany?: RelationsCreateManyLicensesInputEnvelope
    set?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
    disconnect?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
    delete?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
    connect?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
    update?: RelationsUpdateWithWhereUniqueWithoutLicensesInput | RelationsUpdateWithWhereUniqueWithoutLicensesInput[]
    updateMany?: RelationsUpdateManyWithWhereWithoutLicensesInput | RelationsUpdateManyWithWhereWithoutLicensesInput[]
    deleteMany?: RelationsScalarWhereInput | RelationsScalarWhereInput[]
  }

  export type LicensesLangUncheckedUpdateManyWithoutLicensesNestedInput = {
    create?: XOR<LicensesLangCreateWithoutLicensesInput, LicensesLangUncheckedCreateWithoutLicensesInput> | LicensesLangCreateWithoutLicensesInput[] | LicensesLangUncheckedCreateWithoutLicensesInput[]
    connectOrCreate?: LicensesLangCreateOrConnectWithoutLicensesInput | LicensesLangCreateOrConnectWithoutLicensesInput[]
    upsert?: LicensesLangUpsertWithWhereUniqueWithoutLicensesInput | LicensesLangUpsertWithWhereUniqueWithoutLicensesInput[]
    createMany?: LicensesLangCreateManyLicensesInputEnvelope
    set?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
    disconnect?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
    delete?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
    connect?: LicensesLangWhereUniqueInput | LicensesLangWhereUniqueInput[]
    update?: LicensesLangUpdateWithWhereUniqueWithoutLicensesInput | LicensesLangUpdateWithWhereUniqueWithoutLicensesInput[]
    updateMany?: LicensesLangUpdateManyWithWhereWithoutLicensesInput | LicensesLangUpdateManyWithWhereWithoutLicensesInput[]
    deleteMany?: LicensesLangScalarWhereInput | LicensesLangScalarWhereInput[]
  }

  export type RelationsUncheckedUpdateManyWithoutLicensesNestedInput = {
    create?: XOR<RelationsCreateWithoutLicensesInput, RelationsUncheckedCreateWithoutLicensesInput> | RelationsCreateWithoutLicensesInput[] | RelationsUncheckedCreateWithoutLicensesInput[]
    connectOrCreate?: RelationsCreateOrConnectWithoutLicensesInput | RelationsCreateOrConnectWithoutLicensesInput[]
    upsert?: RelationsUpsertWithWhereUniqueWithoutLicensesInput | RelationsUpsertWithWhereUniqueWithoutLicensesInput[]
    createMany?: RelationsCreateManyLicensesInputEnvelope
    set?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
    disconnect?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
    delete?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
    connect?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
    update?: RelationsUpdateWithWhereUniqueWithoutLicensesInput | RelationsUpdateWithWhereUniqueWithoutLicensesInput[]
    updateMany?: RelationsUpdateManyWithWhereWithoutLicensesInput | RelationsUpdateManyWithWhereWithoutLicensesInput[]
    deleteMany?: RelationsScalarWhereInput | RelationsScalarWhereInput[]
  }

  export type LicensesCreateNestedOneWithoutLicensesLangInput = {
    create?: XOR<LicensesCreateWithoutLicensesLangInput, LicensesUncheckedCreateWithoutLicensesLangInput>
    connectOrCreate?: LicensesCreateOrConnectWithoutLicensesLangInput
    connect?: LicensesWhereUniqueInput
  }

  export type LanguagesCreateNestedOneWithoutLicensesLangInput = {
    create?: XOR<LanguagesCreateWithoutLicensesLangInput, LanguagesUncheckedCreateWithoutLicensesLangInput>
    connectOrCreate?: LanguagesCreateOrConnectWithoutLicensesLangInput
    connect?: LanguagesWhereUniqueInput
  }

  export type AudioCreateNestedOneWithoutLicensesLangInput = {
    create?: XOR<AudioCreateWithoutLicensesLangInput, AudioUncheckedCreateWithoutLicensesLangInput>
    connectOrCreate?: AudioCreateOrConnectWithoutLicensesLangInput
    connect?: AudioWhereUniqueInput
  }

  export type LicensesUpdateOneRequiredWithoutLicensesLangNestedInput = {
    create?: XOR<LicensesCreateWithoutLicensesLangInput, LicensesUncheckedCreateWithoutLicensesLangInput>
    connectOrCreate?: LicensesCreateOrConnectWithoutLicensesLangInput
    upsert?: LicensesUpsertWithoutLicensesLangInput
    connect?: LicensesWhereUniqueInput
    update?: XOR<XOR<LicensesUpdateToOneWithWhereWithoutLicensesLangInput, LicensesUpdateWithoutLicensesLangInput>, LicensesUncheckedUpdateWithoutLicensesLangInput>
  }

  export type LanguagesUpdateOneRequiredWithoutLicensesLangNestedInput = {
    create?: XOR<LanguagesCreateWithoutLicensesLangInput, LanguagesUncheckedCreateWithoutLicensesLangInput>
    connectOrCreate?: LanguagesCreateOrConnectWithoutLicensesLangInput
    upsert?: LanguagesUpsertWithoutLicensesLangInput
    connect?: LanguagesWhereUniqueInput
    update?: XOR<XOR<LanguagesUpdateToOneWithWhereWithoutLicensesLangInput, LanguagesUpdateWithoutLicensesLangInput>, LanguagesUncheckedUpdateWithoutLicensesLangInput>
  }

  export type AudioUpdateOneWithoutLicensesLangNestedInput = {
    create?: XOR<AudioCreateWithoutLicensesLangInput, AudioUncheckedCreateWithoutLicensesLangInput>
    connectOrCreate?: AudioCreateOrConnectWithoutLicensesLangInput
    upsert?: AudioUpsertWithoutLicensesLangInput
    disconnect?: AudioWhereInput | boolean
    delete?: AudioWhereInput | boolean
    connect?: AudioWhereUniqueInput
    update?: XOR<XOR<AudioUpdateToOneWithWhereWithoutLicensesLangInput, AudioUpdateWithoutLicensesLangInput>, AudioUncheckedUpdateWithoutLicensesLangInput>
  }

  export type GroupsCreateNestedManyWithoutMediaInput = {
    create?: XOR<GroupsCreateWithoutMediaInput, GroupsUncheckedCreateWithoutMediaInput> | GroupsCreateWithoutMediaInput[] | GroupsUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: GroupsCreateOrConnectWithoutMediaInput | GroupsCreateOrConnectWithoutMediaInput[]
    createMany?: GroupsCreateManyMediaInputEnvelope
    connect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
  }

  export type LicensesCreateNestedManyWithoutMediaInput = {
    create?: XOR<LicensesCreateWithoutMediaInput, LicensesUncheckedCreateWithoutMediaInput> | LicensesCreateWithoutMediaInput[] | LicensesUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: LicensesCreateOrConnectWithoutMediaInput | LicensesCreateOrConnectWithoutMediaInput[]
    createMany?: LicensesCreateManyMediaInputEnvelope
    connect?: LicensesWhereUniqueInput | LicensesWhereUniqueInput[]
  }

  export type RelationsChoicesCreateNestedManyWithoutMediaInput = {
    create?: XOR<RelationsChoicesCreateWithoutMediaInput, RelationsChoicesUncheckedCreateWithoutMediaInput> | RelationsChoicesCreateWithoutMediaInput[] | RelationsChoicesUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: RelationsChoicesCreateOrConnectWithoutMediaInput | RelationsChoicesCreateOrConnectWithoutMediaInput[]
    createMany?: RelationsChoicesCreateManyMediaInputEnvelope
    connect?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
  }

  export type RelationsQuestionsCreateNestedManyWithoutMediaInput = {
    create?: XOR<RelationsQuestionsCreateWithoutMediaInput, RelationsQuestionsUncheckedCreateWithoutMediaInput> | RelationsQuestionsCreateWithoutMediaInput[] | RelationsQuestionsUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: RelationsQuestionsCreateOrConnectWithoutMediaInput | RelationsQuestionsCreateOrConnectWithoutMediaInput[]
    createMany?: RelationsQuestionsCreateManyMediaInputEnvelope
    connect?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
  }

  export type QuizzesCreateNestedManyWithoutMediaInput = {
    create?: XOR<QuizzesCreateWithoutMediaInput, QuizzesUncheckedCreateWithoutMediaInput> | QuizzesCreateWithoutMediaInput[] | QuizzesUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: QuizzesCreateOrConnectWithoutMediaInput | QuizzesCreateOrConnectWithoutMediaInput[]
    createMany?: QuizzesCreateManyMediaInputEnvelope
    connect?: QuizzesWhereUniqueInput | QuizzesWhereUniqueInput[]
  }

  export type GroupsUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<GroupsCreateWithoutMediaInput, GroupsUncheckedCreateWithoutMediaInput> | GroupsCreateWithoutMediaInput[] | GroupsUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: GroupsCreateOrConnectWithoutMediaInput | GroupsCreateOrConnectWithoutMediaInput[]
    createMany?: GroupsCreateManyMediaInputEnvelope
    connect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
  }

  export type LicensesUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<LicensesCreateWithoutMediaInput, LicensesUncheckedCreateWithoutMediaInput> | LicensesCreateWithoutMediaInput[] | LicensesUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: LicensesCreateOrConnectWithoutMediaInput | LicensesCreateOrConnectWithoutMediaInput[]
    createMany?: LicensesCreateManyMediaInputEnvelope
    connect?: LicensesWhereUniqueInput | LicensesWhereUniqueInput[]
  }

  export type RelationsChoicesUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<RelationsChoicesCreateWithoutMediaInput, RelationsChoicesUncheckedCreateWithoutMediaInput> | RelationsChoicesCreateWithoutMediaInput[] | RelationsChoicesUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: RelationsChoicesCreateOrConnectWithoutMediaInput | RelationsChoicesCreateOrConnectWithoutMediaInput[]
    createMany?: RelationsChoicesCreateManyMediaInputEnvelope
    connect?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
  }

  export type RelationsQuestionsUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<RelationsQuestionsCreateWithoutMediaInput, RelationsQuestionsUncheckedCreateWithoutMediaInput> | RelationsQuestionsCreateWithoutMediaInput[] | RelationsQuestionsUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: RelationsQuestionsCreateOrConnectWithoutMediaInput | RelationsQuestionsCreateOrConnectWithoutMediaInput[]
    createMany?: RelationsQuestionsCreateManyMediaInputEnvelope
    connect?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
  }

  export type QuizzesUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<QuizzesCreateWithoutMediaInput, QuizzesUncheckedCreateWithoutMediaInput> | QuizzesCreateWithoutMediaInput[] | QuizzesUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: QuizzesCreateOrConnectWithoutMediaInput | QuizzesCreateOrConnectWithoutMediaInput[]
    createMany?: QuizzesCreateManyMediaInputEnvelope
    connect?: QuizzesWhereUniqueInput | QuizzesWhereUniqueInput[]
  }

  export type GroupsUpdateManyWithoutMediaNestedInput = {
    create?: XOR<GroupsCreateWithoutMediaInput, GroupsUncheckedCreateWithoutMediaInput> | GroupsCreateWithoutMediaInput[] | GroupsUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: GroupsCreateOrConnectWithoutMediaInput | GroupsCreateOrConnectWithoutMediaInput[]
    upsert?: GroupsUpsertWithWhereUniqueWithoutMediaInput | GroupsUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: GroupsCreateManyMediaInputEnvelope
    set?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    disconnect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    delete?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    connect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    update?: GroupsUpdateWithWhereUniqueWithoutMediaInput | GroupsUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: GroupsUpdateManyWithWhereWithoutMediaInput | GroupsUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: GroupsScalarWhereInput | GroupsScalarWhereInput[]
  }

  export type LicensesUpdateManyWithoutMediaNestedInput = {
    create?: XOR<LicensesCreateWithoutMediaInput, LicensesUncheckedCreateWithoutMediaInput> | LicensesCreateWithoutMediaInput[] | LicensesUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: LicensesCreateOrConnectWithoutMediaInput | LicensesCreateOrConnectWithoutMediaInput[]
    upsert?: LicensesUpsertWithWhereUniqueWithoutMediaInput | LicensesUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: LicensesCreateManyMediaInputEnvelope
    set?: LicensesWhereUniqueInput | LicensesWhereUniqueInput[]
    disconnect?: LicensesWhereUniqueInput | LicensesWhereUniqueInput[]
    delete?: LicensesWhereUniqueInput | LicensesWhereUniqueInput[]
    connect?: LicensesWhereUniqueInput | LicensesWhereUniqueInput[]
    update?: LicensesUpdateWithWhereUniqueWithoutMediaInput | LicensesUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: LicensesUpdateManyWithWhereWithoutMediaInput | LicensesUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: LicensesScalarWhereInput | LicensesScalarWhereInput[]
  }

  export type RelationsChoicesUpdateManyWithoutMediaNestedInput = {
    create?: XOR<RelationsChoicesCreateWithoutMediaInput, RelationsChoicesUncheckedCreateWithoutMediaInput> | RelationsChoicesCreateWithoutMediaInput[] | RelationsChoicesUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: RelationsChoicesCreateOrConnectWithoutMediaInput | RelationsChoicesCreateOrConnectWithoutMediaInput[]
    upsert?: RelationsChoicesUpsertWithWhereUniqueWithoutMediaInput | RelationsChoicesUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: RelationsChoicesCreateManyMediaInputEnvelope
    set?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    disconnect?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    delete?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    connect?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    update?: RelationsChoicesUpdateWithWhereUniqueWithoutMediaInput | RelationsChoicesUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: RelationsChoicesUpdateManyWithWhereWithoutMediaInput | RelationsChoicesUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: RelationsChoicesScalarWhereInput | RelationsChoicesScalarWhereInput[]
  }

  export type RelationsQuestionsUpdateManyWithoutMediaNestedInput = {
    create?: XOR<RelationsQuestionsCreateWithoutMediaInput, RelationsQuestionsUncheckedCreateWithoutMediaInput> | RelationsQuestionsCreateWithoutMediaInput[] | RelationsQuestionsUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: RelationsQuestionsCreateOrConnectWithoutMediaInput | RelationsQuestionsCreateOrConnectWithoutMediaInput[]
    upsert?: RelationsQuestionsUpsertWithWhereUniqueWithoutMediaInput | RelationsQuestionsUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: RelationsQuestionsCreateManyMediaInputEnvelope
    set?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
    disconnect?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
    delete?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
    connect?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
    update?: RelationsQuestionsUpdateWithWhereUniqueWithoutMediaInput | RelationsQuestionsUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: RelationsQuestionsUpdateManyWithWhereWithoutMediaInput | RelationsQuestionsUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: RelationsQuestionsScalarWhereInput | RelationsQuestionsScalarWhereInput[]
  }

  export type QuizzesUpdateManyWithoutMediaNestedInput = {
    create?: XOR<QuizzesCreateWithoutMediaInput, QuizzesUncheckedCreateWithoutMediaInput> | QuizzesCreateWithoutMediaInput[] | QuizzesUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: QuizzesCreateOrConnectWithoutMediaInput | QuizzesCreateOrConnectWithoutMediaInput[]
    upsert?: QuizzesUpsertWithWhereUniqueWithoutMediaInput | QuizzesUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: QuizzesCreateManyMediaInputEnvelope
    set?: QuizzesWhereUniqueInput | QuizzesWhereUniqueInput[]
    disconnect?: QuizzesWhereUniqueInput | QuizzesWhereUniqueInput[]
    delete?: QuizzesWhereUniqueInput | QuizzesWhereUniqueInput[]
    connect?: QuizzesWhereUniqueInput | QuizzesWhereUniqueInput[]
    update?: QuizzesUpdateWithWhereUniqueWithoutMediaInput | QuizzesUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: QuizzesUpdateManyWithWhereWithoutMediaInput | QuizzesUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: QuizzesScalarWhereInput | QuizzesScalarWhereInput[]
  }

  export type GroupsUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<GroupsCreateWithoutMediaInput, GroupsUncheckedCreateWithoutMediaInput> | GroupsCreateWithoutMediaInput[] | GroupsUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: GroupsCreateOrConnectWithoutMediaInput | GroupsCreateOrConnectWithoutMediaInput[]
    upsert?: GroupsUpsertWithWhereUniqueWithoutMediaInput | GroupsUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: GroupsCreateManyMediaInputEnvelope
    set?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    disconnect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    delete?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    connect?: GroupsWhereUniqueInput | GroupsWhereUniqueInput[]
    update?: GroupsUpdateWithWhereUniqueWithoutMediaInput | GroupsUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: GroupsUpdateManyWithWhereWithoutMediaInput | GroupsUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: GroupsScalarWhereInput | GroupsScalarWhereInput[]
  }

  export type LicensesUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<LicensesCreateWithoutMediaInput, LicensesUncheckedCreateWithoutMediaInput> | LicensesCreateWithoutMediaInput[] | LicensesUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: LicensesCreateOrConnectWithoutMediaInput | LicensesCreateOrConnectWithoutMediaInput[]
    upsert?: LicensesUpsertWithWhereUniqueWithoutMediaInput | LicensesUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: LicensesCreateManyMediaInputEnvelope
    set?: LicensesWhereUniqueInput | LicensesWhereUniqueInput[]
    disconnect?: LicensesWhereUniqueInput | LicensesWhereUniqueInput[]
    delete?: LicensesWhereUniqueInput | LicensesWhereUniqueInput[]
    connect?: LicensesWhereUniqueInput | LicensesWhereUniqueInput[]
    update?: LicensesUpdateWithWhereUniqueWithoutMediaInput | LicensesUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: LicensesUpdateManyWithWhereWithoutMediaInput | LicensesUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: LicensesScalarWhereInput | LicensesScalarWhereInput[]
  }

  export type RelationsChoicesUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<RelationsChoicesCreateWithoutMediaInput, RelationsChoicesUncheckedCreateWithoutMediaInput> | RelationsChoicesCreateWithoutMediaInput[] | RelationsChoicesUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: RelationsChoicesCreateOrConnectWithoutMediaInput | RelationsChoicesCreateOrConnectWithoutMediaInput[]
    upsert?: RelationsChoicesUpsertWithWhereUniqueWithoutMediaInput | RelationsChoicesUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: RelationsChoicesCreateManyMediaInputEnvelope
    set?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    disconnect?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    delete?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    connect?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    update?: RelationsChoicesUpdateWithWhereUniqueWithoutMediaInput | RelationsChoicesUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: RelationsChoicesUpdateManyWithWhereWithoutMediaInput | RelationsChoicesUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: RelationsChoicesScalarWhereInput | RelationsChoicesScalarWhereInput[]
  }

  export type RelationsQuestionsUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<RelationsQuestionsCreateWithoutMediaInput, RelationsQuestionsUncheckedCreateWithoutMediaInput> | RelationsQuestionsCreateWithoutMediaInput[] | RelationsQuestionsUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: RelationsQuestionsCreateOrConnectWithoutMediaInput | RelationsQuestionsCreateOrConnectWithoutMediaInput[]
    upsert?: RelationsQuestionsUpsertWithWhereUniqueWithoutMediaInput | RelationsQuestionsUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: RelationsQuestionsCreateManyMediaInputEnvelope
    set?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
    disconnect?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
    delete?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
    connect?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
    update?: RelationsQuestionsUpdateWithWhereUniqueWithoutMediaInput | RelationsQuestionsUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: RelationsQuestionsUpdateManyWithWhereWithoutMediaInput | RelationsQuestionsUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: RelationsQuestionsScalarWhereInput | RelationsQuestionsScalarWhereInput[]
  }

  export type QuizzesUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<QuizzesCreateWithoutMediaInput, QuizzesUncheckedCreateWithoutMediaInput> | QuizzesCreateWithoutMediaInput[] | QuizzesUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: QuizzesCreateOrConnectWithoutMediaInput | QuizzesCreateOrConnectWithoutMediaInput[]
    upsert?: QuizzesUpsertWithWhereUniqueWithoutMediaInput | QuizzesUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: QuizzesCreateManyMediaInputEnvelope
    set?: QuizzesWhereUniqueInput | QuizzesWhereUniqueInput[]
    disconnect?: QuizzesWhereUniqueInput | QuizzesWhereUniqueInput[]
    delete?: QuizzesWhereUniqueInput | QuizzesWhereUniqueInput[]
    connect?: QuizzesWhereUniqueInput | QuizzesWhereUniqueInput[]
    update?: QuizzesUpdateWithWhereUniqueWithoutMediaInput | QuizzesUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: QuizzesUpdateManyWithWhereWithoutMediaInput | QuizzesUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: QuizzesScalarWhereInput | QuizzesScalarWhereInput[]
  }

  export type QuestionsLangCreateNestedManyWithoutQuestionsInput = {
    create?: XOR<QuestionsLangCreateWithoutQuestionsInput, QuestionsLangUncheckedCreateWithoutQuestionsInput> | QuestionsLangCreateWithoutQuestionsInput[] | QuestionsLangUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: QuestionsLangCreateOrConnectWithoutQuestionsInput | QuestionsLangCreateOrConnectWithoutQuestionsInput[]
    createMany?: QuestionsLangCreateManyQuestionsInputEnvelope
    connect?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
  }

  export type RelationsQuestionsCreateNestedManyWithoutQuestionsInput = {
    create?: XOR<RelationsQuestionsCreateWithoutQuestionsInput, RelationsQuestionsUncheckedCreateWithoutQuestionsInput> | RelationsQuestionsCreateWithoutQuestionsInput[] | RelationsQuestionsUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: RelationsQuestionsCreateOrConnectWithoutQuestionsInput | RelationsQuestionsCreateOrConnectWithoutQuestionsInput[]
    createMany?: RelationsQuestionsCreateManyQuestionsInputEnvelope
    connect?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
  }

  export type QuestionsLangUncheckedCreateNestedManyWithoutQuestionsInput = {
    create?: XOR<QuestionsLangCreateWithoutQuestionsInput, QuestionsLangUncheckedCreateWithoutQuestionsInput> | QuestionsLangCreateWithoutQuestionsInput[] | QuestionsLangUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: QuestionsLangCreateOrConnectWithoutQuestionsInput | QuestionsLangCreateOrConnectWithoutQuestionsInput[]
    createMany?: QuestionsLangCreateManyQuestionsInputEnvelope
    connect?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
  }

  export type RelationsQuestionsUncheckedCreateNestedManyWithoutQuestionsInput = {
    create?: XOR<RelationsQuestionsCreateWithoutQuestionsInput, RelationsQuestionsUncheckedCreateWithoutQuestionsInput> | RelationsQuestionsCreateWithoutQuestionsInput[] | RelationsQuestionsUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: RelationsQuestionsCreateOrConnectWithoutQuestionsInput | RelationsQuestionsCreateOrConnectWithoutQuestionsInput[]
    createMany?: RelationsQuestionsCreateManyQuestionsInputEnvelope
    connect?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
  }

  export type QuestionsLangUpdateManyWithoutQuestionsNestedInput = {
    create?: XOR<QuestionsLangCreateWithoutQuestionsInput, QuestionsLangUncheckedCreateWithoutQuestionsInput> | QuestionsLangCreateWithoutQuestionsInput[] | QuestionsLangUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: QuestionsLangCreateOrConnectWithoutQuestionsInput | QuestionsLangCreateOrConnectWithoutQuestionsInput[]
    upsert?: QuestionsLangUpsertWithWhereUniqueWithoutQuestionsInput | QuestionsLangUpsertWithWhereUniqueWithoutQuestionsInput[]
    createMany?: QuestionsLangCreateManyQuestionsInputEnvelope
    set?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
    disconnect?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
    delete?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
    connect?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
    update?: QuestionsLangUpdateWithWhereUniqueWithoutQuestionsInput | QuestionsLangUpdateWithWhereUniqueWithoutQuestionsInput[]
    updateMany?: QuestionsLangUpdateManyWithWhereWithoutQuestionsInput | QuestionsLangUpdateManyWithWhereWithoutQuestionsInput[]
    deleteMany?: QuestionsLangScalarWhereInput | QuestionsLangScalarWhereInput[]
  }

  export type RelationsQuestionsUpdateManyWithoutQuestionsNestedInput = {
    create?: XOR<RelationsQuestionsCreateWithoutQuestionsInput, RelationsQuestionsUncheckedCreateWithoutQuestionsInput> | RelationsQuestionsCreateWithoutQuestionsInput[] | RelationsQuestionsUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: RelationsQuestionsCreateOrConnectWithoutQuestionsInput | RelationsQuestionsCreateOrConnectWithoutQuestionsInput[]
    upsert?: RelationsQuestionsUpsertWithWhereUniqueWithoutQuestionsInput | RelationsQuestionsUpsertWithWhereUniqueWithoutQuestionsInput[]
    createMany?: RelationsQuestionsCreateManyQuestionsInputEnvelope
    set?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
    disconnect?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
    delete?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
    connect?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
    update?: RelationsQuestionsUpdateWithWhereUniqueWithoutQuestionsInput | RelationsQuestionsUpdateWithWhereUniqueWithoutQuestionsInput[]
    updateMany?: RelationsQuestionsUpdateManyWithWhereWithoutQuestionsInput | RelationsQuestionsUpdateManyWithWhereWithoutQuestionsInput[]
    deleteMany?: RelationsQuestionsScalarWhereInput | RelationsQuestionsScalarWhereInput[]
  }

  export type QuestionsLangUncheckedUpdateManyWithoutQuestionsNestedInput = {
    create?: XOR<QuestionsLangCreateWithoutQuestionsInput, QuestionsLangUncheckedCreateWithoutQuestionsInput> | QuestionsLangCreateWithoutQuestionsInput[] | QuestionsLangUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: QuestionsLangCreateOrConnectWithoutQuestionsInput | QuestionsLangCreateOrConnectWithoutQuestionsInput[]
    upsert?: QuestionsLangUpsertWithWhereUniqueWithoutQuestionsInput | QuestionsLangUpsertWithWhereUniqueWithoutQuestionsInput[]
    createMany?: QuestionsLangCreateManyQuestionsInputEnvelope
    set?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
    disconnect?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
    delete?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
    connect?: QuestionsLangWhereUniqueInput | QuestionsLangWhereUniqueInput[]
    update?: QuestionsLangUpdateWithWhereUniqueWithoutQuestionsInput | QuestionsLangUpdateWithWhereUniqueWithoutQuestionsInput[]
    updateMany?: QuestionsLangUpdateManyWithWhereWithoutQuestionsInput | QuestionsLangUpdateManyWithWhereWithoutQuestionsInput[]
    deleteMany?: QuestionsLangScalarWhereInput | QuestionsLangScalarWhereInput[]
  }

  export type RelationsQuestionsUncheckedUpdateManyWithoutQuestionsNestedInput = {
    create?: XOR<RelationsQuestionsCreateWithoutQuestionsInput, RelationsQuestionsUncheckedCreateWithoutQuestionsInput> | RelationsQuestionsCreateWithoutQuestionsInput[] | RelationsQuestionsUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: RelationsQuestionsCreateOrConnectWithoutQuestionsInput | RelationsQuestionsCreateOrConnectWithoutQuestionsInput[]
    upsert?: RelationsQuestionsUpsertWithWhereUniqueWithoutQuestionsInput | RelationsQuestionsUpsertWithWhereUniqueWithoutQuestionsInput[]
    createMany?: RelationsQuestionsCreateManyQuestionsInputEnvelope
    set?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
    disconnect?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
    delete?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
    connect?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
    update?: RelationsQuestionsUpdateWithWhereUniqueWithoutQuestionsInput | RelationsQuestionsUpdateWithWhereUniqueWithoutQuestionsInput[]
    updateMany?: RelationsQuestionsUpdateManyWithWhereWithoutQuestionsInput | RelationsQuestionsUpdateManyWithWhereWithoutQuestionsInput[]
    deleteMany?: RelationsQuestionsScalarWhereInput | RelationsQuestionsScalarWhereInput[]
  }

  export type QuestionsCreateNestedOneWithoutQuestionsLangInput = {
    create?: XOR<QuestionsCreateWithoutQuestionsLangInput, QuestionsUncheckedCreateWithoutQuestionsLangInput>
    connectOrCreate?: QuestionsCreateOrConnectWithoutQuestionsLangInput
    connect?: QuestionsWhereUniqueInput
  }

  export type LanguagesCreateNestedOneWithoutQuestionsLangInput = {
    create?: XOR<LanguagesCreateWithoutQuestionsLangInput, LanguagesUncheckedCreateWithoutQuestionsLangInput>
    connectOrCreate?: LanguagesCreateOrConnectWithoutQuestionsLangInput
    connect?: LanguagesWhereUniqueInput
  }

  export type AudioCreateNestedOneWithoutQuestionsLangInput = {
    create?: XOR<AudioCreateWithoutQuestionsLangInput, AudioUncheckedCreateWithoutQuestionsLangInput>
    connectOrCreate?: AudioCreateOrConnectWithoutQuestionsLangInput
    connect?: AudioWhereUniqueInput
  }

  export type QuestionsUpdateOneRequiredWithoutQuestionsLangNestedInput = {
    create?: XOR<QuestionsCreateWithoutQuestionsLangInput, QuestionsUncheckedCreateWithoutQuestionsLangInput>
    connectOrCreate?: QuestionsCreateOrConnectWithoutQuestionsLangInput
    upsert?: QuestionsUpsertWithoutQuestionsLangInput
    connect?: QuestionsWhereUniqueInput
    update?: XOR<XOR<QuestionsUpdateToOneWithWhereWithoutQuestionsLangInput, QuestionsUpdateWithoutQuestionsLangInput>, QuestionsUncheckedUpdateWithoutQuestionsLangInput>
  }

  export type LanguagesUpdateOneRequiredWithoutQuestionsLangNestedInput = {
    create?: XOR<LanguagesCreateWithoutQuestionsLangInput, LanguagesUncheckedCreateWithoutQuestionsLangInput>
    connectOrCreate?: LanguagesCreateOrConnectWithoutQuestionsLangInput
    upsert?: LanguagesUpsertWithoutQuestionsLangInput
    connect?: LanguagesWhereUniqueInput
    update?: XOR<XOR<LanguagesUpdateToOneWithWhereWithoutQuestionsLangInput, LanguagesUpdateWithoutQuestionsLangInput>, LanguagesUncheckedUpdateWithoutQuestionsLangInput>
  }

  export type AudioUpdateOneWithoutQuestionsLangNestedInput = {
    create?: XOR<AudioCreateWithoutQuestionsLangInput, AudioUncheckedCreateWithoutQuestionsLangInput>
    connectOrCreate?: AudioCreateOrConnectWithoutQuestionsLangInput
    upsert?: AudioUpsertWithoutQuestionsLangInput
    disconnect?: AudioWhereInput | boolean
    delete?: AudioWhereInput | boolean
    connect?: AudioWhereUniqueInput
    update?: XOR<XOR<AudioUpdateToOneWithWhereWithoutQuestionsLangInput, AudioUpdateWithoutQuestionsLangInput>, AudioUncheckedUpdateWithoutQuestionsLangInput>
  }

  export type MediaCreateNestedOneWithoutQuizzesInput = {
    create?: XOR<MediaCreateWithoutQuizzesInput, MediaUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: MediaCreateOrConnectWithoutQuizzesInput
    connect?: MediaWhereUniqueInput
  }

  export type QuizzesLangCreateNestedManyWithoutQuizzesInput = {
    create?: XOR<QuizzesLangCreateWithoutQuizzesInput, QuizzesLangUncheckedCreateWithoutQuizzesInput> | QuizzesLangCreateWithoutQuizzesInput[] | QuizzesLangUncheckedCreateWithoutQuizzesInput[]
    connectOrCreate?: QuizzesLangCreateOrConnectWithoutQuizzesInput | QuizzesLangCreateOrConnectWithoutQuizzesInput[]
    createMany?: QuizzesLangCreateManyQuizzesInputEnvelope
    connect?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
  }

  export type RelationsCreateNestedManyWithoutQuizzesInput = {
    create?: XOR<RelationsCreateWithoutQuizzesInput, RelationsUncheckedCreateWithoutQuizzesInput> | RelationsCreateWithoutQuizzesInput[] | RelationsUncheckedCreateWithoutQuizzesInput[]
    connectOrCreate?: RelationsCreateOrConnectWithoutQuizzesInput | RelationsCreateOrConnectWithoutQuizzesInput[]
    createMany?: RelationsCreateManyQuizzesInputEnvelope
    connect?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
  }

  export type QuizzesLangUncheckedCreateNestedManyWithoutQuizzesInput = {
    create?: XOR<QuizzesLangCreateWithoutQuizzesInput, QuizzesLangUncheckedCreateWithoutQuizzesInput> | QuizzesLangCreateWithoutQuizzesInput[] | QuizzesLangUncheckedCreateWithoutQuizzesInput[]
    connectOrCreate?: QuizzesLangCreateOrConnectWithoutQuizzesInput | QuizzesLangCreateOrConnectWithoutQuizzesInput[]
    createMany?: QuizzesLangCreateManyQuizzesInputEnvelope
    connect?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
  }

  export type RelationsUncheckedCreateNestedManyWithoutQuizzesInput = {
    create?: XOR<RelationsCreateWithoutQuizzesInput, RelationsUncheckedCreateWithoutQuizzesInput> | RelationsCreateWithoutQuizzesInput[] | RelationsUncheckedCreateWithoutQuizzesInput[]
    connectOrCreate?: RelationsCreateOrConnectWithoutQuizzesInput | RelationsCreateOrConnectWithoutQuizzesInput[]
    createMany?: RelationsCreateManyQuizzesInputEnvelope
    connect?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
  }

  export type MediaUpdateOneWithoutQuizzesNestedInput = {
    create?: XOR<MediaCreateWithoutQuizzesInput, MediaUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: MediaCreateOrConnectWithoutQuizzesInput
    upsert?: MediaUpsertWithoutQuizzesInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutQuizzesInput, MediaUpdateWithoutQuizzesInput>, MediaUncheckedUpdateWithoutQuizzesInput>
  }

  export type QuizzesLangUpdateManyWithoutQuizzesNestedInput = {
    create?: XOR<QuizzesLangCreateWithoutQuizzesInput, QuizzesLangUncheckedCreateWithoutQuizzesInput> | QuizzesLangCreateWithoutQuizzesInput[] | QuizzesLangUncheckedCreateWithoutQuizzesInput[]
    connectOrCreate?: QuizzesLangCreateOrConnectWithoutQuizzesInput | QuizzesLangCreateOrConnectWithoutQuizzesInput[]
    upsert?: QuizzesLangUpsertWithWhereUniqueWithoutQuizzesInput | QuizzesLangUpsertWithWhereUniqueWithoutQuizzesInput[]
    createMany?: QuizzesLangCreateManyQuizzesInputEnvelope
    set?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
    disconnect?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
    delete?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
    connect?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
    update?: QuizzesLangUpdateWithWhereUniqueWithoutQuizzesInput | QuizzesLangUpdateWithWhereUniqueWithoutQuizzesInput[]
    updateMany?: QuizzesLangUpdateManyWithWhereWithoutQuizzesInput | QuizzesLangUpdateManyWithWhereWithoutQuizzesInput[]
    deleteMany?: QuizzesLangScalarWhereInput | QuizzesLangScalarWhereInput[]
  }

  export type RelationsUpdateManyWithoutQuizzesNestedInput = {
    create?: XOR<RelationsCreateWithoutQuizzesInput, RelationsUncheckedCreateWithoutQuizzesInput> | RelationsCreateWithoutQuizzesInput[] | RelationsUncheckedCreateWithoutQuizzesInput[]
    connectOrCreate?: RelationsCreateOrConnectWithoutQuizzesInput | RelationsCreateOrConnectWithoutQuizzesInput[]
    upsert?: RelationsUpsertWithWhereUniqueWithoutQuizzesInput | RelationsUpsertWithWhereUniqueWithoutQuizzesInput[]
    createMany?: RelationsCreateManyQuizzesInputEnvelope
    set?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
    disconnect?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
    delete?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
    connect?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
    update?: RelationsUpdateWithWhereUniqueWithoutQuizzesInput | RelationsUpdateWithWhereUniqueWithoutQuizzesInput[]
    updateMany?: RelationsUpdateManyWithWhereWithoutQuizzesInput | RelationsUpdateManyWithWhereWithoutQuizzesInput[]
    deleteMany?: RelationsScalarWhereInput | RelationsScalarWhereInput[]
  }

  export type QuizzesLangUncheckedUpdateManyWithoutQuizzesNestedInput = {
    create?: XOR<QuizzesLangCreateWithoutQuizzesInput, QuizzesLangUncheckedCreateWithoutQuizzesInput> | QuizzesLangCreateWithoutQuizzesInput[] | QuizzesLangUncheckedCreateWithoutQuizzesInput[]
    connectOrCreate?: QuizzesLangCreateOrConnectWithoutQuizzesInput | QuizzesLangCreateOrConnectWithoutQuizzesInput[]
    upsert?: QuizzesLangUpsertWithWhereUniqueWithoutQuizzesInput | QuizzesLangUpsertWithWhereUniqueWithoutQuizzesInput[]
    createMany?: QuizzesLangCreateManyQuizzesInputEnvelope
    set?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
    disconnect?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
    delete?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
    connect?: QuizzesLangWhereUniqueInput | QuizzesLangWhereUniqueInput[]
    update?: QuizzesLangUpdateWithWhereUniqueWithoutQuizzesInput | QuizzesLangUpdateWithWhereUniqueWithoutQuizzesInput[]
    updateMany?: QuizzesLangUpdateManyWithWhereWithoutQuizzesInput | QuizzesLangUpdateManyWithWhereWithoutQuizzesInput[]
    deleteMany?: QuizzesLangScalarWhereInput | QuizzesLangScalarWhereInput[]
  }

  export type RelationsUncheckedUpdateManyWithoutQuizzesNestedInput = {
    create?: XOR<RelationsCreateWithoutQuizzesInput, RelationsUncheckedCreateWithoutQuizzesInput> | RelationsCreateWithoutQuizzesInput[] | RelationsUncheckedCreateWithoutQuizzesInput[]
    connectOrCreate?: RelationsCreateOrConnectWithoutQuizzesInput | RelationsCreateOrConnectWithoutQuizzesInput[]
    upsert?: RelationsUpsertWithWhereUniqueWithoutQuizzesInput | RelationsUpsertWithWhereUniqueWithoutQuizzesInput[]
    createMany?: RelationsCreateManyQuizzesInputEnvelope
    set?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
    disconnect?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
    delete?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
    connect?: RelationsWhereUniqueInput | RelationsWhereUniqueInput[]
    update?: RelationsUpdateWithWhereUniqueWithoutQuizzesInput | RelationsUpdateWithWhereUniqueWithoutQuizzesInput[]
    updateMany?: RelationsUpdateManyWithWhereWithoutQuizzesInput | RelationsUpdateManyWithWhereWithoutQuizzesInput[]
    deleteMany?: RelationsScalarWhereInput | RelationsScalarWhereInput[]
  }

  export type QuizzesCreateNestedOneWithoutQuizzesLangInput = {
    create?: XOR<QuizzesCreateWithoutQuizzesLangInput, QuizzesUncheckedCreateWithoutQuizzesLangInput>
    connectOrCreate?: QuizzesCreateOrConnectWithoutQuizzesLangInput
    connect?: QuizzesWhereUniqueInput
  }

  export type LanguagesCreateNestedOneWithoutQuizzesLangInput = {
    create?: XOR<LanguagesCreateWithoutQuizzesLangInput, LanguagesUncheckedCreateWithoutQuizzesLangInput>
    connectOrCreate?: LanguagesCreateOrConnectWithoutQuizzesLangInput
    connect?: LanguagesWhereUniqueInput
  }

  export type AudioCreateNestedOneWithoutQuizzesLangInput = {
    create?: XOR<AudioCreateWithoutQuizzesLangInput, AudioUncheckedCreateWithoutQuizzesLangInput>
    connectOrCreate?: AudioCreateOrConnectWithoutQuizzesLangInput
    connect?: AudioWhereUniqueInput
  }

  export type QuizzesUpdateOneRequiredWithoutQuizzesLangNestedInput = {
    create?: XOR<QuizzesCreateWithoutQuizzesLangInput, QuizzesUncheckedCreateWithoutQuizzesLangInput>
    connectOrCreate?: QuizzesCreateOrConnectWithoutQuizzesLangInput
    upsert?: QuizzesUpsertWithoutQuizzesLangInput
    connect?: QuizzesWhereUniqueInput
    update?: XOR<XOR<QuizzesUpdateToOneWithWhereWithoutQuizzesLangInput, QuizzesUpdateWithoutQuizzesLangInput>, QuizzesUncheckedUpdateWithoutQuizzesLangInput>
  }

  export type LanguagesUpdateOneRequiredWithoutQuizzesLangNestedInput = {
    create?: XOR<LanguagesCreateWithoutQuizzesLangInput, LanguagesUncheckedCreateWithoutQuizzesLangInput>
    connectOrCreate?: LanguagesCreateOrConnectWithoutQuizzesLangInput
    upsert?: LanguagesUpsertWithoutQuizzesLangInput
    connect?: LanguagesWhereUniqueInput
    update?: XOR<XOR<LanguagesUpdateToOneWithWhereWithoutQuizzesLangInput, LanguagesUpdateWithoutQuizzesLangInput>, LanguagesUncheckedUpdateWithoutQuizzesLangInput>
  }

  export type AudioUpdateOneWithoutQuizzesLangNestedInput = {
    create?: XOR<AudioCreateWithoutQuizzesLangInput, AudioUncheckedCreateWithoutQuizzesLangInput>
    connectOrCreate?: AudioCreateOrConnectWithoutQuizzesLangInput
    upsert?: AudioUpsertWithoutQuizzesLangInput
    disconnect?: AudioWhereInput | boolean
    delete?: AudioWhereInput | boolean
    connect?: AudioWhereUniqueInput
    update?: XOR<XOR<AudioUpdateToOneWithWhereWithoutQuizzesLangInput, AudioUpdateWithoutQuizzesLangInput>, AudioUncheckedUpdateWithoutQuizzesLangInput>
  }

  export type LicensesCreateNestedOneWithoutRelationsInput = {
    create?: XOR<LicensesCreateWithoutRelationsInput, LicensesUncheckedCreateWithoutRelationsInput>
    connectOrCreate?: LicensesCreateOrConnectWithoutRelationsInput
    connect?: LicensesWhereUniqueInput
  }

  export type GroupsCreateNestedOneWithoutRelationsInput = {
    create?: XOR<GroupsCreateWithoutRelationsInput, GroupsUncheckedCreateWithoutRelationsInput>
    connectOrCreate?: GroupsCreateOrConnectWithoutRelationsInput
    connect?: GroupsWhereUniqueInput
  }

  export type QuizzesCreateNestedOneWithoutRelationsInput = {
    create?: XOR<QuizzesCreateWithoutRelationsInput, QuizzesUncheckedCreateWithoutRelationsInput>
    connectOrCreate?: QuizzesCreateOrConnectWithoutRelationsInput
    connect?: QuizzesWhereUniqueInput
  }

  export type RelationsChoicesCreateNestedManyWithoutRelationsInput = {
    create?: XOR<RelationsChoicesCreateWithoutRelationsInput, RelationsChoicesUncheckedCreateWithoutRelationsInput> | RelationsChoicesCreateWithoutRelationsInput[] | RelationsChoicesUncheckedCreateWithoutRelationsInput[]
    connectOrCreate?: RelationsChoicesCreateOrConnectWithoutRelationsInput | RelationsChoicesCreateOrConnectWithoutRelationsInput[]
    createMany?: RelationsChoicesCreateManyRelationsInputEnvelope
    connect?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
  }

  export type RelationsQuestionsCreateNestedManyWithoutRelationsInput = {
    create?: XOR<RelationsQuestionsCreateWithoutRelationsInput, RelationsQuestionsUncheckedCreateWithoutRelationsInput> | RelationsQuestionsCreateWithoutRelationsInput[] | RelationsQuestionsUncheckedCreateWithoutRelationsInput[]
    connectOrCreate?: RelationsQuestionsCreateOrConnectWithoutRelationsInput | RelationsQuestionsCreateOrConnectWithoutRelationsInput[]
    createMany?: RelationsQuestionsCreateManyRelationsInputEnvelope
    connect?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
  }

  export type UsersRelationsCreateNestedManyWithoutRelationsInput = {
    create?: XOR<UsersRelationsCreateWithoutRelationsInput, UsersRelationsUncheckedCreateWithoutRelationsInput> | UsersRelationsCreateWithoutRelationsInput[] | UsersRelationsUncheckedCreateWithoutRelationsInput[]
    connectOrCreate?: UsersRelationsCreateOrConnectWithoutRelationsInput | UsersRelationsCreateOrConnectWithoutRelationsInput[]
    createMany?: UsersRelationsCreateManyRelationsInputEnvelope
    connect?: UsersRelationsWhereUniqueInput | UsersRelationsWhereUniqueInput[]
  }

  export type RelationsChoicesUncheckedCreateNestedManyWithoutRelationsInput = {
    create?: XOR<RelationsChoicesCreateWithoutRelationsInput, RelationsChoicesUncheckedCreateWithoutRelationsInput> | RelationsChoicesCreateWithoutRelationsInput[] | RelationsChoicesUncheckedCreateWithoutRelationsInput[]
    connectOrCreate?: RelationsChoicesCreateOrConnectWithoutRelationsInput | RelationsChoicesCreateOrConnectWithoutRelationsInput[]
    createMany?: RelationsChoicesCreateManyRelationsInputEnvelope
    connect?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
  }

  export type RelationsQuestionsUncheckedCreateNestedManyWithoutRelationsInput = {
    create?: XOR<RelationsQuestionsCreateWithoutRelationsInput, RelationsQuestionsUncheckedCreateWithoutRelationsInput> | RelationsQuestionsCreateWithoutRelationsInput[] | RelationsQuestionsUncheckedCreateWithoutRelationsInput[]
    connectOrCreate?: RelationsQuestionsCreateOrConnectWithoutRelationsInput | RelationsQuestionsCreateOrConnectWithoutRelationsInput[]
    createMany?: RelationsQuestionsCreateManyRelationsInputEnvelope
    connect?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
  }

  export type UsersRelationsUncheckedCreateNestedManyWithoutRelationsInput = {
    create?: XOR<UsersRelationsCreateWithoutRelationsInput, UsersRelationsUncheckedCreateWithoutRelationsInput> | UsersRelationsCreateWithoutRelationsInput[] | UsersRelationsUncheckedCreateWithoutRelationsInput[]
    connectOrCreate?: UsersRelationsCreateOrConnectWithoutRelationsInput | UsersRelationsCreateOrConnectWithoutRelationsInput[]
    createMany?: UsersRelationsCreateManyRelationsInputEnvelope
    connect?: UsersRelationsWhereUniqueInput | UsersRelationsWhereUniqueInput[]
  }

  export type LicensesUpdateOneRequiredWithoutRelationsNestedInput = {
    create?: XOR<LicensesCreateWithoutRelationsInput, LicensesUncheckedCreateWithoutRelationsInput>
    connectOrCreate?: LicensesCreateOrConnectWithoutRelationsInput
    upsert?: LicensesUpsertWithoutRelationsInput
    connect?: LicensesWhereUniqueInput
    update?: XOR<XOR<LicensesUpdateToOneWithWhereWithoutRelationsInput, LicensesUpdateWithoutRelationsInput>, LicensesUncheckedUpdateWithoutRelationsInput>
  }

  export type GroupsUpdateOneRequiredWithoutRelationsNestedInput = {
    create?: XOR<GroupsCreateWithoutRelationsInput, GroupsUncheckedCreateWithoutRelationsInput>
    connectOrCreate?: GroupsCreateOrConnectWithoutRelationsInput
    upsert?: GroupsUpsertWithoutRelationsInput
    connect?: GroupsWhereUniqueInput
    update?: XOR<XOR<GroupsUpdateToOneWithWhereWithoutRelationsInput, GroupsUpdateWithoutRelationsInput>, GroupsUncheckedUpdateWithoutRelationsInput>
  }

  export type QuizzesUpdateOneRequiredWithoutRelationsNestedInput = {
    create?: XOR<QuizzesCreateWithoutRelationsInput, QuizzesUncheckedCreateWithoutRelationsInput>
    connectOrCreate?: QuizzesCreateOrConnectWithoutRelationsInput
    upsert?: QuizzesUpsertWithoutRelationsInput
    connect?: QuizzesWhereUniqueInput
    update?: XOR<XOR<QuizzesUpdateToOneWithWhereWithoutRelationsInput, QuizzesUpdateWithoutRelationsInput>, QuizzesUncheckedUpdateWithoutRelationsInput>
  }

  export type RelationsChoicesUpdateManyWithoutRelationsNestedInput = {
    create?: XOR<RelationsChoicesCreateWithoutRelationsInput, RelationsChoicesUncheckedCreateWithoutRelationsInput> | RelationsChoicesCreateWithoutRelationsInput[] | RelationsChoicesUncheckedCreateWithoutRelationsInput[]
    connectOrCreate?: RelationsChoicesCreateOrConnectWithoutRelationsInput | RelationsChoicesCreateOrConnectWithoutRelationsInput[]
    upsert?: RelationsChoicesUpsertWithWhereUniqueWithoutRelationsInput | RelationsChoicesUpsertWithWhereUniqueWithoutRelationsInput[]
    createMany?: RelationsChoicesCreateManyRelationsInputEnvelope
    set?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    disconnect?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    delete?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    connect?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    update?: RelationsChoicesUpdateWithWhereUniqueWithoutRelationsInput | RelationsChoicesUpdateWithWhereUniqueWithoutRelationsInput[]
    updateMany?: RelationsChoicesUpdateManyWithWhereWithoutRelationsInput | RelationsChoicesUpdateManyWithWhereWithoutRelationsInput[]
    deleteMany?: RelationsChoicesScalarWhereInput | RelationsChoicesScalarWhereInput[]
  }

  export type RelationsQuestionsUpdateManyWithoutRelationsNestedInput = {
    create?: XOR<RelationsQuestionsCreateWithoutRelationsInput, RelationsQuestionsUncheckedCreateWithoutRelationsInput> | RelationsQuestionsCreateWithoutRelationsInput[] | RelationsQuestionsUncheckedCreateWithoutRelationsInput[]
    connectOrCreate?: RelationsQuestionsCreateOrConnectWithoutRelationsInput | RelationsQuestionsCreateOrConnectWithoutRelationsInput[]
    upsert?: RelationsQuestionsUpsertWithWhereUniqueWithoutRelationsInput | RelationsQuestionsUpsertWithWhereUniqueWithoutRelationsInput[]
    createMany?: RelationsQuestionsCreateManyRelationsInputEnvelope
    set?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
    disconnect?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
    delete?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
    connect?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
    update?: RelationsQuestionsUpdateWithWhereUniqueWithoutRelationsInput | RelationsQuestionsUpdateWithWhereUniqueWithoutRelationsInput[]
    updateMany?: RelationsQuestionsUpdateManyWithWhereWithoutRelationsInput | RelationsQuestionsUpdateManyWithWhereWithoutRelationsInput[]
    deleteMany?: RelationsQuestionsScalarWhereInput | RelationsQuestionsScalarWhereInput[]
  }

  export type UsersRelationsUpdateManyWithoutRelationsNestedInput = {
    create?: XOR<UsersRelationsCreateWithoutRelationsInput, UsersRelationsUncheckedCreateWithoutRelationsInput> | UsersRelationsCreateWithoutRelationsInput[] | UsersRelationsUncheckedCreateWithoutRelationsInput[]
    connectOrCreate?: UsersRelationsCreateOrConnectWithoutRelationsInput | UsersRelationsCreateOrConnectWithoutRelationsInput[]
    upsert?: UsersRelationsUpsertWithWhereUniqueWithoutRelationsInput | UsersRelationsUpsertWithWhereUniqueWithoutRelationsInput[]
    createMany?: UsersRelationsCreateManyRelationsInputEnvelope
    set?: UsersRelationsWhereUniqueInput | UsersRelationsWhereUniqueInput[]
    disconnect?: UsersRelationsWhereUniqueInput | UsersRelationsWhereUniqueInput[]
    delete?: UsersRelationsWhereUniqueInput | UsersRelationsWhereUniqueInput[]
    connect?: UsersRelationsWhereUniqueInput | UsersRelationsWhereUniqueInput[]
    update?: UsersRelationsUpdateWithWhereUniqueWithoutRelationsInput | UsersRelationsUpdateWithWhereUniqueWithoutRelationsInput[]
    updateMany?: UsersRelationsUpdateManyWithWhereWithoutRelationsInput | UsersRelationsUpdateManyWithWhereWithoutRelationsInput[]
    deleteMany?: UsersRelationsScalarWhereInput | UsersRelationsScalarWhereInput[]
  }

  export type RelationsChoicesUncheckedUpdateManyWithoutRelationsNestedInput = {
    create?: XOR<RelationsChoicesCreateWithoutRelationsInput, RelationsChoicesUncheckedCreateWithoutRelationsInput> | RelationsChoicesCreateWithoutRelationsInput[] | RelationsChoicesUncheckedCreateWithoutRelationsInput[]
    connectOrCreate?: RelationsChoicesCreateOrConnectWithoutRelationsInput | RelationsChoicesCreateOrConnectWithoutRelationsInput[]
    upsert?: RelationsChoicesUpsertWithWhereUniqueWithoutRelationsInput | RelationsChoicesUpsertWithWhereUniqueWithoutRelationsInput[]
    createMany?: RelationsChoicesCreateManyRelationsInputEnvelope
    set?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    disconnect?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    delete?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    connect?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    update?: RelationsChoicesUpdateWithWhereUniqueWithoutRelationsInput | RelationsChoicesUpdateWithWhereUniqueWithoutRelationsInput[]
    updateMany?: RelationsChoicesUpdateManyWithWhereWithoutRelationsInput | RelationsChoicesUpdateManyWithWhereWithoutRelationsInput[]
    deleteMany?: RelationsChoicesScalarWhereInput | RelationsChoicesScalarWhereInput[]
  }

  export type RelationsQuestionsUncheckedUpdateManyWithoutRelationsNestedInput = {
    create?: XOR<RelationsQuestionsCreateWithoutRelationsInput, RelationsQuestionsUncheckedCreateWithoutRelationsInput> | RelationsQuestionsCreateWithoutRelationsInput[] | RelationsQuestionsUncheckedCreateWithoutRelationsInput[]
    connectOrCreate?: RelationsQuestionsCreateOrConnectWithoutRelationsInput | RelationsQuestionsCreateOrConnectWithoutRelationsInput[]
    upsert?: RelationsQuestionsUpsertWithWhereUniqueWithoutRelationsInput | RelationsQuestionsUpsertWithWhereUniqueWithoutRelationsInput[]
    createMany?: RelationsQuestionsCreateManyRelationsInputEnvelope
    set?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
    disconnect?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
    delete?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
    connect?: RelationsQuestionsWhereUniqueInput | RelationsQuestionsWhereUniqueInput[]
    update?: RelationsQuestionsUpdateWithWhereUniqueWithoutRelationsInput | RelationsQuestionsUpdateWithWhereUniqueWithoutRelationsInput[]
    updateMany?: RelationsQuestionsUpdateManyWithWhereWithoutRelationsInput | RelationsQuestionsUpdateManyWithWhereWithoutRelationsInput[]
    deleteMany?: RelationsQuestionsScalarWhereInput | RelationsQuestionsScalarWhereInput[]
  }

  export type UsersRelationsUncheckedUpdateManyWithoutRelationsNestedInput = {
    create?: XOR<UsersRelationsCreateWithoutRelationsInput, UsersRelationsUncheckedCreateWithoutRelationsInput> | UsersRelationsCreateWithoutRelationsInput[] | UsersRelationsUncheckedCreateWithoutRelationsInput[]
    connectOrCreate?: UsersRelationsCreateOrConnectWithoutRelationsInput | UsersRelationsCreateOrConnectWithoutRelationsInput[]
    upsert?: UsersRelationsUpsertWithWhereUniqueWithoutRelationsInput | UsersRelationsUpsertWithWhereUniqueWithoutRelationsInput[]
    createMany?: UsersRelationsCreateManyRelationsInputEnvelope
    set?: UsersRelationsWhereUniqueInput | UsersRelationsWhereUniqueInput[]
    disconnect?: UsersRelationsWhereUniqueInput | UsersRelationsWhereUniqueInput[]
    delete?: UsersRelationsWhereUniqueInput | UsersRelationsWhereUniqueInput[]
    connect?: UsersRelationsWhereUniqueInput | UsersRelationsWhereUniqueInput[]
    update?: UsersRelationsUpdateWithWhereUniqueWithoutRelationsInput | UsersRelationsUpdateWithWhereUniqueWithoutRelationsInput[]
    updateMany?: UsersRelationsUpdateManyWithWhereWithoutRelationsInput | UsersRelationsUpdateManyWithWhereWithoutRelationsInput[]
    deleteMany?: UsersRelationsScalarWhereInput | UsersRelationsScalarWhereInput[]
  }

  export type ChoicesCreateNestedOneWithoutRelationsChoicesInput = {
    create?: XOR<ChoicesCreateWithoutRelationsChoicesInput, ChoicesUncheckedCreateWithoutRelationsChoicesInput>
    connectOrCreate?: ChoicesCreateOrConnectWithoutRelationsChoicesInput
    connect?: ChoicesWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutRelationsChoicesInput = {
    create?: XOR<MediaCreateWithoutRelationsChoicesInput, MediaUncheckedCreateWithoutRelationsChoicesInput>
    connectOrCreate?: MediaCreateOrConnectWithoutRelationsChoicesInput
    connect?: MediaWhereUniqueInput
  }

  export type RelationsQuestionsCreateNestedOneWithoutRelationsChoicesInput = {
    create?: XOR<RelationsQuestionsCreateWithoutRelationsChoicesInput, RelationsQuestionsUncheckedCreateWithoutRelationsChoicesInput>
    connectOrCreate?: RelationsQuestionsCreateOrConnectWithoutRelationsChoicesInput
    connect?: RelationsQuestionsWhereUniqueInput
  }

  export type RelationsCreateNestedOneWithoutRelationsChoicesInput = {
    create?: XOR<RelationsCreateWithoutRelationsChoicesInput, RelationsUncheckedCreateWithoutRelationsChoicesInput>
    connectOrCreate?: RelationsCreateOrConnectWithoutRelationsChoicesInput
    connect?: RelationsWhereUniqueInput
  }

  export type UsersRelationsDetailsCreateNestedManyWithoutRelationsChoicesInput = {
    create?: XOR<UsersRelationsDetailsCreateWithoutRelationsChoicesInput, UsersRelationsDetailsUncheckedCreateWithoutRelationsChoicesInput> | UsersRelationsDetailsCreateWithoutRelationsChoicesInput[] | UsersRelationsDetailsUncheckedCreateWithoutRelationsChoicesInput[]
    connectOrCreate?: UsersRelationsDetailsCreateOrConnectWithoutRelationsChoicesInput | UsersRelationsDetailsCreateOrConnectWithoutRelationsChoicesInput[]
    createMany?: UsersRelationsDetailsCreateManyRelationsChoicesInputEnvelope
    connect?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
  }

  export type UsersRelationsDetailsUncheckedCreateNestedManyWithoutRelationsChoicesInput = {
    create?: XOR<UsersRelationsDetailsCreateWithoutRelationsChoicesInput, UsersRelationsDetailsUncheckedCreateWithoutRelationsChoicesInput> | UsersRelationsDetailsCreateWithoutRelationsChoicesInput[] | UsersRelationsDetailsUncheckedCreateWithoutRelationsChoicesInput[]
    connectOrCreate?: UsersRelationsDetailsCreateOrConnectWithoutRelationsChoicesInput | UsersRelationsDetailsCreateOrConnectWithoutRelationsChoicesInput[]
    createMany?: UsersRelationsDetailsCreateManyRelationsChoicesInputEnvelope
    connect?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
  }

  export type ChoicesUpdateOneRequiredWithoutRelationsChoicesNestedInput = {
    create?: XOR<ChoicesCreateWithoutRelationsChoicesInput, ChoicesUncheckedCreateWithoutRelationsChoicesInput>
    connectOrCreate?: ChoicesCreateOrConnectWithoutRelationsChoicesInput
    upsert?: ChoicesUpsertWithoutRelationsChoicesInput
    connect?: ChoicesWhereUniqueInput
    update?: XOR<XOR<ChoicesUpdateToOneWithWhereWithoutRelationsChoicesInput, ChoicesUpdateWithoutRelationsChoicesInput>, ChoicesUncheckedUpdateWithoutRelationsChoicesInput>
  }

  export type MediaUpdateOneWithoutRelationsChoicesNestedInput = {
    create?: XOR<MediaCreateWithoutRelationsChoicesInput, MediaUncheckedCreateWithoutRelationsChoicesInput>
    connectOrCreate?: MediaCreateOrConnectWithoutRelationsChoicesInput
    upsert?: MediaUpsertWithoutRelationsChoicesInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutRelationsChoicesInput, MediaUpdateWithoutRelationsChoicesInput>, MediaUncheckedUpdateWithoutRelationsChoicesInput>
  }

  export type RelationsQuestionsUpdateOneRequiredWithoutRelationsChoicesNestedInput = {
    create?: XOR<RelationsQuestionsCreateWithoutRelationsChoicesInput, RelationsQuestionsUncheckedCreateWithoutRelationsChoicesInput>
    connectOrCreate?: RelationsQuestionsCreateOrConnectWithoutRelationsChoicesInput
    upsert?: RelationsQuestionsUpsertWithoutRelationsChoicesInput
    connect?: RelationsQuestionsWhereUniqueInput
    update?: XOR<XOR<RelationsQuestionsUpdateToOneWithWhereWithoutRelationsChoicesInput, RelationsQuestionsUpdateWithoutRelationsChoicesInput>, RelationsQuestionsUncheckedUpdateWithoutRelationsChoicesInput>
  }

  export type RelationsUpdateOneWithoutRelationsChoicesNestedInput = {
    create?: XOR<RelationsCreateWithoutRelationsChoicesInput, RelationsUncheckedCreateWithoutRelationsChoicesInput>
    connectOrCreate?: RelationsCreateOrConnectWithoutRelationsChoicesInput
    upsert?: RelationsUpsertWithoutRelationsChoicesInput
    disconnect?: RelationsWhereInput | boolean
    delete?: RelationsWhereInput | boolean
    connect?: RelationsWhereUniqueInput
    update?: XOR<XOR<RelationsUpdateToOneWithWhereWithoutRelationsChoicesInput, RelationsUpdateWithoutRelationsChoicesInput>, RelationsUncheckedUpdateWithoutRelationsChoicesInput>
  }

  export type UsersRelationsDetailsUpdateManyWithoutRelationsChoicesNestedInput = {
    create?: XOR<UsersRelationsDetailsCreateWithoutRelationsChoicesInput, UsersRelationsDetailsUncheckedCreateWithoutRelationsChoicesInput> | UsersRelationsDetailsCreateWithoutRelationsChoicesInput[] | UsersRelationsDetailsUncheckedCreateWithoutRelationsChoicesInput[]
    connectOrCreate?: UsersRelationsDetailsCreateOrConnectWithoutRelationsChoicesInput | UsersRelationsDetailsCreateOrConnectWithoutRelationsChoicesInput[]
    upsert?: UsersRelationsDetailsUpsertWithWhereUniqueWithoutRelationsChoicesInput | UsersRelationsDetailsUpsertWithWhereUniqueWithoutRelationsChoicesInput[]
    createMany?: UsersRelationsDetailsCreateManyRelationsChoicesInputEnvelope
    set?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
    disconnect?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
    delete?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
    connect?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
    update?: UsersRelationsDetailsUpdateWithWhereUniqueWithoutRelationsChoicesInput | UsersRelationsDetailsUpdateWithWhereUniqueWithoutRelationsChoicesInput[]
    updateMany?: UsersRelationsDetailsUpdateManyWithWhereWithoutRelationsChoicesInput | UsersRelationsDetailsUpdateManyWithWhereWithoutRelationsChoicesInput[]
    deleteMany?: UsersRelationsDetailsScalarWhereInput | UsersRelationsDetailsScalarWhereInput[]
  }

  export type UsersRelationsDetailsUncheckedUpdateManyWithoutRelationsChoicesNestedInput = {
    create?: XOR<UsersRelationsDetailsCreateWithoutRelationsChoicesInput, UsersRelationsDetailsUncheckedCreateWithoutRelationsChoicesInput> | UsersRelationsDetailsCreateWithoutRelationsChoicesInput[] | UsersRelationsDetailsUncheckedCreateWithoutRelationsChoicesInput[]
    connectOrCreate?: UsersRelationsDetailsCreateOrConnectWithoutRelationsChoicesInput | UsersRelationsDetailsCreateOrConnectWithoutRelationsChoicesInput[]
    upsert?: UsersRelationsDetailsUpsertWithWhereUniqueWithoutRelationsChoicesInput | UsersRelationsDetailsUpsertWithWhereUniqueWithoutRelationsChoicesInput[]
    createMany?: UsersRelationsDetailsCreateManyRelationsChoicesInputEnvelope
    set?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
    disconnect?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
    delete?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
    connect?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
    update?: UsersRelationsDetailsUpdateWithWhereUniqueWithoutRelationsChoicesInput | UsersRelationsDetailsUpdateWithWhereUniqueWithoutRelationsChoicesInput[]
    updateMany?: UsersRelationsDetailsUpdateManyWithWhereWithoutRelationsChoicesInput | UsersRelationsDetailsUpdateManyWithWhereWithoutRelationsChoicesInput[]
    deleteMany?: UsersRelationsDetailsScalarWhereInput | UsersRelationsDetailsScalarWhereInput[]
  }

  export type QuestionsCreateNestedOneWithoutRelationsQuestionsInput = {
    create?: XOR<QuestionsCreateWithoutRelationsQuestionsInput, QuestionsUncheckedCreateWithoutRelationsQuestionsInput>
    connectOrCreate?: QuestionsCreateOrConnectWithoutRelationsQuestionsInput
    connect?: QuestionsWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutRelationsQuestionsInput = {
    create?: XOR<MediaCreateWithoutRelationsQuestionsInput, MediaUncheckedCreateWithoutRelationsQuestionsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutRelationsQuestionsInput
    connect?: MediaWhereUniqueInput
  }

  export type RelationsCreateNestedOneWithoutRelationsQuestionsInput = {
    create?: XOR<RelationsCreateWithoutRelationsQuestionsInput, RelationsUncheckedCreateWithoutRelationsQuestionsInput>
    connectOrCreate?: RelationsCreateOrConnectWithoutRelationsQuestionsInput
    connect?: RelationsWhereUniqueInput
  }

  export type RelationsChoicesCreateNestedManyWithoutRelationsQuestionsInput = {
    create?: XOR<RelationsChoicesCreateWithoutRelationsQuestionsInput, RelationsChoicesUncheckedCreateWithoutRelationsQuestionsInput> | RelationsChoicesCreateWithoutRelationsQuestionsInput[] | RelationsChoicesUncheckedCreateWithoutRelationsQuestionsInput[]
    connectOrCreate?: RelationsChoicesCreateOrConnectWithoutRelationsQuestionsInput | RelationsChoicesCreateOrConnectWithoutRelationsQuestionsInput[]
    createMany?: RelationsChoicesCreateManyRelationsQuestionsInputEnvelope
    connect?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
  }

  export type UsersRelationsDetailsCreateNestedManyWithoutRelationsQuestionsInput = {
    create?: XOR<UsersRelationsDetailsCreateWithoutRelationsQuestionsInput, UsersRelationsDetailsUncheckedCreateWithoutRelationsQuestionsInput> | UsersRelationsDetailsCreateWithoutRelationsQuestionsInput[] | UsersRelationsDetailsUncheckedCreateWithoutRelationsQuestionsInput[]
    connectOrCreate?: UsersRelationsDetailsCreateOrConnectWithoutRelationsQuestionsInput | UsersRelationsDetailsCreateOrConnectWithoutRelationsQuestionsInput[]
    createMany?: UsersRelationsDetailsCreateManyRelationsQuestionsInputEnvelope
    connect?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
  }

  export type RelationsChoicesUncheckedCreateNestedManyWithoutRelationsQuestionsInput = {
    create?: XOR<RelationsChoicesCreateWithoutRelationsQuestionsInput, RelationsChoicesUncheckedCreateWithoutRelationsQuestionsInput> | RelationsChoicesCreateWithoutRelationsQuestionsInput[] | RelationsChoicesUncheckedCreateWithoutRelationsQuestionsInput[]
    connectOrCreate?: RelationsChoicesCreateOrConnectWithoutRelationsQuestionsInput | RelationsChoicesCreateOrConnectWithoutRelationsQuestionsInput[]
    createMany?: RelationsChoicesCreateManyRelationsQuestionsInputEnvelope
    connect?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
  }

  export type UsersRelationsDetailsUncheckedCreateNestedManyWithoutRelationsQuestionsInput = {
    create?: XOR<UsersRelationsDetailsCreateWithoutRelationsQuestionsInput, UsersRelationsDetailsUncheckedCreateWithoutRelationsQuestionsInput> | UsersRelationsDetailsCreateWithoutRelationsQuestionsInput[] | UsersRelationsDetailsUncheckedCreateWithoutRelationsQuestionsInput[]
    connectOrCreate?: UsersRelationsDetailsCreateOrConnectWithoutRelationsQuestionsInput | UsersRelationsDetailsCreateOrConnectWithoutRelationsQuestionsInput[]
    createMany?: UsersRelationsDetailsCreateManyRelationsQuestionsInputEnvelope
    connect?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
  }

  export type QuestionsUpdateOneRequiredWithoutRelationsQuestionsNestedInput = {
    create?: XOR<QuestionsCreateWithoutRelationsQuestionsInput, QuestionsUncheckedCreateWithoutRelationsQuestionsInput>
    connectOrCreate?: QuestionsCreateOrConnectWithoutRelationsQuestionsInput
    upsert?: QuestionsUpsertWithoutRelationsQuestionsInput
    connect?: QuestionsWhereUniqueInput
    update?: XOR<XOR<QuestionsUpdateToOneWithWhereWithoutRelationsQuestionsInput, QuestionsUpdateWithoutRelationsQuestionsInput>, QuestionsUncheckedUpdateWithoutRelationsQuestionsInput>
  }

  export type MediaUpdateOneWithoutRelationsQuestionsNestedInput = {
    create?: XOR<MediaCreateWithoutRelationsQuestionsInput, MediaUncheckedCreateWithoutRelationsQuestionsInput>
    connectOrCreate?: MediaCreateOrConnectWithoutRelationsQuestionsInput
    upsert?: MediaUpsertWithoutRelationsQuestionsInput
    disconnect?: MediaWhereInput | boolean
    delete?: MediaWhereInput | boolean
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutRelationsQuestionsInput, MediaUpdateWithoutRelationsQuestionsInput>, MediaUncheckedUpdateWithoutRelationsQuestionsInput>
  }

  export type RelationsUpdateOneRequiredWithoutRelationsQuestionsNestedInput = {
    create?: XOR<RelationsCreateWithoutRelationsQuestionsInput, RelationsUncheckedCreateWithoutRelationsQuestionsInput>
    connectOrCreate?: RelationsCreateOrConnectWithoutRelationsQuestionsInput
    upsert?: RelationsUpsertWithoutRelationsQuestionsInput
    connect?: RelationsWhereUniqueInput
    update?: XOR<XOR<RelationsUpdateToOneWithWhereWithoutRelationsQuestionsInput, RelationsUpdateWithoutRelationsQuestionsInput>, RelationsUncheckedUpdateWithoutRelationsQuestionsInput>
  }

  export type RelationsChoicesUpdateManyWithoutRelationsQuestionsNestedInput = {
    create?: XOR<RelationsChoicesCreateWithoutRelationsQuestionsInput, RelationsChoicesUncheckedCreateWithoutRelationsQuestionsInput> | RelationsChoicesCreateWithoutRelationsQuestionsInput[] | RelationsChoicesUncheckedCreateWithoutRelationsQuestionsInput[]
    connectOrCreate?: RelationsChoicesCreateOrConnectWithoutRelationsQuestionsInput | RelationsChoicesCreateOrConnectWithoutRelationsQuestionsInput[]
    upsert?: RelationsChoicesUpsertWithWhereUniqueWithoutRelationsQuestionsInput | RelationsChoicesUpsertWithWhereUniqueWithoutRelationsQuestionsInput[]
    createMany?: RelationsChoicesCreateManyRelationsQuestionsInputEnvelope
    set?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    disconnect?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    delete?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    connect?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    update?: RelationsChoicesUpdateWithWhereUniqueWithoutRelationsQuestionsInput | RelationsChoicesUpdateWithWhereUniqueWithoutRelationsQuestionsInput[]
    updateMany?: RelationsChoicesUpdateManyWithWhereWithoutRelationsQuestionsInput | RelationsChoicesUpdateManyWithWhereWithoutRelationsQuestionsInput[]
    deleteMany?: RelationsChoicesScalarWhereInput | RelationsChoicesScalarWhereInput[]
  }

  export type UsersRelationsDetailsUpdateManyWithoutRelationsQuestionsNestedInput = {
    create?: XOR<UsersRelationsDetailsCreateWithoutRelationsQuestionsInput, UsersRelationsDetailsUncheckedCreateWithoutRelationsQuestionsInput> | UsersRelationsDetailsCreateWithoutRelationsQuestionsInput[] | UsersRelationsDetailsUncheckedCreateWithoutRelationsQuestionsInput[]
    connectOrCreate?: UsersRelationsDetailsCreateOrConnectWithoutRelationsQuestionsInput | UsersRelationsDetailsCreateOrConnectWithoutRelationsQuestionsInput[]
    upsert?: UsersRelationsDetailsUpsertWithWhereUniqueWithoutRelationsQuestionsInput | UsersRelationsDetailsUpsertWithWhereUniqueWithoutRelationsQuestionsInput[]
    createMany?: UsersRelationsDetailsCreateManyRelationsQuestionsInputEnvelope
    set?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
    disconnect?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
    delete?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
    connect?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
    update?: UsersRelationsDetailsUpdateWithWhereUniqueWithoutRelationsQuestionsInput | UsersRelationsDetailsUpdateWithWhereUniqueWithoutRelationsQuestionsInput[]
    updateMany?: UsersRelationsDetailsUpdateManyWithWhereWithoutRelationsQuestionsInput | UsersRelationsDetailsUpdateManyWithWhereWithoutRelationsQuestionsInput[]
    deleteMany?: UsersRelationsDetailsScalarWhereInput | UsersRelationsDetailsScalarWhereInput[]
  }

  export type RelationsChoicesUncheckedUpdateManyWithoutRelationsQuestionsNestedInput = {
    create?: XOR<RelationsChoicesCreateWithoutRelationsQuestionsInput, RelationsChoicesUncheckedCreateWithoutRelationsQuestionsInput> | RelationsChoicesCreateWithoutRelationsQuestionsInput[] | RelationsChoicesUncheckedCreateWithoutRelationsQuestionsInput[]
    connectOrCreate?: RelationsChoicesCreateOrConnectWithoutRelationsQuestionsInput | RelationsChoicesCreateOrConnectWithoutRelationsQuestionsInput[]
    upsert?: RelationsChoicesUpsertWithWhereUniqueWithoutRelationsQuestionsInput | RelationsChoicesUpsertWithWhereUniqueWithoutRelationsQuestionsInput[]
    createMany?: RelationsChoicesCreateManyRelationsQuestionsInputEnvelope
    set?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    disconnect?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    delete?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    connect?: RelationsChoicesWhereUniqueInput | RelationsChoicesWhereUniqueInput[]
    update?: RelationsChoicesUpdateWithWhereUniqueWithoutRelationsQuestionsInput | RelationsChoicesUpdateWithWhereUniqueWithoutRelationsQuestionsInput[]
    updateMany?: RelationsChoicesUpdateManyWithWhereWithoutRelationsQuestionsInput | RelationsChoicesUpdateManyWithWhereWithoutRelationsQuestionsInput[]
    deleteMany?: RelationsChoicesScalarWhereInput | RelationsChoicesScalarWhereInput[]
  }

  export type UsersRelationsDetailsUncheckedUpdateManyWithoutRelationsQuestionsNestedInput = {
    create?: XOR<UsersRelationsDetailsCreateWithoutRelationsQuestionsInput, UsersRelationsDetailsUncheckedCreateWithoutRelationsQuestionsInput> | UsersRelationsDetailsCreateWithoutRelationsQuestionsInput[] | UsersRelationsDetailsUncheckedCreateWithoutRelationsQuestionsInput[]
    connectOrCreate?: UsersRelationsDetailsCreateOrConnectWithoutRelationsQuestionsInput | UsersRelationsDetailsCreateOrConnectWithoutRelationsQuestionsInput[]
    upsert?: UsersRelationsDetailsUpsertWithWhereUniqueWithoutRelationsQuestionsInput | UsersRelationsDetailsUpsertWithWhereUniqueWithoutRelationsQuestionsInput[]
    createMany?: UsersRelationsDetailsCreateManyRelationsQuestionsInputEnvelope
    set?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
    disconnect?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
    delete?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
    connect?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
    update?: UsersRelationsDetailsUpdateWithWhereUniqueWithoutRelationsQuestionsInput | UsersRelationsDetailsUpdateWithWhereUniqueWithoutRelationsQuestionsInput[]
    updateMany?: UsersRelationsDetailsUpdateManyWithWhereWithoutRelationsQuestionsInput | UsersRelationsDetailsUpdateManyWithWhereWithoutRelationsQuestionsInput[]
    deleteMany?: UsersRelationsDetailsScalarWhereInput | UsersRelationsDetailsScalarWhereInput[]
  }

  export type LocationsCreateNestedOneWithoutUsersInput = {
    create?: XOR<LocationsCreateWithoutUsersInput, LocationsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: LocationsCreateOrConnectWithoutUsersInput
    connect?: LocationsWhereUniqueInput
  }

  export type UsersAuthCreateNestedManyWithoutUsersInput = {
    create?: XOR<UsersAuthCreateWithoutUsersInput, UsersAuthUncheckedCreateWithoutUsersInput> | UsersAuthCreateWithoutUsersInput[] | UsersAuthUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UsersAuthCreateOrConnectWithoutUsersInput | UsersAuthCreateOrConnectWithoutUsersInput[]
    createMany?: UsersAuthCreateManyUsersInputEnvelope
    connect?: UsersAuthWhereUniqueInput | UsersAuthWhereUniqueInput[]
  }

  export type UsersGroupsCreateNestedManyWithoutUsersInput = {
    create?: XOR<UsersGroupsCreateWithoutUsersInput, UsersGroupsUncheckedCreateWithoutUsersInput> | UsersGroupsCreateWithoutUsersInput[] | UsersGroupsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UsersGroupsCreateOrConnectWithoutUsersInput | UsersGroupsCreateOrConnectWithoutUsersInput[]
    createMany?: UsersGroupsCreateManyUsersInputEnvelope
    connect?: UsersGroupsWhereUniqueInput | UsersGroupsWhereUniqueInput[]
  }

  export type UsersLoginCreateNestedManyWithoutUsersInput = {
    create?: XOR<UsersLoginCreateWithoutUsersInput, UsersLoginUncheckedCreateWithoutUsersInput> | UsersLoginCreateWithoutUsersInput[] | UsersLoginUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UsersLoginCreateOrConnectWithoutUsersInput | UsersLoginCreateOrConnectWithoutUsersInput[]
    createMany?: UsersLoginCreateManyUsersInputEnvelope
    connect?: UsersLoginWhereUniqueInput | UsersLoginWhereUniqueInput[]
  }

  export type UsersRelationsCreateNestedManyWithoutUsersInput = {
    create?: XOR<UsersRelationsCreateWithoutUsersInput, UsersRelationsUncheckedCreateWithoutUsersInput> | UsersRelationsCreateWithoutUsersInput[] | UsersRelationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UsersRelationsCreateOrConnectWithoutUsersInput | UsersRelationsCreateOrConnectWithoutUsersInput[]
    createMany?: UsersRelationsCreateManyUsersInputEnvelope
    connect?: UsersRelationsWhereUniqueInput | UsersRelationsWhereUniqueInput[]
  }

  export type UsersAuthUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<UsersAuthCreateWithoutUsersInput, UsersAuthUncheckedCreateWithoutUsersInput> | UsersAuthCreateWithoutUsersInput[] | UsersAuthUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UsersAuthCreateOrConnectWithoutUsersInput | UsersAuthCreateOrConnectWithoutUsersInput[]
    createMany?: UsersAuthCreateManyUsersInputEnvelope
    connect?: UsersAuthWhereUniqueInput | UsersAuthWhereUniqueInput[]
  }

  export type UsersGroupsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<UsersGroupsCreateWithoutUsersInput, UsersGroupsUncheckedCreateWithoutUsersInput> | UsersGroupsCreateWithoutUsersInput[] | UsersGroupsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UsersGroupsCreateOrConnectWithoutUsersInput | UsersGroupsCreateOrConnectWithoutUsersInput[]
    createMany?: UsersGroupsCreateManyUsersInputEnvelope
    connect?: UsersGroupsWhereUniqueInput | UsersGroupsWhereUniqueInput[]
  }

  export type UsersLoginUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<UsersLoginCreateWithoutUsersInput, UsersLoginUncheckedCreateWithoutUsersInput> | UsersLoginCreateWithoutUsersInput[] | UsersLoginUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UsersLoginCreateOrConnectWithoutUsersInput | UsersLoginCreateOrConnectWithoutUsersInput[]
    createMany?: UsersLoginCreateManyUsersInputEnvelope
    connect?: UsersLoginWhereUniqueInput | UsersLoginWhereUniqueInput[]
  }

  export type UsersRelationsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<UsersRelationsCreateWithoutUsersInput, UsersRelationsUncheckedCreateWithoutUsersInput> | UsersRelationsCreateWithoutUsersInput[] | UsersRelationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UsersRelationsCreateOrConnectWithoutUsersInput | UsersRelationsCreateOrConnectWithoutUsersInput[]
    createMany?: UsersRelationsCreateManyUsersInputEnvelope
    connect?: UsersRelationsWhereUniqueInput | UsersRelationsWhereUniqueInput[]
  }

  export type LocationsUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<LocationsCreateWithoutUsersInput, LocationsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: LocationsCreateOrConnectWithoutUsersInput
    upsert?: LocationsUpsertWithoutUsersInput
    connect?: LocationsWhereUniqueInput
    update?: XOR<XOR<LocationsUpdateToOneWithWhereWithoutUsersInput, LocationsUpdateWithoutUsersInput>, LocationsUncheckedUpdateWithoutUsersInput>
  }

  export type UsersAuthUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UsersAuthCreateWithoutUsersInput, UsersAuthUncheckedCreateWithoutUsersInput> | UsersAuthCreateWithoutUsersInput[] | UsersAuthUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UsersAuthCreateOrConnectWithoutUsersInput | UsersAuthCreateOrConnectWithoutUsersInput[]
    upsert?: UsersAuthUpsertWithWhereUniqueWithoutUsersInput | UsersAuthUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: UsersAuthCreateManyUsersInputEnvelope
    set?: UsersAuthWhereUniqueInput | UsersAuthWhereUniqueInput[]
    disconnect?: UsersAuthWhereUniqueInput | UsersAuthWhereUniqueInput[]
    delete?: UsersAuthWhereUniqueInput | UsersAuthWhereUniqueInput[]
    connect?: UsersAuthWhereUniqueInput | UsersAuthWhereUniqueInput[]
    update?: UsersAuthUpdateWithWhereUniqueWithoutUsersInput | UsersAuthUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UsersAuthUpdateManyWithWhereWithoutUsersInput | UsersAuthUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UsersAuthScalarWhereInput | UsersAuthScalarWhereInput[]
  }

  export type UsersGroupsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UsersGroupsCreateWithoutUsersInput, UsersGroupsUncheckedCreateWithoutUsersInput> | UsersGroupsCreateWithoutUsersInput[] | UsersGroupsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UsersGroupsCreateOrConnectWithoutUsersInput | UsersGroupsCreateOrConnectWithoutUsersInput[]
    upsert?: UsersGroupsUpsertWithWhereUniqueWithoutUsersInput | UsersGroupsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: UsersGroupsCreateManyUsersInputEnvelope
    set?: UsersGroupsWhereUniqueInput | UsersGroupsWhereUniqueInput[]
    disconnect?: UsersGroupsWhereUniqueInput | UsersGroupsWhereUniqueInput[]
    delete?: UsersGroupsWhereUniqueInput | UsersGroupsWhereUniqueInput[]
    connect?: UsersGroupsWhereUniqueInput | UsersGroupsWhereUniqueInput[]
    update?: UsersGroupsUpdateWithWhereUniqueWithoutUsersInput | UsersGroupsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UsersGroupsUpdateManyWithWhereWithoutUsersInput | UsersGroupsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UsersGroupsScalarWhereInput | UsersGroupsScalarWhereInput[]
  }

  export type UsersLoginUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UsersLoginCreateWithoutUsersInput, UsersLoginUncheckedCreateWithoutUsersInput> | UsersLoginCreateWithoutUsersInput[] | UsersLoginUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UsersLoginCreateOrConnectWithoutUsersInput | UsersLoginCreateOrConnectWithoutUsersInput[]
    upsert?: UsersLoginUpsertWithWhereUniqueWithoutUsersInput | UsersLoginUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: UsersLoginCreateManyUsersInputEnvelope
    set?: UsersLoginWhereUniqueInput | UsersLoginWhereUniqueInput[]
    disconnect?: UsersLoginWhereUniqueInput | UsersLoginWhereUniqueInput[]
    delete?: UsersLoginWhereUniqueInput | UsersLoginWhereUniqueInput[]
    connect?: UsersLoginWhereUniqueInput | UsersLoginWhereUniqueInput[]
    update?: UsersLoginUpdateWithWhereUniqueWithoutUsersInput | UsersLoginUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UsersLoginUpdateManyWithWhereWithoutUsersInput | UsersLoginUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UsersLoginScalarWhereInput | UsersLoginScalarWhereInput[]
  }

  export type UsersRelationsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UsersRelationsCreateWithoutUsersInput, UsersRelationsUncheckedCreateWithoutUsersInput> | UsersRelationsCreateWithoutUsersInput[] | UsersRelationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UsersRelationsCreateOrConnectWithoutUsersInput | UsersRelationsCreateOrConnectWithoutUsersInput[]
    upsert?: UsersRelationsUpsertWithWhereUniqueWithoutUsersInput | UsersRelationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: UsersRelationsCreateManyUsersInputEnvelope
    set?: UsersRelationsWhereUniqueInput | UsersRelationsWhereUniqueInput[]
    disconnect?: UsersRelationsWhereUniqueInput | UsersRelationsWhereUniqueInput[]
    delete?: UsersRelationsWhereUniqueInput | UsersRelationsWhereUniqueInput[]
    connect?: UsersRelationsWhereUniqueInput | UsersRelationsWhereUniqueInput[]
    update?: UsersRelationsUpdateWithWhereUniqueWithoutUsersInput | UsersRelationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UsersRelationsUpdateManyWithWhereWithoutUsersInput | UsersRelationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UsersRelationsScalarWhereInput | UsersRelationsScalarWhereInput[]
  }

  export type UsersAuthUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UsersAuthCreateWithoutUsersInput, UsersAuthUncheckedCreateWithoutUsersInput> | UsersAuthCreateWithoutUsersInput[] | UsersAuthUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UsersAuthCreateOrConnectWithoutUsersInput | UsersAuthCreateOrConnectWithoutUsersInput[]
    upsert?: UsersAuthUpsertWithWhereUniqueWithoutUsersInput | UsersAuthUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: UsersAuthCreateManyUsersInputEnvelope
    set?: UsersAuthWhereUniqueInput | UsersAuthWhereUniqueInput[]
    disconnect?: UsersAuthWhereUniqueInput | UsersAuthWhereUniqueInput[]
    delete?: UsersAuthWhereUniqueInput | UsersAuthWhereUniqueInput[]
    connect?: UsersAuthWhereUniqueInput | UsersAuthWhereUniqueInput[]
    update?: UsersAuthUpdateWithWhereUniqueWithoutUsersInput | UsersAuthUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UsersAuthUpdateManyWithWhereWithoutUsersInput | UsersAuthUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UsersAuthScalarWhereInput | UsersAuthScalarWhereInput[]
  }

  export type UsersGroupsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UsersGroupsCreateWithoutUsersInput, UsersGroupsUncheckedCreateWithoutUsersInput> | UsersGroupsCreateWithoutUsersInput[] | UsersGroupsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UsersGroupsCreateOrConnectWithoutUsersInput | UsersGroupsCreateOrConnectWithoutUsersInput[]
    upsert?: UsersGroupsUpsertWithWhereUniqueWithoutUsersInput | UsersGroupsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: UsersGroupsCreateManyUsersInputEnvelope
    set?: UsersGroupsWhereUniqueInput | UsersGroupsWhereUniqueInput[]
    disconnect?: UsersGroupsWhereUniqueInput | UsersGroupsWhereUniqueInput[]
    delete?: UsersGroupsWhereUniqueInput | UsersGroupsWhereUniqueInput[]
    connect?: UsersGroupsWhereUniqueInput | UsersGroupsWhereUniqueInput[]
    update?: UsersGroupsUpdateWithWhereUniqueWithoutUsersInput | UsersGroupsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UsersGroupsUpdateManyWithWhereWithoutUsersInput | UsersGroupsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UsersGroupsScalarWhereInput | UsersGroupsScalarWhereInput[]
  }

  export type UsersLoginUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UsersLoginCreateWithoutUsersInput, UsersLoginUncheckedCreateWithoutUsersInput> | UsersLoginCreateWithoutUsersInput[] | UsersLoginUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UsersLoginCreateOrConnectWithoutUsersInput | UsersLoginCreateOrConnectWithoutUsersInput[]
    upsert?: UsersLoginUpsertWithWhereUniqueWithoutUsersInput | UsersLoginUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: UsersLoginCreateManyUsersInputEnvelope
    set?: UsersLoginWhereUniqueInput | UsersLoginWhereUniqueInput[]
    disconnect?: UsersLoginWhereUniqueInput | UsersLoginWhereUniqueInput[]
    delete?: UsersLoginWhereUniqueInput | UsersLoginWhereUniqueInput[]
    connect?: UsersLoginWhereUniqueInput | UsersLoginWhereUniqueInput[]
    update?: UsersLoginUpdateWithWhereUniqueWithoutUsersInput | UsersLoginUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UsersLoginUpdateManyWithWhereWithoutUsersInput | UsersLoginUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UsersLoginScalarWhereInput | UsersLoginScalarWhereInput[]
  }

  export type UsersRelationsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UsersRelationsCreateWithoutUsersInput, UsersRelationsUncheckedCreateWithoutUsersInput> | UsersRelationsCreateWithoutUsersInput[] | UsersRelationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UsersRelationsCreateOrConnectWithoutUsersInput | UsersRelationsCreateOrConnectWithoutUsersInput[]
    upsert?: UsersRelationsUpsertWithWhereUniqueWithoutUsersInput | UsersRelationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: UsersRelationsCreateManyUsersInputEnvelope
    set?: UsersRelationsWhereUniqueInput | UsersRelationsWhereUniqueInput[]
    disconnect?: UsersRelationsWhereUniqueInput | UsersRelationsWhereUniqueInput[]
    delete?: UsersRelationsWhereUniqueInput | UsersRelationsWhereUniqueInput[]
    connect?: UsersRelationsWhereUniqueInput | UsersRelationsWhereUniqueInput[]
    update?: UsersRelationsUpdateWithWhereUniqueWithoutUsersInput | UsersRelationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UsersRelationsUpdateManyWithWhereWithoutUsersInput | UsersRelationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UsersRelationsScalarWhereInput | UsersRelationsScalarWhereInput[]
  }

  export type AuthorizationsCreateNestedOneWithoutUsersAuthInput = {
    create?: XOR<AuthorizationsCreateWithoutUsersAuthInput, AuthorizationsUncheckedCreateWithoutUsersAuthInput>
    connectOrCreate?: AuthorizationsCreateOrConnectWithoutUsersAuthInput
    connect?: AuthorizationsWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutUsersAuthInput = {
    create?: XOR<UsersCreateWithoutUsersAuthInput, UsersUncheckedCreateWithoutUsersAuthInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUsersAuthInput
    connect?: UsersWhereUniqueInput
  }

  export type AuthorizationsUpdateOneRequiredWithoutUsersAuthNestedInput = {
    create?: XOR<AuthorizationsCreateWithoutUsersAuthInput, AuthorizationsUncheckedCreateWithoutUsersAuthInput>
    connectOrCreate?: AuthorizationsCreateOrConnectWithoutUsersAuthInput
    upsert?: AuthorizationsUpsertWithoutUsersAuthInput
    connect?: AuthorizationsWhereUniqueInput
    update?: XOR<XOR<AuthorizationsUpdateToOneWithWhereWithoutUsersAuthInput, AuthorizationsUpdateWithoutUsersAuthInput>, AuthorizationsUncheckedUpdateWithoutUsersAuthInput>
  }

  export type UsersUpdateOneRequiredWithoutUsersAuthNestedInput = {
    create?: XOR<UsersCreateWithoutUsersAuthInput, UsersUncheckedCreateWithoutUsersAuthInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUsersAuthInput
    upsert?: UsersUpsertWithoutUsersAuthInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutUsersAuthInput, UsersUpdateWithoutUsersAuthInput>, UsersUncheckedUpdateWithoutUsersAuthInput>
  }

  export type GroupsCreateNestedOneWithoutUsersGroupsInput = {
    create?: XOR<GroupsCreateWithoutUsersGroupsInput, GroupsUncheckedCreateWithoutUsersGroupsInput>
    connectOrCreate?: GroupsCreateOrConnectWithoutUsersGroupsInput
    connect?: GroupsWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutUsersGroupsInput = {
    create?: XOR<UsersCreateWithoutUsersGroupsInput, UsersUncheckedCreateWithoutUsersGroupsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUsersGroupsInput
    connect?: UsersWhereUniqueInput
  }

  export type GroupsUpdateOneRequiredWithoutUsersGroupsNestedInput = {
    create?: XOR<GroupsCreateWithoutUsersGroupsInput, GroupsUncheckedCreateWithoutUsersGroupsInput>
    connectOrCreate?: GroupsCreateOrConnectWithoutUsersGroupsInput
    upsert?: GroupsUpsertWithoutUsersGroupsInput
    connect?: GroupsWhereUniqueInput
    update?: XOR<XOR<GroupsUpdateToOneWithWhereWithoutUsersGroupsInput, GroupsUpdateWithoutUsersGroupsInput>, GroupsUncheckedUpdateWithoutUsersGroupsInput>
  }

  export type UsersUpdateOneRequiredWithoutUsersGroupsNestedInput = {
    create?: XOR<UsersCreateWithoutUsersGroupsInput, UsersUncheckedCreateWithoutUsersGroupsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUsersGroupsInput
    upsert?: UsersUpsertWithoutUsersGroupsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutUsersGroupsInput, UsersUpdateWithoutUsersGroupsInput>, UsersUncheckedUpdateWithoutUsersGroupsInput>
  }

  export type UsersCreateNestedOneWithoutUsersLoginInput = {
    create?: XOR<UsersCreateWithoutUsersLoginInput, UsersUncheckedCreateWithoutUsersLoginInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUsersLoginInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutUsersLoginNestedInput = {
    create?: XOR<UsersCreateWithoutUsersLoginInput, UsersUncheckedCreateWithoutUsersLoginInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUsersLoginInput
    upsert?: UsersUpsertWithoutUsersLoginInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutUsersLoginInput, UsersUpdateWithoutUsersLoginInput>, UsersUncheckedUpdateWithoutUsersLoginInput>
  }

  export type RelationsCreateNestedOneWithoutUsersRelationsInput = {
    create?: XOR<RelationsCreateWithoutUsersRelationsInput, RelationsUncheckedCreateWithoutUsersRelationsInput>
    connectOrCreate?: RelationsCreateOrConnectWithoutUsersRelationsInput
    connect?: RelationsWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutUsersRelationsInput = {
    create?: XOR<UsersCreateWithoutUsersRelationsInput, UsersUncheckedCreateWithoutUsersRelationsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUsersRelationsInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersRelationsDetailsCreateNestedManyWithoutUsersRelationsInput = {
    create?: XOR<UsersRelationsDetailsCreateWithoutUsersRelationsInput, UsersRelationsDetailsUncheckedCreateWithoutUsersRelationsInput> | UsersRelationsDetailsCreateWithoutUsersRelationsInput[] | UsersRelationsDetailsUncheckedCreateWithoutUsersRelationsInput[]
    connectOrCreate?: UsersRelationsDetailsCreateOrConnectWithoutUsersRelationsInput | UsersRelationsDetailsCreateOrConnectWithoutUsersRelationsInput[]
    createMany?: UsersRelationsDetailsCreateManyUsersRelationsInputEnvelope
    connect?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
  }

  export type UsersRelationsDetailsUncheckedCreateNestedManyWithoutUsersRelationsInput = {
    create?: XOR<UsersRelationsDetailsCreateWithoutUsersRelationsInput, UsersRelationsDetailsUncheckedCreateWithoutUsersRelationsInput> | UsersRelationsDetailsCreateWithoutUsersRelationsInput[] | UsersRelationsDetailsUncheckedCreateWithoutUsersRelationsInput[]
    connectOrCreate?: UsersRelationsDetailsCreateOrConnectWithoutUsersRelationsInput | UsersRelationsDetailsCreateOrConnectWithoutUsersRelationsInput[]
    createMany?: UsersRelationsDetailsCreateManyUsersRelationsInputEnvelope
    connect?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
  }

  export type RelationsUpdateOneRequiredWithoutUsersRelationsNestedInput = {
    create?: XOR<RelationsCreateWithoutUsersRelationsInput, RelationsUncheckedCreateWithoutUsersRelationsInput>
    connectOrCreate?: RelationsCreateOrConnectWithoutUsersRelationsInput
    upsert?: RelationsUpsertWithoutUsersRelationsInput
    connect?: RelationsWhereUniqueInput
    update?: XOR<XOR<RelationsUpdateToOneWithWhereWithoutUsersRelationsInput, RelationsUpdateWithoutUsersRelationsInput>, RelationsUncheckedUpdateWithoutUsersRelationsInput>
  }

  export type UsersUpdateOneRequiredWithoutUsersRelationsNestedInput = {
    create?: XOR<UsersCreateWithoutUsersRelationsInput, UsersUncheckedCreateWithoutUsersRelationsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutUsersRelationsInput
    upsert?: UsersUpsertWithoutUsersRelationsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutUsersRelationsInput, UsersUpdateWithoutUsersRelationsInput>, UsersUncheckedUpdateWithoutUsersRelationsInput>
  }

  export type UsersRelationsDetailsUpdateManyWithoutUsersRelationsNestedInput = {
    create?: XOR<UsersRelationsDetailsCreateWithoutUsersRelationsInput, UsersRelationsDetailsUncheckedCreateWithoutUsersRelationsInput> | UsersRelationsDetailsCreateWithoutUsersRelationsInput[] | UsersRelationsDetailsUncheckedCreateWithoutUsersRelationsInput[]
    connectOrCreate?: UsersRelationsDetailsCreateOrConnectWithoutUsersRelationsInput | UsersRelationsDetailsCreateOrConnectWithoutUsersRelationsInput[]
    upsert?: UsersRelationsDetailsUpsertWithWhereUniqueWithoutUsersRelationsInput | UsersRelationsDetailsUpsertWithWhereUniqueWithoutUsersRelationsInput[]
    createMany?: UsersRelationsDetailsCreateManyUsersRelationsInputEnvelope
    set?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
    disconnect?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
    delete?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
    connect?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
    update?: UsersRelationsDetailsUpdateWithWhereUniqueWithoutUsersRelationsInput | UsersRelationsDetailsUpdateWithWhereUniqueWithoutUsersRelationsInput[]
    updateMany?: UsersRelationsDetailsUpdateManyWithWhereWithoutUsersRelationsInput | UsersRelationsDetailsUpdateManyWithWhereWithoutUsersRelationsInput[]
    deleteMany?: UsersRelationsDetailsScalarWhereInput | UsersRelationsDetailsScalarWhereInput[]
  }

  export type UsersRelationsDetailsUncheckedUpdateManyWithoutUsersRelationsNestedInput = {
    create?: XOR<UsersRelationsDetailsCreateWithoutUsersRelationsInput, UsersRelationsDetailsUncheckedCreateWithoutUsersRelationsInput> | UsersRelationsDetailsCreateWithoutUsersRelationsInput[] | UsersRelationsDetailsUncheckedCreateWithoutUsersRelationsInput[]
    connectOrCreate?: UsersRelationsDetailsCreateOrConnectWithoutUsersRelationsInput | UsersRelationsDetailsCreateOrConnectWithoutUsersRelationsInput[]
    upsert?: UsersRelationsDetailsUpsertWithWhereUniqueWithoutUsersRelationsInput | UsersRelationsDetailsUpsertWithWhereUniqueWithoutUsersRelationsInput[]
    createMany?: UsersRelationsDetailsCreateManyUsersRelationsInputEnvelope
    set?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
    disconnect?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
    delete?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
    connect?: UsersRelationsDetailsWhereUniqueInput | UsersRelationsDetailsWhereUniqueInput[]
    update?: UsersRelationsDetailsUpdateWithWhereUniqueWithoutUsersRelationsInput | UsersRelationsDetailsUpdateWithWhereUniqueWithoutUsersRelationsInput[]
    updateMany?: UsersRelationsDetailsUpdateManyWithWhereWithoutUsersRelationsInput | UsersRelationsDetailsUpdateManyWithWhereWithoutUsersRelationsInput[]
    deleteMany?: UsersRelationsDetailsScalarWhereInput | UsersRelationsDetailsScalarWhereInput[]
  }

  export type UsersRelationsCreateNestedOneWithoutUsersRelationsDetailsInput = {
    create?: XOR<UsersRelationsCreateWithoutUsersRelationsDetailsInput, UsersRelationsUncheckedCreateWithoutUsersRelationsDetailsInput>
    connectOrCreate?: UsersRelationsCreateOrConnectWithoutUsersRelationsDetailsInput
    connect?: UsersRelationsWhereUniqueInput
  }

  export type RelationsChoicesCreateNestedOneWithoutUsersRelationsDetailsInput = {
    create?: XOR<RelationsChoicesCreateWithoutUsersRelationsDetailsInput, RelationsChoicesUncheckedCreateWithoutUsersRelationsDetailsInput>
    connectOrCreate?: RelationsChoicesCreateOrConnectWithoutUsersRelationsDetailsInput
    connect?: RelationsChoicesWhereUniqueInput
  }

  export type RelationsQuestionsCreateNestedOneWithoutUsersRelationsDetailsInput = {
    create?: XOR<RelationsQuestionsCreateWithoutUsersRelationsDetailsInput, RelationsQuestionsUncheckedCreateWithoutUsersRelationsDetailsInput>
    connectOrCreate?: RelationsQuestionsCreateOrConnectWithoutUsersRelationsDetailsInput
    connect?: RelationsQuestionsWhereUniqueInput
  }

  export type UsersRelationsUpdateOneRequiredWithoutUsersRelationsDetailsNestedInput = {
    create?: XOR<UsersRelationsCreateWithoutUsersRelationsDetailsInput, UsersRelationsUncheckedCreateWithoutUsersRelationsDetailsInput>
    connectOrCreate?: UsersRelationsCreateOrConnectWithoutUsersRelationsDetailsInput
    upsert?: UsersRelationsUpsertWithoutUsersRelationsDetailsInput
    connect?: UsersRelationsWhereUniqueInput
    update?: XOR<XOR<UsersRelationsUpdateToOneWithWhereWithoutUsersRelationsDetailsInput, UsersRelationsUpdateWithoutUsersRelationsDetailsInput>, UsersRelationsUncheckedUpdateWithoutUsersRelationsDetailsInput>
  }

  export type RelationsChoicesUpdateOneRequiredWithoutUsersRelationsDetailsNestedInput = {
    create?: XOR<RelationsChoicesCreateWithoutUsersRelationsDetailsInput, RelationsChoicesUncheckedCreateWithoutUsersRelationsDetailsInput>
    connectOrCreate?: RelationsChoicesCreateOrConnectWithoutUsersRelationsDetailsInput
    upsert?: RelationsChoicesUpsertWithoutUsersRelationsDetailsInput
    connect?: RelationsChoicesWhereUniqueInput
    update?: XOR<XOR<RelationsChoicesUpdateToOneWithWhereWithoutUsersRelationsDetailsInput, RelationsChoicesUpdateWithoutUsersRelationsDetailsInput>, RelationsChoicesUncheckedUpdateWithoutUsersRelationsDetailsInput>
  }

  export type RelationsQuestionsUpdateOneRequiredWithoutUsersRelationsDetailsNestedInput = {
    create?: XOR<RelationsQuestionsCreateWithoutUsersRelationsDetailsInput, RelationsQuestionsUncheckedCreateWithoutUsersRelationsDetailsInput>
    connectOrCreate?: RelationsQuestionsCreateOrConnectWithoutUsersRelationsDetailsInput
    upsert?: RelationsQuestionsUpsertWithoutUsersRelationsDetailsInput
    connect?: RelationsQuestionsWhereUniqueInput
    update?: XOR<XOR<RelationsQuestionsUpdateToOneWithWhereWithoutUsersRelationsDetailsInput, RelationsQuestionsUpdateWithoutUsersRelationsDetailsInput>, RelationsQuestionsUncheckedUpdateWithoutUsersRelationsDetailsInput>
  }

  export type UsersCreateNestedManyWithoutLocationsInput = {
    create?: XOR<UsersCreateWithoutLocationsInput, UsersUncheckedCreateWithoutLocationsInput> | UsersCreateWithoutLocationsInput[] | UsersUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutLocationsInput | UsersCreateOrConnectWithoutLocationsInput[]
    createMany?: UsersCreateManyLocationsInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type UsersUncheckedCreateNestedManyWithoutLocationsInput = {
    create?: XOR<UsersCreateWithoutLocationsInput, UsersUncheckedCreateWithoutLocationsInput> | UsersCreateWithoutLocationsInput[] | UsersUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutLocationsInput | UsersCreateOrConnectWithoutLocationsInput[]
    createMany?: UsersCreateManyLocationsInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type UsersUpdateManyWithoutLocationsNestedInput = {
    create?: XOR<UsersCreateWithoutLocationsInput, UsersUncheckedCreateWithoutLocationsInput> | UsersCreateWithoutLocationsInput[] | UsersUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutLocationsInput | UsersCreateOrConnectWithoutLocationsInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutLocationsInput | UsersUpsertWithWhereUniqueWithoutLocationsInput[]
    createMany?: UsersCreateManyLocationsInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutLocationsInput | UsersUpdateWithWhereUniqueWithoutLocationsInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutLocationsInput | UsersUpdateManyWithWhereWithoutLocationsInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type UsersUncheckedUpdateManyWithoutLocationsNestedInput = {
    create?: XOR<UsersCreateWithoutLocationsInput, UsersUncheckedCreateWithoutLocationsInput> | UsersCreateWithoutLocationsInput[] | UsersUncheckedCreateWithoutLocationsInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutLocationsInput | UsersCreateOrConnectWithoutLocationsInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutLocationsInput | UsersUpsertWithWhereUniqueWithoutLocationsInput[]
    createMany?: UsersCreateManyLocationsInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutLocationsInput | UsersUpdateWithWhereUniqueWithoutLocationsInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutLocationsInput | UsersUpdateManyWithWhereWithoutLocationsInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ChoicesLangCreateWithoutAudioInput = {
    id?: bigint | number
    text: string
    hint?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Choices: ChoicesCreateNestedOneWithoutChoicesLangInput
    Languages: LanguagesCreateNestedOneWithoutChoicesLangInput
  }

  export type ChoicesLangUncheckedCreateWithoutAudioInput = {
    id?: bigint | number
    chId: bigint | number
    lang: bigint | number
    text: string
    hint?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type ChoicesLangCreateOrConnectWithoutAudioInput = {
    where: ChoicesLangWhereUniqueInput
    create: XOR<ChoicesLangCreateWithoutAudioInput, ChoicesLangUncheckedCreateWithoutAudioInput>
  }

  export type ChoicesLangCreateManyAudioInputEnvelope = {
    data: ChoicesLangCreateManyAudioInput | ChoicesLangCreateManyAudioInput[]
    skipDuplicates?: boolean
  }

  export type GroupsLangCreateWithoutAudioInput = {
    id?: bigint | number
    name: string
    desc?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Groups: GroupsCreateNestedOneWithoutGroupsLangInput
    Languages: LanguagesCreateNestedOneWithoutGroupsLangInput
  }

  export type GroupsLangUncheckedCreateWithoutAudioInput = {
    id?: bigint | number
    gpId: bigint | number
    lang: bigint | number
    name: string
    desc?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type GroupsLangCreateOrConnectWithoutAudioInput = {
    where: GroupsLangWhereUniqueInput
    create: XOR<GroupsLangCreateWithoutAudioInput, GroupsLangUncheckedCreateWithoutAudioInput>
  }

  export type GroupsLangCreateManyAudioInputEnvelope = {
    data: GroupsLangCreateManyAudioInput | GroupsLangCreateManyAudioInput[]
    skipDuplicates?: boolean
  }

  export type LicensesLangCreateWithoutAudioInput = {
    id?: bigint | number
    name: string
    desc?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Licenses: LicensesCreateNestedOneWithoutLicensesLangInput
    Languages: LanguagesCreateNestedOneWithoutLicensesLangInput
  }

  export type LicensesLangUncheckedCreateWithoutAudioInput = {
    id?: bigint | number
    liId: bigint | number
    lang: bigint | number
    name: string
    desc?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type LicensesLangCreateOrConnectWithoutAudioInput = {
    where: LicensesLangWhereUniqueInput
    create: XOR<LicensesLangCreateWithoutAudioInput, LicensesLangUncheckedCreateWithoutAudioInput>
  }

  export type LicensesLangCreateManyAudioInputEnvelope = {
    data: LicensesLangCreateManyAudioInput | LicensesLangCreateManyAudioInput[]
    skipDuplicates?: boolean
  }

  export type QuizzesLangCreateWithoutAudioInput = {
    id?: bigint | number
    name: string
    desc?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Quizzes: QuizzesCreateNestedOneWithoutQuizzesLangInput
    Languages: LanguagesCreateNestedOneWithoutQuizzesLangInput
  }

  export type QuizzesLangUncheckedCreateWithoutAudioInput = {
    id?: bigint | number
    qzId: bigint | number
    lang: bigint | number
    name: string
    desc?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type QuizzesLangCreateOrConnectWithoutAudioInput = {
    where: QuizzesLangWhereUniqueInput
    create: XOR<QuizzesLangCreateWithoutAudioInput, QuizzesLangUncheckedCreateWithoutAudioInput>
  }

  export type QuizzesLangCreateManyAudioInputEnvelope = {
    data: QuizzesLangCreateManyAudioInput | QuizzesLangCreateManyAudioInput[]
    skipDuplicates?: boolean
  }

  export type QuestionsLangCreateWithoutAudioInput = {
    id?: bigint | number
    text: string
    hint?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Questions: QuestionsCreateNestedOneWithoutQuestionsLangInput
    Languages: LanguagesCreateNestedOneWithoutQuestionsLangInput
  }

  export type QuestionsLangUncheckedCreateWithoutAudioInput = {
    id?: bigint | number
    qsId: bigint | number
    lang: bigint | number
    text: string
    hint?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type QuestionsLangCreateOrConnectWithoutAudioInput = {
    where: QuestionsLangWhereUniqueInput
    create: XOR<QuestionsLangCreateWithoutAudioInput, QuestionsLangUncheckedCreateWithoutAudioInput>
  }

  export type QuestionsLangCreateManyAudioInputEnvelope = {
    data: QuestionsLangCreateManyAudioInput | QuestionsLangCreateManyAudioInput[]
    skipDuplicates?: boolean
  }

  export type ChoicesLangUpsertWithWhereUniqueWithoutAudioInput = {
    where: ChoicesLangWhereUniqueInput
    update: XOR<ChoicesLangUpdateWithoutAudioInput, ChoicesLangUncheckedUpdateWithoutAudioInput>
    create: XOR<ChoicesLangCreateWithoutAudioInput, ChoicesLangUncheckedCreateWithoutAudioInput>
  }

  export type ChoicesLangUpdateWithWhereUniqueWithoutAudioInput = {
    where: ChoicesLangWhereUniqueInput
    data: XOR<ChoicesLangUpdateWithoutAudioInput, ChoicesLangUncheckedUpdateWithoutAudioInput>
  }

  export type ChoicesLangUpdateManyWithWhereWithoutAudioInput = {
    where: ChoicesLangScalarWhereInput
    data: XOR<ChoicesLangUpdateManyMutationInput, ChoicesLangUncheckedUpdateManyWithoutAudioInput>
  }

  export type ChoicesLangScalarWhereInput = {
    AND?: ChoicesLangScalarWhereInput | ChoicesLangScalarWhereInput[]
    OR?: ChoicesLangScalarWhereInput[]
    NOT?: ChoicesLangScalarWhereInput | ChoicesLangScalarWhereInput[]
    id?: BigIntFilter<"ChoicesLang"> | bigint | number
    chId?: BigIntFilter<"ChoicesLang"> | bigint | number
    lang?: BigIntFilter<"ChoicesLang"> | bigint | number
    text?: StringFilter<"ChoicesLang"> | string
    hint?: StringNullableFilter<"ChoicesLang"> | string | null
    audio?: BigIntNullableFilter<"ChoicesLang"> | bigint | number | null
    createdAt?: DateTimeNullableFilter<"ChoicesLang"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"ChoicesLang"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"ChoicesLang"> | Date | string | null
  }

  export type GroupsLangUpsertWithWhereUniqueWithoutAudioInput = {
    where: GroupsLangWhereUniqueInput
    update: XOR<GroupsLangUpdateWithoutAudioInput, GroupsLangUncheckedUpdateWithoutAudioInput>
    create: XOR<GroupsLangCreateWithoutAudioInput, GroupsLangUncheckedCreateWithoutAudioInput>
  }

  export type GroupsLangUpdateWithWhereUniqueWithoutAudioInput = {
    where: GroupsLangWhereUniqueInput
    data: XOR<GroupsLangUpdateWithoutAudioInput, GroupsLangUncheckedUpdateWithoutAudioInput>
  }

  export type GroupsLangUpdateManyWithWhereWithoutAudioInput = {
    where: GroupsLangScalarWhereInput
    data: XOR<GroupsLangUpdateManyMutationInput, GroupsLangUncheckedUpdateManyWithoutAudioInput>
  }

  export type GroupsLangScalarWhereInput = {
    AND?: GroupsLangScalarWhereInput | GroupsLangScalarWhereInput[]
    OR?: GroupsLangScalarWhereInput[]
    NOT?: GroupsLangScalarWhereInput | GroupsLangScalarWhereInput[]
    id?: BigIntFilter<"GroupsLang"> | bigint | number
    gpId?: BigIntFilter<"GroupsLang"> | bigint | number
    lang?: BigIntFilter<"GroupsLang"> | bigint | number
    name?: StringFilter<"GroupsLang"> | string
    desc?: StringNullableFilter<"GroupsLang"> | string | null
    audio?: BigIntNullableFilter<"GroupsLang"> | bigint | number | null
    createdAt?: DateTimeNullableFilter<"GroupsLang"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"GroupsLang"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"GroupsLang"> | Date | string | null
  }

  export type LicensesLangUpsertWithWhereUniqueWithoutAudioInput = {
    where: LicensesLangWhereUniqueInput
    update: XOR<LicensesLangUpdateWithoutAudioInput, LicensesLangUncheckedUpdateWithoutAudioInput>
    create: XOR<LicensesLangCreateWithoutAudioInput, LicensesLangUncheckedCreateWithoutAudioInput>
  }

  export type LicensesLangUpdateWithWhereUniqueWithoutAudioInput = {
    where: LicensesLangWhereUniqueInput
    data: XOR<LicensesLangUpdateWithoutAudioInput, LicensesLangUncheckedUpdateWithoutAudioInput>
  }

  export type LicensesLangUpdateManyWithWhereWithoutAudioInput = {
    where: LicensesLangScalarWhereInput
    data: XOR<LicensesLangUpdateManyMutationInput, LicensesLangUncheckedUpdateManyWithoutAudioInput>
  }

  export type LicensesLangScalarWhereInput = {
    AND?: LicensesLangScalarWhereInput | LicensesLangScalarWhereInput[]
    OR?: LicensesLangScalarWhereInput[]
    NOT?: LicensesLangScalarWhereInput | LicensesLangScalarWhereInput[]
    id?: BigIntFilter<"LicensesLang"> | bigint | number
    liId?: BigIntFilter<"LicensesLang"> | bigint | number
    lang?: BigIntFilter<"LicensesLang"> | bigint | number
    name?: StringFilter<"LicensesLang"> | string
    desc?: StringNullableFilter<"LicensesLang"> | string | null
    audio?: BigIntNullableFilter<"LicensesLang"> | bigint | number | null
    createdAt?: DateTimeNullableFilter<"LicensesLang"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"LicensesLang"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"LicensesLang"> | Date | string | null
  }

  export type QuizzesLangUpsertWithWhereUniqueWithoutAudioInput = {
    where: QuizzesLangWhereUniqueInput
    update: XOR<QuizzesLangUpdateWithoutAudioInput, QuizzesLangUncheckedUpdateWithoutAudioInput>
    create: XOR<QuizzesLangCreateWithoutAudioInput, QuizzesLangUncheckedCreateWithoutAudioInput>
  }

  export type QuizzesLangUpdateWithWhereUniqueWithoutAudioInput = {
    where: QuizzesLangWhereUniqueInput
    data: XOR<QuizzesLangUpdateWithoutAudioInput, QuizzesLangUncheckedUpdateWithoutAudioInput>
  }

  export type QuizzesLangUpdateManyWithWhereWithoutAudioInput = {
    where: QuizzesLangScalarWhereInput
    data: XOR<QuizzesLangUpdateManyMutationInput, QuizzesLangUncheckedUpdateManyWithoutAudioInput>
  }

  export type QuizzesLangScalarWhereInput = {
    AND?: QuizzesLangScalarWhereInput | QuizzesLangScalarWhereInput[]
    OR?: QuizzesLangScalarWhereInput[]
    NOT?: QuizzesLangScalarWhereInput | QuizzesLangScalarWhereInput[]
    id?: BigIntFilter<"QuizzesLang"> | bigint | number
    qzId?: BigIntFilter<"QuizzesLang"> | bigint | number
    lang?: BigIntFilter<"QuizzesLang"> | bigint | number
    name?: StringFilter<"QuizzesLang"> | string
    desc?: StringNullableFilter<"QuizzesLang"> | string | null
    audio?: BigIntNullableFilter<"QuizzesLang"> | bigint | number | null
    createdAt?: DateTimeNullableFilter<"QuizzesLang"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"QuizzesLang"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"QuizzesLang"> | Date | string | null
  }

  export type QuestionsLangUpsertWithWhereUniqueWithoutAudioInput = {
    where: QuestionsLangWhereUniqueInput
    update: XOR<QuestionsLangUpdateWithoutAudioInput, QuestionsLangUncheckedUpdateWithoutAudioInput>
    create: XOR<QuestionsLangCreateWithoutAudioInput, QuestionsLangUncheckedCreateWithoutAudioInput>
  }

  export type QuestionsLangUpdateWithWhereUniqueWithoutAudioInput = {
    where: QuestionsLangWhereUniqueInput
    data: XOR<QuestionsLangUpdateWithoutAudioInput, QuestionsLangUncheckedUpdateWithoutAudioInput>
  }

  export type QuestionsLangUpdateManyWithWhereWithoutAudioInput = {
    where: QuestionsLangScalarWhereInput
    data: XOR<QuestionsLangUpdateManyMutationInput, QuestionsLangUncheckedUpdateManyWithoutAudioInput>
  }

  export type QuestionsLangScalarWhereInput = {
    AND?: QuestionsLangScalarWhereInput | QuestionsLangScalarWhereInput[]
    OR?: QuestionsLangScalarWhereInput[]
    NOT?: QuestionsLangScalarWhereInput | QuestionsLangScalarWhereInput[]
    id?: BigIntFilter<"QuestionsLang"> | bigint | number
    qsId?: BigIntFilter<"QuestionsLang"> | bigint | number
    lang?: BigIntFilter<"QuestionsLang"> | bigint | number
    text?: StringFilter<"QuestionsLang"> | string
    hint?: StringNullableFilter<"QuestionsLang"> | string | null
    audio?: BigIntNullableFilter<"QuestionsLang"> | bigint | number | null
    createdAt?: DateTimeNullableFilter<"QuestionsLang"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"QuestionsLang"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"QuestionsLang"> | Date | string | null
  }

  export type UsersAuthCreateWithoutAuthorizationsInput = {
    id?: bigint | number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Users: UsersCreateNestedOneWithoutUsersAuthInput
  }

  export type UsersAuthUncheckedCreateWithoutAuthorizationsInput = {
    id?: bigint | number
    usId: bigint | number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type UsersAuthCreateOrConnectWithoutAuthorizationsInput = {
    where: UsersAuthWhereUniqueInput
    create: XOR<UsersAuthCreateWithoutAuthorizationsInput, UsersAuthUncheckedCreateWithoutAuthorizationsInput>
  }

  export type UsersAuthCreateManyAuthorizationsInputEnvelope = {
    data: UsersAuthCreateManyAuthorizationsInput | UsersAuthCreateManyAuthorizationsInput[]
    skipDuplicates?: boolean
  }

  export type UsersAuthUpsertWithWhereUniqueWithoutAuthorizationsInput = {
    where: UsersAuthWhereUniqueInput
    update: XOR<UsersAuthUpdateWithoutAuthorizationsInput, UsersAuthUncheckedUpdateWithoutAuthorizationsInput>
    create: XOR<UsersAuthCreateWithoutAuthorizationsInput, UsersAuthUncheckedCreateWithoutAuthorizationsInput>
  }

  export type UsersAuthUpdateWithWhereUniqueWithoutAuthorizationsInput = {
    where: UsersAuthWhereUniqueInput
    data: XOR<UsersAuthUpdateWithoutAuthorizationsInput, UsersAuthUncheckedUpdateWithoutAuthorizationsInput>
  }

  export type UsersAuthUpdateManyWithWhereWithoutAuthorizationsInput = {
    where: UsersAuthScalarWhereInput
    data: XOR<UsersAuthUpdateManyMutationInput, UsersAuthUncheckedUpdateManyWithoutAuthorizationsInput>
  }

  export type UsersAuthScalarWhereInput = {
    AND?: UsersAuthScalarWhereInput | UsersAuthScalarWhereInput[]
    OR?: UsersAuthScalarWhereInput[]
    NOT?: UsersAuthScalarWhereInput | UsersAuthScalarWhereInput[]
    id?: BigIntFilter<"UsersAuth"> | bigint | number
    usId?: BigIntFilter<"UsersAuth"> | bigint | number
    auId?: BigIntFilter<"UsersAuth"> | bigint | number
    createdAt?: DateTimeNullableFilter<"UsersAuth"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"UsersAuth"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"UsersAuth"> | Date | string | null
  }

  export type ChoicesLangCreateWithoutChoicesInput = {
    id?: bigint | number
    text: string
    hint?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Languages: LanguagesCreateNestedOneWithoutChoicesLangInput
    Audio?: AudioCreateNestedOneWithoutChoicesLangInput
  }

  export type ChoicesLangUncheckedCreateWithoutChoicesInput = {
    id?: bigint | number
    lang: bigint | number
    text: string
    hint?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type ChoicesLangCreateOrConnectWithoutChoicesInput = {
    where: ChoicesLangWhereUniqueInput
    create: XOR<ChoicesLangCreateWithoutChoicesInput, ChoicesLangUncheckedCreateWithoutChoicesInput>
  }

  export type ChoicesLangCreateManyChoicesInputEnvelope = {
    data: ChoicesLangCreateManyChoicesInput | ChoicesLangCreateManyChoicesInput[]
    skipDuplicates?: boolean
  }

  export type RelationsChoicesCreateWithoutChoicesInput = {
    id?: bigint | number
    correct?: boolean
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Media?: MediaCreateNestedOneWithoutRelationsChoicesInput
    RelationsQuestions: RelationsQuestionsCreateNestedOneWithoutRelationsChoicesInput
    Relations?: RelationsCreateNestedOneWithoutRelationsChoicesInput
    UsersRelationsDetails?: UsersRelationsDetailsCreateNestedManyWithoutRelationsChoicesInput
  }

  export type RelationsChoicesUncheckedCreateWithoutChoicesInput = {
    id?: bigint | number
    rqId: bigint | number
    mdId?: bigint | number | null
    correct?: boolean
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    relationsId?: bigint | number | null
    UsersRelationsDetails?: UsersRelationsDetailsUncheckedCreateNestedManyWithoutRelationsChoicesInput
  }

  export type RelationsChoicesCreateOrConnectWithoutChoicesInput = {
    where: RelationsChoicesWhereUniqueInput
    create: XOR<RelationsChoicesCreateWithoutChoicesInput, RelationsChoicesUncheckedCreateWithoutChoicesInput>
  }

  export type RelationsChoicesCreateManyChoicesInputEnvelope = {
    data: RelationsChoicesCreateManyChoicesInput | RelationsChoicesCreateManyChoicesInput[]
    skipDuplicates?: boolean
  }

  export type ChoicesLangUpsertWithWhereUniqueWithoutChoicesInput = {
    where: ChoicesLangWhereUniqueInput
    update: XOR<ChoicesLangUpdateWithoutChoicesInput, ChoicesLangUncheckedUpdateWithoutChoicesInput>
    create: XOR<ChoicesLangCreateWithoutChoicesInput, ChoicesLangUncheckedCreateWithoutChoicesInput>
  }

  export type ChoicesLangUpdateWithWhereUniqueWithoutChoicesInput = {
    where: ChoicesLangWhereUniqueInput
    data: XOR<ChoicesLangUpdateWithoutChoicesInput, ChoicesLangUncheckedUpdateWithoutChoicesInput>
  }

  export type ChoicesLangUpdateManyWithWhereWithoutChoicesInput = {
    where: ChoicesLangScalarWhereInput
    data: XOR<ChoicesLangUpdateManyMutationInput, ChoicesLangUncheckedUpdateManyWithoutChoicesInput>
  }

  export type RelationsChoicesUpsertWithWhereUniqueWithoutChoicesInput = {
    where: RelationsChoicesWhereUniqueInput
    update: XOR<RelationsChoicesUpdateWithoutChoicesInput, RelationsChoicesUncheckedUpdateWithoutChoicesInput>
    create: XOR<RelationsChoicesCreateWithoutChoicesInput, RelationsChoicesUncheckedCreateWithoutChoicesInput>
  }

  export type RelationsChoicesUpdateWithWhereUniqueWithoutChoicesInput = {
    where: RelationsChoicesWhereUniqueInput
    data: XOR<RelationsChoicesUpdateWithoutChoicesInput, RelationsChoicesUncheckedUpdateWithoutChoicesInput>
  }

  export type RelationsChoicesUpdateManyWithWhereWithoutChoicesInput = {
    where: RelationsChoicesScalarWhereInput
    data: XOR<RelationsChoicesUpdateManyMutationInput, RelationsChoicesUncheckedUpdateManyWithoutChoicesInput>
  }

  export type RelationsChoicesScalarWhereInput = {
    AND?: RelationsChoicesScalarWhereInput | RelationsChoicesScalarWhereInput[]
    OR?: RelationsChoicesScalarWhereInput[]
    NOT?: RelationsChoicesScalarWhereInput | RelationsChoicesScalarWhereInput[]
    id?: BigIntFilter<"RelationsChoices"> | bigint | number
    rqId?: BigIntFilter<"RelationsChoices"> | bigint | number
    chId?: BigIntFilter<"RelationsChoices"> | bigint | number
    mdId?: BigIntNullableFilter<"RelationsChoices"> | bigint | number | null
    correct?: BoolFilter<"RelationsChoices"> | boolean
    ordering?: IntFilter<"RelationsChoices"> | number
    createdAt?: DateTimeNullableFilter<"RelationsChoices"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelationsChoices"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"RelationsChoices"> | Date | string | null
    relationsId?: BigIntNullableFilter<"RelationsChoices"> | bigint | number | null
  }

  export type ChoicesCreateWithoutChoicesLangInput = {
    id?: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    RelationsChoices?: RelationsChoicesCreateNestedManyWithoutChoicesInput
  }

  export type ChoicesUncheckedCreateWithoutChoicesLangInput = {
    id?: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    RelationsChoices?: RelationsChoicesUncheckedCreateNestedManyWithoutChoicesInput
  }

  export type ChoicesCreateOrConnectWithoutChoicesLangInput = {
    where: ChoicesWhereUniqueInput
    create: XOR<ChoicesCreateWithoutChoicesLangInput, ChoicesUncheckedCreateWithoutChoicesLangInput>
  }

  export type LanguagesCreateWithoutChoicesLangInput = {
    id?: bigint | number
    name: string
    code: string
    voiceCode: string
    voiceType: string
    voiceName: string
    voiceGender: string
    voiceProfile: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    GroupsLang?: GroupsLangCreateNestedManyWithoutLanguagesInput
    LicensesLang?: LicensesLangCreateNestedManyWithoutLanguagesInput
    QuestionsLang?: QuestionsLangCreateNestedManyWithoutLanguagesInput
    QuizzesLang?: QuizzesLangCreateNestedManyWithoutLanguagesInput
  }

  export type LanguagesUncheckedCreateWithoutChoicesLangInput = {
    id?: bigint | number
    name: string
    code: string
    voiceCode: string
    voiceType: string
    voiceName: string
    voiceGender: string
    voiceProfile: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    GroupsLang?: GroupsLangUncheckedCreateNestedManyWithoutLanguagesInput
    LicensesLang?: LicensesLangUncheckedCreateNestedManyWithoutLanguagesInput
    QuestionsLang?: QuestionsLangUncheckedCreateNestedManyWithoutLanguagesInput
    QuizzesLang?: QuizzesLangUncheckedCreateNestedManyWithoutLanguagesInput
  }

  export type LanguagesCreateOrConnectWithoutChoicesLangInput = {
    where: LanguagesWhereUniqueInput
    create: XOR<LanguagesCreateWithoutChoicesLangInput, LanguagesUncheckedCreateWithoutChoicesLangInput>
  }

  export type AudioCreateWithoutChoicesLangInput = {
    id?: bigint | number
    name: string
    url: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    GroupsLang?: GroupsLangCreateNestedManyWithoutAudioInput
    LicensesLang?: LicensesLangCreateNestedManyWithoutAudioInput
    QuizzesLang?: QuizzesLangCreateNestedManyWithoutAudioInput
    QuestionsLang?: QuestionsLangCreateNestedManyWithoutAudioInput
  }

  export type AudioUncheckedCreateWithoutChoicesLangInput = {
    id?: bigint | number
    name: string
    url: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    GroupsLang?: GroupsLangUncheckedCreateNestedManyWithoutAudioInput
    LicensesLang?: LicensesLangUncheckedCreateNestedManyWithoutAudioInput
    QuizzesLang?: QuizzesLangUncheckedCreateNestedManyWithoutAudioInput
    QuestionsLang?: QuestionsLangUncheckedCreateNestedManyWithoutAudioInput
  }

  export type AudioCreateOrConnectWithoutChoicesLangInput = {
    where: AudioWhereUniqueInput
    create: XOR<AudioCreateWithoutChoicesLangInput, AudioUncheckedCreateWithoutChoicesLangInput>
  }

  export type ChoicesUpsertWithoutChoicesLangInput = {
    update: XOR<ChoicesUpdateWithoutChoicesLangInput, ChoicesUncheckedUpdateWithoutChoicesLangInput>
    create: XOR<ChoicesCreateWithoutChoicesLangInput, ChoicesUncheckedCreateWithoutChoicesLangInput>
    where?: ChoicesWhereInput
  }

  export type ChoicesUpdateToOneWithWhereWithoutChoicesLangInput = {
    where?: ChoicesWhereInput
    data: XOR<ChoicesUpdateWithoutChoicesLangInput, ChoicesUncheckedUpdateWithoutChoicesLangInput>
  }

  export type ChoicesUpdateWithoutChoicesLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RelationsChoices?: RelationsChoicesUpdateManyWithoutChoicesNestedInput
  }

  export type ChoicesUncheckedUpdateWithoutChoicesLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RelationsChoices?: RelationsChoicesUncheckedUpdateManyWithoutChoicesNestedInput
  }

  export type LanguagesUpsertWithoutChoicesLangInput = {
    update: XOR<LanguagesUpdateWithoutChoicesLangInput, LanguagesUncheckedUpdateWithoutChoicesLangInput>
    create: XOR<LanguagesCreateWithoutChoicesLangInput, LanguagesUncheckedCreateWithoutChoicesLangInput>
    where?: LanguagesWhereInput
  }

  export type LanguagesUpdateToOneWithWhereWithoutChoicesLangInput = {
    where?: LanguagesWhereInput
    data: XOR<LanguagesUpdateWithoutChoicesLangInput, LanguagesUncheckedUpdateWithoutChoicesLangInput>
  }

  export type LanguagesUpdateWithoutChoicesLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    voiceCode?: StringFieldUpdateOperationsInput | string
    voiceType?: StringFieldUpdateOperationsInput | string
    voiceName?: StringFieldUpdateOperationsInput | string
    voiceGender?: StringFieldUpdateOperationsInput | string
    voiceProfile?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GroupsLang?: GroupsLangUpdateManyWithoutLanguagesNestedInput
    LicensesLang?: LicensesLangUpdateManyWithoutLanguagesNestedInput
    QuestionsLang?: QuestionsLangUpdateManyWithoutLanguagesNestedInput
    QuizzesLang?: QuizzesLangUpdateManyWithoutLanguagesNestedInput
  }

  export type LanguagesUncheckedUpdateWithoutChoicesLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    voiceCode?: StringFieldUpdateOperationsInput | string
    voiceType?: StringFieldUpdateOperationsInput | string
    voiceName?: StringFieldUpdateOperationsInput | string
    voiceGender?: StringFieldUpdateOperationsInput | string
    voiceProfile?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GroupsLang?: GroupsLangUncheckedUpdateManyWithoutLanguagesNestedInput
    LicensesLang?: LicensesLangUncheckedUpdateManyWithoutLanguagesNestedInput
    QuestionsLang?: QuestionsLangUncheckedUpdateManyWithoutLanguagesNestedInput
    QuizzesLang?: QuizzesLangUncheckedUpdateManyWithoutLanguagesNestedInput
  }

  export type AudioUpsertWithoutChoicesLangInput = {
    update: XOR<AudioUpdateWithoutChoicesLangInput, AudioUncheckedUpdateWithoutChoicesLangInput>
    create: XOR<AudioCreateWithoutChoicesLangInput, AudioUncheckedCreateWithoutChoicesLangInput>
    where?: AudioWhereInput
  }

  export type AudioUpdateToOneWithWhereWithoutChoicesLangInput = {
    where?: AudioWhereInput
    data: XOR<AudioUpdateWithoutChoicesLangInput, AudioUncheckedUpdateWithoutChoicesLangInput>
  }

  export type AudioUpdateWithoutChoicesLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GroupsLang?: GroupsLangUpdateManyWithoutAudioNestedInput
    LicensesLang?: LicensesLangUpdateManyWithoutAudioNestedInput
    QuizzesLang?: QuizzesLangUpdateManyWithoutAudioNestedInput
    QuestionsLang?: QuestionsLangUpdateManyWithoutAudioNestedInput
  }

  export type AudioUncheckedUpdateWithoutChoicesLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GroupsLang?: GroupsLangUncheckedUpdateManyWithoutAudioNestedInput
    LicensesLang?: LicensesLangUncheckedUpdateManyWithoutAudioNestedInput
    QuizzesLang?: QuizzesLangUncheckedUpdateManyWithoutAudioNestedInput
    QuestionsLang?: QuestionsLangUncheckedUpdateManyWithoutAudioNestedInput
  }

  export type MediaCreateWithoutGroupsInput = {
    id?: bigint | number
    name: string
    extension: string
    url: string
    uploadedName: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Licenses?: LicensesCreateNestedManyWithoutMediaInput
    RelationsChoices?: RelationsChoicesCreateNestedManyWithoutMediaInput
    RelationsQuestions?: RelationsQuestionsCreateNestedManyWithoutMediaInput
    Quizzes?: QuizzesCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutGroupsInput = {
    id?: bigint | number
    name: string
    extension: string
    url: string
    uploadedName: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Licenses?: LicensesUncheckedCreateNestedManyWithoutMediaInput
    RelationsChoices?: RelationsChoicesUncheckedCreateNestedManyWithoutMediaInput
    RelationsQuestions?: RelationsQuestionsUncheckedCreateNestedManyWithoutMediaInput
    Quizzes?: QuizzesUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutGroupsInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutGroupsInput, MediaUncheckedCreateWithoutGroupsInput>
  }

  export type GroupsLangCreateWithoutGroupsInput = {
    id?: bigint | number
    name: string
    desc?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Languages: LanguagesCreateNestedOneWithoutGroupsLangInput
    Audio?: AudioCreateNestedOneWithoutGroupsLangInput
  }

  export type GroupsLangUncheckedCreateWithoutGroupsInput = {
    id?: bigint | number
    lang: bigint | number
    name: string
    desc?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type GroupsLangCreateOrConnectWithoutGroupsInput = {
    where: GroupsLangWhereUniqueInput
    create: XOR<GroupsLangCreateWithoutGroupsInput, GroupsLangUncheckedCreateWithoutGroupsInput>
  }

  export type GroupsLangCreateManyGroupsInputEnvelope = {
    data: GroupsLangCreateManyGroupsInput | GroupsLangCreateManyGroupsInput[]
    skipDuplicates?: boolean
  }

  export type RelationsCreateWithoutGroupsInput = {
    id?: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Licenses: LicensesCreateNestedOneWithoutRelationsInput
    Quizzes: QuizzesCreateNestedOneWithoutRelationsInput
    RelationsChoices?: RelationsChoicesCreateNestedManyWithoutRelationsInput
    RelationsQuestions?: RelationsQuestionsCreateNestedManyWithoutRelationsInput
    UsersRelations?: UsersRelationsCreateNestedManyWithoutRelationsInput
  }

  export type RelationsUncheckedCreateWithoutGroupsInput = {
    id?: bigint | number
    liId: bigint | number
    qzId: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    RelationsChoices?: RelationsChoicesUncheckedCreateNestedManyWithoutRelationsInput
    RelationsQuestions?: RelationsQuestionsUncheckedCreateNestedManyWithoutRelationsInput
    UsersRelations?: UsersRelationsUncheckedCreateNestedManyWithoutRelationsInput
  }

  export type RelationsCreateOrConnectWithoutGroupsInput = {
    where: RelationsWhereUniqueInput
    create: XOR<RelationsCreateWithoutGroupsInput, RelationsUncheckedCreateWithoutGroupsInput>
  }

  export type RelationsCreateManyGroupsInputEnvelope = {
    data: RelationsCreateManyGroupsInput | RelationsCreateManyGroupsInput[]
    skipDuplicates?: boolean
  }

  export type UsersGroupsCreateWithoutGroupsInput = {
    id?: bigint | number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Users: UsersCreateNestedOneWithoutUsersGroupsInput
  }

  export type UsersGroupsUncheckedCreateWithoutGroupsInput = {
    id?: bigint | number
    usId: bigint | number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type UsersGroupsCreateOrConnectWithoutGroupsInput = {
    where: UsersGroupsWhereUniqueInput
    create: XOR<UsersGroupsCreateWithoutGroupsInput, UsersGroupsUncheckedCreateWithoutGroupsInput>
  }

  export type UsersGroupsCreateManyGroupsInputEnvelope = {
    data: UsersGroupsCreateManyGroupsInput | UsersGroupsCreateManyGroupsInput[]
    skipDuplicates?: boolean
  }

  export type MediaUpsertWithoutGroupsInput = {
    update: XOR<MediaUpdateWithoutGroupsInput, MediaUncheckedUpdateWithoutGroupsInput>
    create: XOR<MediaCreateWithoutGroupsInput, MediaUncheckedCreateWithoutGroupsInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutGroupsInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutGroupsInput, MediaUncheckedUpdateWithoutGroupsInput>
  }

  export type MediaUpdateWithoutGroupsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedName?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Licenses?: LicensesUpdateManyWithoutMediaNestedInput
    RelationsChoices?: RelationsChoicesUpdateManyWithoutMediaNestedInput
    RelationsQuestions?: RelationsQuestionsUpdateManyWithoutMediaNestedInput
    Quizzes?: QuizzesUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutGroupsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedName?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Licenses?: LicensesUncheckedUpdateManyWithoutMediaNestedInput
    RelationsChoices?: RelationsChoicesUncheckedUpdateManyWithoutMediaNestedInput
    RelationsQuestions?: RelationsQuestionsUncheckedUpdateManyWithoutMediaNestedInput
    Quizzes?: QuizzesUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type GroupsLangUpsertWithWhereUniqueWithoutGroupsInput = {
    where: GroupsLangWhereUniqueInput
    update: XOR<GroupsLangUpdateWithoutGroupsInput, GroupsLangUncheckedUpdateWithoutGroupsInput>
    create: XOR<GroupsLangCreateWithoutGroupsInput, GroupsLangUncheckedCreateWithoutGroupsInput>
  }

  export type GroupsLangUpdateWithWhereUniqueWithoutGroupsInput = {
    where: GroupsLangWhereUniqueInput
    data: XOR<GroupsLangUpdateWithoutGroupsInput, GroupsLangUncheckedUpdateWithoutGroupsInput>
  }

  export type GroupsLangUpdateManyWithWhereWithoutGroupsInput = {
    where: GroupsLangScalarWhereInput
    data: XOR<GroupsLangUpdateManyMutationInput, GroupsLangUncheckedUpdateManyWithoutGroupsInput>
  }

  export type RelationsUpsertWithWhereUniqueWithoutGroupsInput = {
    where: RelationsWhereUniqueInput
    update: XOR<RelationsUpdateWithoutGroupsInput, RelationsUncheckedUpdateWithoutGroupsInput>
    create: XOR<RelationsCreateWithoutGroupsInput, RelationsUncheckedCreateWithoutGroupsInput>
  }

  export type RelationsUpdateWithWhereUniqueWithoutGroupsInput = {
    where: RelationsWhereUniqueInput
    data: XOR<RelationsUpdateWithoutGroupsInput, RelationsUncheckedUpdateWithoutGroupsInput>
  }

  export type RelationsUpdateManyWithWhereWithoutGroupsInput = {
    where: RelationsScalarWhereInput
    data: XOR<RelationsUpdateManyMutationInput, RelationsUncheckedUpdateManyWithoutGroupsInput>
  }

  export type RelationsScalarWhereInput = {
    AND?: RelationsScalarWhereInput | RelationsScalarWhereInput[]
    OR?: RelationsScalarWhereInput[]
    NOT?: RelationsScalarWhereInput | RelationsScalarWhereInput[]
    id?: BigIntFilter<"Relations"> | bigint | number
    liId?: BigIntFilter<"Relations"> | bigint | number
    gpId?: BigIntFilter<"Relations"> | bigint | number
    qzId?: BigIntFilter<"Relations"> | bigint | number
    enabled?: BoolFilter<"Relations"> | boolean
    createdAt?: DateTimeNullableFilter<"Relations"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Relations"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Relations"> | Date | string | null
  }

  export type UsersGroupsUpsertWithWhereUniqueWithoutGroupsInput = {
    where: UsersGroupsWhereUniqueInput
    update: XOR<UsersGroupsUpdateWithoutGroupsInput, UsersGroupsUncheckedUpdateWithoutGroupsInput>
    create: XOR<UsersGroupsCreateWithoutGroupsInput, UsersGroupsUncheckedCreateWithoutGroupsInput>
  }

  export type UsersGroupsUpdateWithWhereUniqueWithoutGroupsInput = {
    where: UsersGroupsWhereUniqueInput
    data: XOR<UsersGroupsUpdateWithoutGroupsInput, UsersGroupsUncheckedUpdateWithoutGroupsInput>
  }

  export type UsersGroupsUpdateManyWithWhereWithoutGroupsInput = {
    where: UsersGroupsScalarWhereInput
    data: XOR<UsersGroupsUpdateManyMutationInput, UsersGroupsUncheckedUpdateManyWithoutGroupsInput>
  }

  export type UsersGroupsScalarWhereInput = {
    AND?: UsersGroupsScalarWhereInput | UsersGroupsScalarWhereInput[]
    OR?: UsersGroupsScalarWhereInput[]
    NOT?: UsersGroupsScalarWhereInput | UsersGroupsScalarWhereInput[]
    id?: BigIntFilter<"UsersGroups"> | bigint | number
    usId?: BigIntFilter<"UsersGroups"> | bigint | number
    gpId?: BigIntFilter<"UsersGroups"> | bigint | number
    createdAt?: DateTimeNullableFilter<"UsersGroups"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"UsersGroups"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"UsersGroups"> | Date | string | null
  }

  export type GroupsCreateWithoutGroupsLangInput = {
    id?: bigint | number
    code: string
    level?: number
    randCount?: number
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Media?: MediaCreateNestedOneWithoutGroupsInput
    Relations?: RelationsCreateNestedManyWithoutGroupsInput
    UsersGroups?: UsersGroupsCreateNestedManyWithoutGroupsInput
  }

  export type GroupsUncheckedCreateWithoutGroupsLangInput = {
    id?: bigint | number
    code: string
    level?: number
    media?: bigint | number | null
    randCount?: number
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Relations?: RelationsUncheckedCreateNestedManyWithoutGroupsInput
    UsersGroups?: UsersGroupsUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupsCreateOrConnectWithoutGroupsLangInput = {
    where: GroupsWhereUniqueInput
    create: XOR<GroupsCreateWithoutGroupsLangInput, GroupsUncheckedCreateWithoutGroupsLangInput>
  }

  export type LanguagesCreateWithoutGroupsLangInput = {
    id?: bigint | number
    name: string
    code: string
    voiceCode: string
    voiceType: string
    voiceName: string
    voiceGender: string
    voiceProfile: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    ChoicesLang?: ChoicesLangCreateNestedManyWithoutLanguagesInput
    LicensesLang?: LicensesLangCreateNestedManyWithoutLanguagesInput
    QuestionsLang?: QuestionsLangCreateNestedManyWithoutLanguagesInput
    QuizzesLang?: QuizzesLangCreateNestedManyWithoutLanguagesInput
  }

  export type LanguagesUncheckedCreateWithoutGroupsLangInput = {
    id?: bigint | number
    name: string
    code: string
    voiceCode: string
    voiceType: string
    voiceName: string
    voiceGender: string
    voiceProfile: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    ChoicesLang?: ChoicesLangUncheckedCreateNestedManyWithoutLanguagesInput
    LicensesLang?: LicensesLangUncheckedCreateNestedManyWithoutLanguagesInput
    QuestionsLang?: QuestionsLangUncheckedCreateNestedManyWithoutLanguagesInput
    QuizzesLang?: QuizzesLangUncheckedCreateNestedManyWithoutLanguagesInput
  }

  export type LanguagesCreateOrConnectWithoutGroupsLangInput = {
    where: LanguagesWhereUniqueInput
    create: XOR<LanguagesCreateWithoutGroupsLangInput, LanguagesUncheckedCreateWithoutGroupsLangInput>
  }

  export type AudioCreateWithoutGroupsLangInput = {
    id?: bigint | number
    name: string
    url: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    ChoicesLang?: ChoicesLangCreateNestedManyWithoutAudioInput
    LicensesLang?: LicensesLangCreateNestedManyWithoutAudioInput
    QuizzesLang?: QuizzesLangCreateNestedManyWithoutAudioInput
    QuestionsLang?: QuestionsLangCreateNestedManyWithoutAudioInput
  }

  export type AudioUncheckedCreateWithoutGroupsLangInput = {
    id?: bigint | number
    name: string
    url: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    ChoicesLang?: ChoicesLangUncheckedCreateNestedManyWithoutAudioInput
    LicensesLang?: LicensesLangUncheckedCreateNestedManyWithoutAudioInput
    QuizzesLang?: QuizzesLangUncheckedCreateNestedManyWithoutAudioInput
    QuestionsLang?: QuestionsLangUncheckedCreateNestedManyWithoutAudioInput
  }

  export type AudioCreateOrConnectWithoutGroupsLangInput = {
    where: AudioWhereUniqueInput
    create: XOR<AudioCreateWithoutGroupsLangInput, AudioUncheckedCreateWithoutGroupsLangInput>
  }

  export type GroupsUpsertWithoutGroupsLangInput = {
    update: XOR<GroupsUpdateWithoutGroupsLangInput, GroupsUncheckedUpdateWithoutGroupsLangInput>
    create: XOR<GroupsCreateWithoutGroupsLangInput, GroupsUncheckedCreateWithoutGroupsLangInput>
    where?: GroupsWhereInput
  }

  export type GroupsUpdateToOneWithWhereWithoutGroupsLangInput = {
    where?: GroupsWhereInput
    data: XOR<GroupsUpdateWithoutGroupsLangInput, GroupsUncheckedUpdateWithoutGroupsLangInput>
  }

  export type GroupsUpdateWithoutGroupsLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    randCount?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Media?: MediaUpdateOneWithoutGroupsNestedInput
    Relations?: RelationsUpdateManyWithoutGroupsNestedInput
    UsersGroups?: UsersGroupsUpdateManyWithoutGroupsNestedInput
  }

  export type GroupsUncheckedUpdateWithoutGroupsLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    media?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    randCount?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Relations?: RelationsUncheckedUpdateManyWithoutGroupsNestedInput
    UsersGroups?: UsersGroupsUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type LanguagesUpsertWithoutGroupsLangInput = {
    update: XOR<LanguagesUpdateWithoutGroupsLangInput, LanguagesUncheckedUpdateWithoutGroupsLangInput>
    create: XOR<LanguagesCreateWithoutGroupsLangInput, LanguagesUncheckedCreateWithoutGroupsLangInput>
    where?: LanguagesWhereInput
  }

  export type LanguagesUpdateToOneWithWhereWithoutGroupsLangInput = {
    where?: LanguagesWhereInput
    data: XOR<LanguagesUpdateWithoutGroupsLangInput, LanguagesUncheckedUpdateWithoutGroupsLangInput>
  }

  export type LanguagesUpdateWithoutGroupsLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    voiceCode?: StringFieldUpdateOperationsInput | string
    voiceType?: StringFieldUpdateOperationsInput | string
    voiceName?: StringFieldUpdateOperationsInput | string
    voiceGender?: StringFieldUpdateOperationsInput | string
    voiceProfile?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ChoicesLang?: ChoicesLangUpdateManyWithoutLanguagesNestedInput
    LicensesLang?: LicensesLangUpdateManyWithoutLanguagesNestedInput
    QuestionsLang?: QuestionsLangUpdateManyWithoutLanguagesNestedInput
    QuizzesLang?: QuizzesLangUpdateManyWithoutLanguagesNestedInput
  }

  export type LanguagesUncheckedUpdateWithoutGroupsLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    voiceCode?: StringFieldUpdateOperationsInput | string
    voiceType?: StringFieldUpdateOperationsInput | string
    voiceName?: StringFieldUpdateOperationsInput | string
    voiceGender?: StringFieldUpdateOperationsInput | string
    voiceProfile?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ChoicesLang?: ChoicesLangUncheckedUpdateManyWithoutLanguagesNestedInput
    LicensesLang?: LicensesLangUncheckedUpdateManyWithoutLanguagesNestedInput
    QuestionsLang?: QuestionsLangUncheckedUpdateManyWithoutLanguagesNestedInput
    QuizzesLang?: QuizzesLangUncheckedUpdateManyWithoutLanguagesNestedInput
  }

  export type AudioUpsertWithoutGroupsLangInput = {
    update: XOR<AudioUpdateWithoutGroupsLangInput, AudioUncheckedUpdateWithoutGroupsLangInput>
    create: XOR<AudioCreateWithoutGroupsLangInput, AudioUncheckedCreateWithoutGroupsLangInput>
    where?: AudioWhereInput
  }

  export type AudioUpdateToOneWithWhereWithoutGroupsLangInput = {
    where?: AudioWhereInput
    data: XOR<AudioUpdateWithoutGroupsLangInput, AudioUncheckedUpdateWithoutGroupsLangInput>
  }

  export type AudioUpdateWithoutGroupsLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ChoicesLang?: ChoicesLangUpdateManyWithoutAudioNestedInput
    LicensesLang?: LicensesLangUpdateManyWithoutAudioNestedInput
    QuizzesLang?: QuizzesLangUpdateManyWithoutAudioNestedInput
    QuestionsLang?: QuestionsLangUpdateManyWithoutAudioNestedInput
  }

  export type AudioUncheckedUpdateWithoutGroupsLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ChoicesLang?: ChoicesLangUncheckedUpdateManyWithoutAudioNestedInput
    LicensesLang?: LicensesLangUncheckedUpdateManyWithoutAudioNestedInput
    QuizzesLang?: QuizzesLangUncheckedUpdateManyWithoutAudioNestedInput
    QuestionsLang?: QuestionsLangUncheckedUpdateManyWithoutAudioNestedInput
  }

  export type ChoicesLangCreateWithoutLanguagesInput = {
    id?: bigint | number
    text: string
    hint?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Choices: ChoicesCreateNestedOneWithoutChoicesLangInput
    Audio?: AudioCreateNestedOneWithoutChoicesLangInput
  }

  export type ChoicesLangUncheckedCreateWithoutLanguagesInput = {
    id?: bigint | number
    chId: bigint | number
    text: string
    hint?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type ChoicesLangCreateOrConnectWithoutLanguagesInput = {
    where: ChoicesLangWhereUniqueInput
    create: XOR<ChoicesLangCreateWithoutLanguagesInput, ChoicesLangUncheckedCreateWithoutLanguagesInput>
  }

  export type ChoicesLangCreateManyLanguagesInputEnvelope = {
    data: ChoicesLangCreateManyLanguagesInput | ChoicesLangCreateManyLanguagesInput[]
    skipDuplicates?: boolean
  }

  export type GroupsLangCreateWithoutLanguagesInput = {
    id?: bigint | number
    name: string
    desc?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Groups: GroupsCreateNestedOneWithoutGroupsLangInput
    Audio?: AudioCreateNestedOneWithoutGroupsLangInput
  }

  export type GroupsLangUncheckedCreateWithoutLanguagesInput = {
    id?: bigint | number
    gpId: bigint | number
    name: string
    desc?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type GroupsLangCreateOrConnectWithoutLanguagesInput = {
    where: GroupsLangWhereUniqueInput
    create: XOR<GroupsLangCreateWithoutLanguagesInput, GroupsLangUncheckedCreateWithoutLanguagesInput>
  }

  export type GroupsLangCreateManyLanguagesInputEnvelope = {
    data: GroupsLangCreateManyLanguagesInput | GroupsLangCreateManyLanguagesInput[]
    skipDuplicates?: boolean
  }

  export type LicensesLangCreateWithoutLanguagesInput = {
    id?: bigint | number
    name: string
    desc?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Licenses: LicensesCreateNestedOneWithoutLicensesLangInput
    Audio?: AudioCreateNestedOneWithoutLicensesLangInput
  }

  export type LicensesLangUncheckedCreateWithoutLanguagesInput = {
    id?: bigint | number
    liId: bigint | number
    name: string
    desc?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type LicensesLangCreateOrConnectWithoutLanguagesInput = {
    where: LicensesLangWhereUniqueInput
    create: XOR<LicensesLangCreateWithoutLanguagesInput, LicensesLangUncheckedCreateWithoutLanguagesInput>
  }

  export type LicensesLangCreateManyLanguagesInputEnvelope = {
    data: LicensesLangCreateManyLanguagesInput | LicensesLangCreateManyLanguagesInput[]
    skipDuplicates?: boolean
  }

  export type QuestionsLangCreateWithoutLanguagesInput = {
    id?: bigint | number
    text: string
    hint?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Questions: QuestionsCreateNestedOneWithoutQuestionsLangInput
    Audio?: AudioCreateNestedOneWithoutQuestionsLangInput
  }

  export type QuestionsLangUncheckedCreateWithoutLanguagesInput = {
    id?: bigint | number
    qsId: bigint | number
    text: string
    hint?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type QuestionsLangCreateOrConnectWithoutLanguagesInput = {
    where: QuestionsLangWhereUniqueInput
    create: XOR<QuestionsLangCreateWithoutLanguagesInput, QuestionsLangUncheckedCreateWithoutLanguagesInput>
  }

  export type QuestionsLangCreateManyLanguagesInputEnvelope = {
    data: QuestionsLangCreateManyLanguagesInput | QuestionsLangCreateManyLanguagesInput[]
    skipDuplicates?: boolean
  }

  export type QuizzesLangCreateWithoutLanguagesInput = {
    id?: bigint | number
    name: string
    desc?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Quizzes: QuizzesCreateNestedOneWithoutQuizzesLangInput
    Audio?: AudioCreateNestedOneWithoutQuizzesLangInput
  }

  export type QuizzesLangUncheckedCreateWithoutLanguagesInput = {
    id?: bigint | number
    qzId: bigint | number
    name: string
    desc?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type QuizzesLangCreateOrConnectWithoutLanguagesInput = {
    where: QuizzesLangWhereUniqueInput
    create: XOR<QuizzesLangCreateWithoutLanguagesInput, QuizzesLangUncheckedCreateWithoutLanguagesInput>
  }

  export type QuizzesLangCreateManyLanguagesInputEnvelope = {
    data: QuizzesLangCreateManyLanguagesInput | QuizzesLangCreateManyLanguagesInput[]
    skipDuplicates?: boolean
  }

  export type ChoicesLangUpsertWithWhereUniqueWithoutLanguagesInput = {
    where: ChoicesLangWhereUniqueInput
    update: XOR<ChoicesLangUpdateWithoutLanguagesInput, ChoicesLangUncheckedUpdateWithoutLanguagesInput>
    create: XOR<ChoicesLangCreateWithoutLanguagesInput, ChoicesLangUncheckedCreateWithoutLanguagesInput>
  }

  export type ChoicesLangUpdateWithWhereUniqueWithoutLanguagesInput = {
    where: ChoicesLangWhereUniqueInput
    data: XOR<ChoicesLangUpdateWithoutLanguagesInput, ChoicesLangUncheckedUpdateWithoutLanguagesInput>
  }

  export type ChoicesLangUpdateManyWithWhereWithoutLanguagesInput = {
    where: ChoicesLangScalarWhereInput
    data: XOR<ChoicesLangUpdateManyMutationInput, ChoicesLangUncheckedUpdateManyWithoutLanguagesInput>
  }

  export type GroupsLangUpsertWithWhereUniqueWithoutLanguagesInput = {
    where: GroupsLangWhereUniqueInput
    update: XOR<GroupsLangUpdateWithoutLanguagesInput, GroupsLangUncheckedUpdateWithoutLanguagesInput>
    create: XOR<GroupsLangCreateWithoutLanguagesInput, GroupsLangUncheckedCreateWithoutLanguagesInput>
  }

  export type GroupsLangUpdateWithWhereUniqueWithoutLanguagesInput = {
    where: GroupsLangWhereUniqueInput
    data: XOR<GroupsLangUpdateWithoutLanguagesInput, GroupsLangUncheckedUpdateWithoutLanguagesInput>
  }

  export type GroupsLangUpdateManyWithWhereWithoutLanguagesInput = {
    where: GroupsLangScalarWhereInput
    data: XOR<GroupsLangUpdateManyMutationInput, GroupsLangUncheckedUpdateManyWithoutLanguagesInput>
  }

  export type LicensesLangUpsertWithWhereUniqueWithoutLanguagesInput = {
    where: LicensesLangWhereUniqueInput
    update: XOR<LicensesLangUpdateWithoutLanguagesInput, LicensesLangUncheckedUpdateWithoutLanguagesInput>
    create: XOR<LicensesLangCreateWithoutLanguagesInput, LicensesLangUncheckedCreateWithoutLanguagesInput>
  }

  export type LicensesLangUpdateWithWhereUniqueWithoutLanguagesInput = {
    where: LicensesLangWhereUniqueInput
    data: XOR<LicensesLangUpdateWithoutLanguagesInput, LicensesLangUncheckedUpdateWithoutLanguagesInput>
  }

  export type LicensesLangUpdateManyWithWhereWithoutLanguagesInput = {
    where: LicensesLangScalarWhereInput
    data: XOR<LicensesLangUpdateManyMutationInput, LicensesLangUncheckedUpdateManyWithoutLanguagesInput>
  }

  export type QuestionsLangUpsertWithWhereUniqueWithoutLanguagesInput = {
    where: QuestionsLangWhereUniqueInput
    update: XOR<QuestionsLangUpdateWithoutLanguagesInput, QuestionsLangUncheckedUpdateWithoutLanguagesInput>
    create: XOR<QuestionsLangCreateWithoutLanguagesInput, QuestionsLangUncheckedCreateWithoutLanguagesInput>
  }

  export type QuestionsLangUpdateWithWhereUniqueWithoutLanguagesInput = {
    where: QuestionsLangWhereUniqueInput
    data: XOR<QuestionsLangUpdateWithoutLanguagesInput, QuestionsLangUncheckedUpdateWithoutLanguagesInput>
  }

  export type QuestionsLangUpdateManyWithWhereWithoutLanguagesInput = {
    where: QuestionsLangScalarWhereInput
    data: XOR<QuestionsLangUpdateManyMutationInput, QuestionsLangUncheckedUpdateManyWithoutLanguagesInput>
  }

  export type QuizzesLangUpsertWithWhereUniqueWithoutLanguagesInput = {
    where: QuizzesLangWhereUniqueInput
    update: XOR<QuizzesLangUpdateWithoutLanguagesInput, QuizzesLangUncheckedUpdateWithoutLanguagesInput>
    create: XOR<QuizzesLangCreateWithoutLanguagesInput, QuizzesLangUncheckedCreateWithoutLanguagesInput>
  }

  export type QuizzesLangUpdateWithWhereUniqueWithoutLanguagesInput = {
    where: QuizzesLangWhereUniqueInput
    data: XOR<QuizzesLangUpdateWithoutLanguagesInput, QuizzesLangUncheckedUpdateWithoutLanguagesInput>
  }

  export type QuizzesLangUpdateManyWithWhereWithoutLanguagesInput = {
    where: QuizzesLangScalarWhereInput
    data: XOR<QuizzesLangUpdateManyMutationInput, QuizzesLangUncheckedUpdateManyWithoutLanguagesInput>
  }

  export type MediaCreateWithoutLicensesInput = {
    id?: bigint | number
    name: string
    extension: string
    url: string
    uploadedName: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Groups?: GroupsCreateNestedManyWithoutMediaInput
    RelationsChoices?: RelationsChoicesCreateNestedManyWithoutMediaInput
    RelationsQuestions?: RelationsQuestionsCreateNestedManyWithoutMediaInput
    Quizzes?: QuizzesCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutLicensesInput = {
    id?: bigint | number
    name: string
    extension: string
    url: string
    uploadedName: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Groups?: GroupsUncheckedCreateNestedManyWithoutMediaInput
    RelationsChoices?: RelationsChoicesUncheckedCreateNestedManyWithoutMediaInput
    RelationsQuestions?: RelationsQuestionsUncheckedCreateNestedManyWithoutMediaInput
    Quizzes?: QuizzesUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutLicensesInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutLicensesInput, MediaUncheckedCreateWithoutLicensesInput>
  }

  export type LicensesLangCreateWithoutLicensesInput = {
    id?: bigint | number
    name: string
    desc?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Languages: LanguagesCreateNestedOneWithoutLicensesLangInput
    Audio?: AudioCreateNestedOneWithoutLicensesLangInput
  }

  export type LicensesLangUncheckedCreateWithoutLicensesInput = {
    id?: bigint | number
    lang: bigint | number
    name: string
    desc?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type LicensesLangCreateOrConnectWithoutLicensesInput = {
    where: LicensesLangWhereUniqueInput
    create: XOR<LicensesLangCreateWithoutLicensesInput, LicensesLangUncheckedCreateWithoutLicensesInput>
  }

  export type LicensesLangCreateManyLicensesInputEnvelope = {
    data: LicensesLangCreateManyLicensesInput | LicensesLangCreateManyLicensesInput[]
    skipDuplicates?: boolean
  }

  export type RelationsCreateWithoutLicensesInput = {
    id?: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Groups: GroupsCreateNestedOneWithoutRelationsInput
    Quizzes: QuizzesCreateNestedOneWithoutRelationsInput
    RelationsChoices?: RelationsChoicesCreateNestedManyWithoutRelationsInput
    RelationsQuestions?: RelationsQuestionsCreateNestedManyWithoutRelationsInput
    UsersRelations?: UsersRelationsCreateNestedManyWithoutRelationsInput
  }

  export type RelationsUncheckedCreateWithoutLicensesInput = {
    id?: bigint | number
    gpId: bigint | number
    qzId: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    RelationsChoices?: RelationsChoicesUncheckedCreateNestedManyWithoutRelationsInput
    RelationsQuestions?: RelationsQuestionsUncheckedCreateNestedManyWithoutRelationsInput
    UsersRelations?: UsersRelationsUncheckedCreateNestedManyWithoutRelationsInput
  }

  export type RelationsCreateOrConnectWithoutLicensesInput = {
    where: RelationsWhereUniqueInput
    create: XOR<RelationsCreateWithoutLicensesInput, RelationsUncheckedCreateWithoutLicensesInput>
  }

  export type RelationsCreateManyLicensesInputEnvelope = {
    data: RelationsCreateManyLicensesInput | RelationsCreateManyLicensesInput[]
    skipDuplicates?: boolean
  }

  export type MediaUpsertWithoutLicensesInput = {
    update: XOR<MediaUpdateWithoutLicensesInput, MediaUncheckedUpdateWithoutLicensesInput>
    create: XOR<MediaCreateWithoutLicensesInput, MediaUncheckedCreateWithoutLicensesInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutLicensesInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutLicensesInput, MediaUncheckedUpdateWithoutLicensesInput>
  }

  export type MediaUpdateWithoutLicensesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedName?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Groups?: GroupsUpdateManyWithoutMediaNestedInput
    RelationsChoices?: RelationsChoicesUpdateManyWithoutMediaNestedInput
    RelationsQuestions?: RelationsQuestionsUpdateManyWithoutMediaNestedInput
    Quizzes?: QuizzesUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutLicensesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedName?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Groups?: GroupsUncheckedUpdateManyWithoutMediaNestedInput
    RelationsChoices?: RelationsChoicesUncheckedUpdateManyWithoutMediaNestedInput
    RelationsQuestions?: RelationsQuestionsUncheckedUpdateManyWithoutMediaNestedInput
    Quizzes?: QuizzesUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type LicensesLangUpsertWithWhereUniqueWithoutLicensesInput = {
    where: LicensesLangWhereUniqueInput
    update: XOR<LicensesLangUpdateWithoutLicensesInput, LicensesLangUncheckedUpdateWithoutLicensesInput>
    create: XOR<LicensesLangCreateWithoutLicensesInput, LicensesLangUncheckedCreateWithoutLicensesInput>
  }

  export type LicensesLangUpdateWithWhereUniqueWithoutLicensesInput = {
    where: LicensesLangWhereUniqueInput
    data: XOR<LicensesLangUpdateWithoutLicensesInput, LicensesLangUncheckedUpdateWithoutLicensesInput>
  }

  export type LicensesLangUpdateManyWithWhereWithoutLicensesInput = {
    where: LicensesLangScalarWhereInput
    data: XOR<LicensesLangUpdateManyMutationInput, LicensesLangUncheckedUpdateManyWithoutLicensesInput>
  }

  export type RelationsUpsertWithWhereUniqueWithoutLicensesInput = {
    where: RelationsWhereUniqueInput
    update: XOR<RelationsUpdateWithoutLicensesInput, RelationsUncheckedUpdateWithoutLicensesInput>
    create: XOR<RelationsCreateWithoutLicensesInput, RelationsUncheckedCreateWithoutLicensesInput>
  }

  export type RelationsUpdateWithWhereUniqueWithoutLicensesInput = {
    where: RelationsWhereUniqueInput
    data: XOR<RelationsUpdateWithoutLicensesInput, RelationsUncheckedUpdateWithoutLicensesInput>
  }

  export type RelationsUpdateManyWithWhereWithoutLicensesInput = {
    where: RelationsScalarWhereInput
    data: XOR<RelationsUpdateManyMutationInput, RelationsUncheckedUpdateManyWithoutLicensesInput>
  }

  export type LicensesCreateWithoutLicensesLangInput = {
    id?: bigint | number
    code: string
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Media?: MediaCreateNestedOneWithoutLicensesInput
    Relations?: RelationsCreateNestedManyWithoutLicensesInput
  }

  export type LicensesUncheckedCreateWithoutLicensesLangInput = {
    id?: bigint | number
    code: string
    media?: bigint | number | null
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Relations?: RelationsUncheckedCreateNestedManyWithoutLicensesInput
  }

  export type LicensesCreateOrConnectWithoutLicensesLangInput = {
    where: LicensesWhereUniqueInput
    create: XOR<LicensesCreateWithoutLicensesLangInput, LicensesUncheckedCreateWithoutLicensesLangInput>
  }

  export type LanguagesCreateWithoutLicensesLangInput = {
    id?: bigint | number
    name: string
    code: string
    voiceCode: string
    voiceType: string
    voiceName: string
    voiceGender: string
    voiceProfile: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    ChoicesLang?: ChoicesLangCreateNestedManyWithoutLanguagesInput
    GroupsLang?: GroupsLangCreateNestedManyWithoutLanguagesInput
    QuestionsLang?: QuestionsLangCreateNestedManyWithoutLanguagesInput
    QuizzesLang?: QuizzesLangCreateNestedManyWithoutLanguagesInput
  }

  export type LanguagesUncheckedCreateWithoutLicensesLangInput = {
    id?: bigint | number
    name: string
    code: string
    voiceCode: string
    voiceType: string
    voiceName: string
    voiceGender: string
    voiceProfile: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    ChoicesLang?: ChoicesLangUncheckedCreateNestedManyWithoutLanguagesInput
    GroupsLang?: GroupsLangUncheckedCreateNestedManyWithoutLanguagesInput
    QuestionsLang?: QuestionsLangUncheckedCreateNestedManyWithoutLanguagesInput
    QuizzesLang?: QuizzesLangUncheckedCreateNestedManyWithoutLanguagesInput
  }

  export type LanguagesCreateOrConnectWithoutLicensesLangInput = {
    where: LanguagesWhereUniqueInput
    create: XOR<LanguagesCreateWithoutLicensesLangInput, LanguagesUncheckedCreateWithoutLicensesLangInput>
  }

  export type AudioCreateWithoutLicensesLangInput = {
    id?: bigint | number
    name: string
    url: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    ChoicesLang?: ChoicesLangCreateNestedManyWithoutAudioInput
    GroupsLang?: GroupsLangCreateNestedManyWithoutAudioInput
    QuizzesLang?: QuizzesLangCreateNestedManyWithoutAudioInput
    QuestionsLang?: QuestionsLangCreateNestedManyWithoutAudioInput
  }

  export type AudioUncheckedCreateWithoutLicensesLangInput = {
    id?: bigint | number
    name: string
    url: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    ChoicesLang?: ChoicesLangUncheckedCreateNestedManyWithoutAudioInput
    GroupsLang?: GroupsLangUncheckedCreateNestedManyWithoutAudioInput
    QuizzesLang?: QuizzesLangUncheckedCreateNestedManyWithoutAudioInput
    QuestionsLang?: QuestionsLangUncheckedCreateNestedManyWithoutAudioInput
  }

  export type AudioCreateOrConnectWithoutLicensesLangInput = {
    where: AudioWhereUniqueInput
    create: XOR<AudioCreateWithoutLicensesLangInput, AudioUncheckedCreateWithoutLicensesLangInput>
  }

  export type LicensesUpsertWithoutLicensesLangInput = {
    update: XOR<LicensesUpdateWithoutLicensesLangInput, LicensesUncheckedUpdateWithoutLicensesLangInput>
    create: XOR<LicensesCreateWithoutLicensesLangInput, LicensesUncheckedCreateWithoutLicensesLangInput>
    where?: LicensesWhereInput
  }

  export type LicensesUpdateToOneWithWhereWithoutLicensesLangInput = {
    where?: LicensesWhereInput
    data: XOR<LicensesUpdateWithoutLicensesLangInput, LicensesUncheckedUpdateWithoutLicensesLangInput>
  }

  export type LicensesUpdateWithoutLicensesLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Media?: MediaUpdateOneWithoutLicensesNestedInput
    Relations?: RelationsUpdateManyWithoutLicensesNestedInput
  }

  export type LicensesUncheckedUpdateWithoutLicensesLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    media?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Relations?: RelationsUncheckedUpdateManyWithoutLicensesNestedInput
  }

  export type LanguagesUpsertWithoutLicensesLangInput = {
    update: XOR<LanguagesUpdateWithoutLicensesLangInput, LanguagesUncheckedUpdateWithoutLicensesLangInput>
    create: XOR<LanguagesCreateWithoutLicensesLangInput, LanguagesUncheckedCreateWithoutLicensesLangInput>
    where?: LanguagesWhereInput
  }

  export type LanguagesUpdateToOneWithWhereWithoutLicensesLangInput = {
    where?: LanguagesWhereInput
    data: XOR<LanguagesUpdateWithoutLicensesLangInput, LanguagesUncheckedUpdateWithoutLicensesLangInput>
  }

  export type LanguagesUpdateWithoutLicensesLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    voiceCode?: StringFieldUpdateOperationsInput | string
    voiceType?: StringFieldUpdateOperationsInput | string
    voiceName?: StringFieldUpdateOperationsInput | string
    voiceGender?: StringFieldUpdateOperationsInput | string
    voiceProfile?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ChoicesLang?: ChoicesLangUpdateManyWithoutLanguagesNestedInput
    GroupsLang?: GroupsLangUpdateManyWithoutLanguagesNestedInput
    QuestionsLang?: QuestionsLangUpdateManyWithoutLanguagesNestedInput
    QuizzesLang?: QuizzesLangUpdateManyWithoutLanguagesNestedInput
  }

  export type LanguagesUncheckedUpdateWithoutLicensesLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    voiceCode?: StringFieldUpdateOperationsInput | string
    voiceType?: StringFieldUpdateOperationsInput | string
    voiceName?: StringFieldUpdateOperationsInput | string
    voiceGender?: StringFieldUpdateOperationsInput | string
    voiceProfile?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ChoicesLang?: ChoicesLangUncheckedUpdateManyWithoutLanguagesNestedInput
    GroupsLang?: GroupsLangUncheckedUpdateManyWithoutLanguagesNestedInput
    QuestionsLang?: QuestionsLangUncheckedUpdateManyWithoutLanguagesNestedInput
    QuizzesLang?: QuizzesLangUncheckedUpdateManyWithoutLanguagesNestedInput
  }

  export type AudioUpsertWithoutLicensesLangInput = {
    update: XOR<AudioUpdateWithoutLicensesLangInput, AudioUncheckedUpdateWithoutLicensesLangInput>
    create: XOR<AudioCreateWithoutLicensesLangInput, AudioUncheckedCreateWithoutLicensesLangInput>
    where?: AudioWhereInput
  }

  export type AudioUpdateToOneWithWhereWithoutLicensesLangInput = {
    where?: AudioWhereInput
    data: XOR<AudioUpdateWithoutLicensesLangInput, AudioUncheckedUpdateWithoutLicensesLangInput>
  }

  export type AudioUpdateWithoutLicensesLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ChoicesLang?: ChoicesLangUpdateManyWithoutAudioNestedInput
    GroupsLang?: GroupsLangUpdateManyWithoutAudioNestedInput
    QuizzesLang?: QuizzesLangUpdateManyWithoutAudioNestedInput
    QuestionsLang?: QuestionsLangUpdateManyWithoutAudioNestedInput
  }

  export type AudioUncheckedUpdateWithoutLicensesLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ChoicesLang?: ChoicesLangUncheckedUpdateManyWithoutAudioNestedInput
    GroupsLang?: GroupsLangUncheckedUpdateManyWithoutAudioNestedInput
    QuizzesLang?: QuizzesLangUncheckedUpdateManyWithoutAudioNestedInput
    QuestionsLang?: QuestionsLangUncheckedUpdateManyWithoutAudioNestedInput
  }

  export type GroupsCreateWithoutMediaInput = {
    id?: bigint | number
    code: string
    level?: number
    randCount?: number
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    GroupsLang?: GroupsLangCreateNestedManyWithoutGroupsInput
    Relations?: RelationsCreateNestedManyWithoutGroupsInput
    UsersGroups?: UsersGroupsCreateNestedManyWithoutGroupsInput
  }

  export type GroupsUncheckedCreateWithoutMediaInput = {
    id?: bigint | number
    code: string
    level?: number
    randCount?: number
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    GroupsLang?: GroupsLangUncheckedCreateNestedManyWithoutGroupsInput
    Relations?: RelationsUncheckedCreateNestedManyWithoutGroupsInput
    UsersGroups?: UsersGroupsUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupsCreateOrConnectWithoutMediaInput = {
    where: GroupsWhereUniqueInput
    create: XOR<GroupsCreateWithoutMediaInput, GroupsUncheckedCreateWithoutMediaInput>
  }

  export type GroupsCreateManyMediaInputEnvelope = {
    data: GroupsCreateManyMediaInput | GroupsCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type LicensesCreateWithoutMediaInput = {
    id?: bigint | number
    code: string
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    LicensesLang?: LicensesLangCreateNestedManyWithoutLicensesInput
    Relations?: RelationsCreateNestedManyWithoutLicensesInput
  }

  export type LicensesUncheckedCreateWithoutMediaInput = {
    id?: bigint | number
    code: string
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    LicensesLang?: LicensesLangUncheckedCreateNestedManyWithoutLicensesInput
    Relations?: RelationsUncheckedCreateNestedManyWithoutLicensesInput
  }

  export type LicensesCreateOrConnectWithoutMediaInput = {
    where: LicensesWhereUniqueInput
    create: XOR<LicensesCreateWithoutMediaInput, LicensesUncheckedCreateWithoutMediaInput>
  }

  export type LicensesCreateManyMediaInputEnvelope = {
    data: LicensesCreateManyMediaInput | LicensesCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type RelationsChoicesCreateWithoutMediaInput = {
    id?: bigint | number
    correct?: boolean
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Choices: ChoicesCreateNestedOneWithoutRelationsChoicesInput
    RelationsQuestions: RelationsQuestionsCreateNestedOneWithoutRelationsChoicesInput
    Relations?: RelationsCreateNestedOneWithoutRelationsChoicesInput
    UsersRelationsDetails?: UsersRelationsDetailsCreateNestedManyWithoutRelationsChoicesInput
  }

  export type RelationsChoicesUncheckedCreateWithoutMediaInput = {
    id?: bigint | number
    rqId: bigint | number
    chId: bigint | number
    correct?: boolean
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    relationsId?: bigint | number | null
    UsersRelationsDetails?: UsersRelationsDetailsUncheckedCreateNestedManyWithoutRelationsChoicesInput
  }

  export type RelationsChoicesCreateOrConnectWithoutMediaInput = {
    where: RelationsChoicesWhereUniqueInput
    create: XOR<RelationsChoicesCreateWithoutMediaInput, RelationsChoicesUncheckedCreateWithoutMediaInput>
  }

  export type RelationsChoicesCreateManyMediaInputEnvelope = {
    data: RelationsChoicesCreateManyMediaInput | RelationsChoicesCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type RelationsQuestionsCreateWithoutMediaInput = {
    id?: bigint | number
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Questions: QuestionsCreateNestedOneWithoutRelationsQuestionsInput
    Relations: RelationsCreateNestedOneWithoutRelationsQuestionsInput
    RelationsChoices?: RelationsChoicesCreateNestedManyWithoutRelationsQuestionsInput
    UsersRelationsDetails?: UsersRelationsDetailsCreateNestedManyWithoutRelationsQuestionsInput
  }

  export type RelationsQuestionsUncheckedCreateWithoutMediaInput = {
    id?: bigint | number
    reId: bigint | number
    qsId: bigint | number
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    RelationsChoices?: RelationsChoicesUncheckedCreateNestedManyWithoutRelationsQuestionsInput
    UsersRelationsDetails?: UsersRelationsDetailsUncheckedCreateNestedManyWithoutRelationsQuestionsInput
  }

  export type RelationsQuestionsCreateOrConnectWithoutMediaInput = {
    where: RelationsQuestionsWhereUniqueInput
    create: XOR<RelationsQuestionsCreateWithoutMediaInput, RelationsQuestionsUncheckedCreateWithoutMediaInput>
  }

  export type RelationsQuestionsCreateManyMediaInputEnvelope = {
    data: RelationsQuestionsCreateManyMediaInput | RelationsQuestionsCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type QuizzesCreateWithoutMediaInput = {
    id?: bigint | number
    code: string
    duration?: number
    level?: number
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    QuizzesLang?: QuizzesLangCreateNestedManyWithoutQuizzesInput
    Relations?: RelationsCreateNestedManyWithoutQuizzesInput
  }

  export type QuizzesUncheckedCreateWithoutMediaInput = {
    id?: bigint | number
    code: string
    duration?: number
    level?: number
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    QuizzesLang?: QuizzesLangUncheckedCreateNestedManyWithoutQuizzesInput
    Relations?: RelationsUncheckedCreateNestedManyWithoutQuizzesInput
  }

  export type QuizzesCreateOrConnectWithoutMediaInput = {
    where: QuizzesWhereUniqueInput
    create: XOR<QuizzesCreateWithoutMediaInput, QuizzesUncheckedCreateWithoutMediaInput>
  }

  export type QuizzesCreateManyMediaInputEnvelope = {
    data: QuizzesCreateManyMediaInput | QuizzesCreateManyMediaInput[]
    skipDuplicates?: boolean
  }

  export type GroupsUpsertWithWhereUniqueWithoutMediaInput = {
    where: GroupsWhereUniqueInput
    update: XOR<GroupsUpdateWithoutMediaInput, GroupsUncheckedUpdateWithoutMediaInput>
    create: XOR<GroupsCreateWithoutMediaInput, GroupsUncheckedCreateWithoutMediaInput>
  }

  export type GroupsUpdateWithWhereUniqueWithoutMediaInput = {
    where: GroupsWhereUniqueInput
    data: XOR<GroupsUpdateWithoutMediaInput, GroupsUncheckedUpdateWithoutMediaInput>
  }

  export type GroupsUpdateManyWithWhereWithoutMediaInput = {
    where: GroupsScalarWhereInput
    data: XOR<GroupsUpdateManyMutationInput, GroupsUncheckedUpdateManyWithoutMediaInput>
  }

  export type GroupsScalarWhereInput = {
    AND?: GroupsScalarWhereInput | GroupsScalarWhereInput[]
    OR?: GroupsScalarWhereInput[]
    NOT?: GroupsScalarWhereInput | GroupsScalarWhereInput[]
    id?: BigIntFilter<"Groups"> | bigint | number
    code?: StringFilter<"Groups"> | string
    level?: IntFilter<"Groups"> | number
    media?: BigIntNullableFilter<"Groups"> | bigint | number | null
    randCount?: IntFilter<"Groups"> | number
    enabled?: BoolFilter<"Groups"> | boolean
    other?: StringNullableFilter<"Groups"> | string | null
    createdAt?: DateTimeNullableFilter<"Groups"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Groups"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Groups"> | Date | string | null
  }

  export type LicensesUpsertWithWhereUniqueWithoutMediaInput = {
    where: LicensesWhereUniqueInput
    update: XOR<LicensesUpdateWithoutMediaInput, LicensesUncheckedUpdateWithoutMediaInput>
    create: XOR<LicensesCreateWithoutMediaInput, LicensesUncheckedCreateWithoutMediaInput>
  }

  export type LicensesUpdateWithWhereUniqueWithoutMediaInput = {
    where: LicensesWhereUniqueInput
    data: XOR<LicensesUpdateWithoutMediaInput, LicensesUncheckedUpdateWithoutMediaInput>
  }

  export type LicensesUpdateManyWithWhereWithoutMediaInput = {
    where: LicensesScalarWhereInput
    data: XOR<LicensesUpdateManyMutationInput, LicensesUncheckedUpdateManyWithoutMediaInput>
  }

  export type LicensesScalarWhereInput = {
    AND?: LicensesScalarWhereInput | LicensesScalarWhereInput[]
    OR?: LicensesScalarWhereInput[]
    NOT?: LicensesScalarWhereInput | LicensesScalarWhereInput[]
    id?: BigIntFilter<"Licenses"> | bigint | number
    code?: StringFilter<"Licenses"> | string
    media?: BigIntNullableFilter<"Licenses"> | bigint | number | null
    enabled?: BoolFilter<"Licenses"> | boolean
    other?: StringNullableFilter<"Licenses"> | string | null
    createdAt?: DateTimeNullableFilter<"Licenses"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Licenses"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Licenses"> | Date | string | null
  }

  export type RelationsChoicesUpsertWithWhereUniqueWithoutMediaInput = {
    where: RelationsChoicesWhereUniqueInput
    update: XOR<RelationsChoicesUpdateWithoutMediaInput, RelationsChoicesUncheckedUpdateWithoutMediaInput>
    create: XOR<RelationsChoicesCreateWithoutMediaInput, RelationsChoicesUncheckedCreateWithoutMediaInput>
  }

  export type RelationsChoicesUpdateWithWhereUniqueWithoutMediaInput = {
    where: RelationsChoicesWhereUniqueInput
    data: XOR<RelationsChoicesUpdateWithoutMediaInput, RelationsChoicesUncheckedUpdateWithoutMediaInput>
  }

  export type RelationsChoicesUpdateManyWithWhereWithoutMediaInput = {
    where: RelationsChoicesScalarWhereInput
    data: XOR<RelationsChoicesUpdateManyMutationInput, RelationsChoicesUncheckedUpdateManyWithoutMediaInput>
  }

  export type RelationsQuestionsUpsertWithWhereUniqueWithoutMediaInput = {
    where: RelationsQuestionsWhereUniqueInput
    update: XOR<RelationsQuestionsUpdateWithoutMediaInput, RelationsQuestionsUncheckedUpdateWithoutMediaInput>
    create: XOR<RelationsQuestionsCreateWithoutMediaInput, RelationsQuestionsUncheckedCreateWithoutMediaInput>
  }

  export type RelationsQuestionsUpdateWithWhereUniqueWithoutMediaInput = {
    where: RelationsQuestionsWhereUniqueInput
    data: XOR<RelationsQuestionsUpdateWithoutMediaInput, RelationsQuestionsUncheckedUpdateWithoutMediaInput>
  }

  export type RelationsQuestionsUpdateManyWithWhereWithoutMediaInput = {
    where: RelationsQuestionsScalarWhereInput
    data: XOR<RelationsQuestionsUpdateManyMutationInput, RelationsQuestionsUncheckedUpdateManyWithoutMediaInput>
  }

  export type RelationsQuestionsScalarWhereInput = {
    AND?: RelationsQuestionsScalarWhereInput | RelationsQuestionsScalarWhereInput[]
    OR?: RelationsQuestionsScalarWhereInput[]
    NOT?: RelationsQuestionsScalarWhereInput | RelationsQuestionsScalarWhereInput[]
    id?: BigIntFilter<"RelationsQuestions"> | bigint | number
    reId?: BigIntFilter<"RelationsQuestions"> | bigint | number
    qsId?: BigIntFilter<"RelationsQuestions"> | bigint | number
    mdId?: BigIntNullableFilter<"RelationsQuestions"> | bigint | number | null
    ordering?: IntFilter<"RelationsQuestions"> | number
    createdAt?: DateTimeNullableFilter<"RelationsQuestions"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"RelationsQuestions"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"RelationsQuestions"> | Date | string | null
  }

  export type QuizzesUpsertWithWhereUniqueWithoutMediaInput = {
    where: QuizzesWhereUniqueInput
    update: XOR<QuizzesUpdateWithoutMediaInput, QuizzesUncheckedUpdateWithoutMediaInput>
    create: XOR<QuizzesCreateWithoutMediaInput, QuizzesUncheckedCreateWithoutMediaInput>
  }

  export type QuizzesUpdateWithWhereUniqueWithoutMediaInput = {
    where: QuizzesWhereUniqueInput
    data: XOR<QuizzesUpdateWithoutMediaInput, QuizzesUncheckedUpdateWithoutMediaInput>
  }

  export type QuizzesUpdateManyWithWhereWithoutMediaInput = {
    where: QuizzesScalarWhereInput
    data: XOR<QuizzesUpdateManyMutationInput, QuizzesUncheckedUpdateManyWithoutMediaInput>
  }

  export type QuizzesScalarWhereInput = {
    AND?: QuizzesScalarWhereInput | QuizzesScalarWhereInput[]
    OR?: QuizzesScalarWhereInput[]
    NOT?: QuizzesScalarWhereInput | QuizzesScalarWhereInput[]
    id?: BigIntFilter<"Quizzes"> | bigint | number
    code?: StringFilter<"Quizzes"> | string
    duration?: IntFilter<"Quizzes"> | number
    level?: IntFilter<"Quizzes"> | number
    media?: BigIntNullableFilter<"Quizzes"> | bigint | number | null
    enabled?: BoolFilter<"Quizzes"> | boolean
    other?: StringNullableFilter<"Quizzes"> | string | null
    createdAt?: DateTimeNullableFilter<"Quizzes"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Quizzes"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Quizzes"> | Date | string | null
  }

  export type QuestionsLangCreateWithoutQuestionsInput = {
    id?: bigint | number
    text: string
    hint?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Languages: LanguagesCreateNestedOneWithoutQuestionsLangInput
    Audio?: AudioCreateNestedOneWithoutQuestionsLangInput
  }

  export type QuestionsLangUncheckedCreateWithoutQuestionsInput = {
    id?: bigint | number
    lang: bigint | number
    text: string
    hint?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type QuestionsLangCreateOrConnectWithoutQuestionsInput = {
    where: QuestionsLangWhereUniqueInput
    create: XOR<QuestionsLangCreateWithoutQuestionsInput, QuestionsLangUncheckedCreateWithoutQuestionsInput>
  }

  export type QuestionsLangCreateManyQuestionsInputEnvelope = {
    data: QuestionsLangCreateManyQuestionsInput | QuestionsLangCreateManyQuestionsInput[]
    skipDuplicates?: boolean
  }

  export type RelationsQuestionsCreateWithoutQuestionsInput = {
    id?: bigint | number
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Media?: MediaCreateNestedOneWithoutRelationsQuestionsInput
    Relations: RelationsCreateNestedOneWithoutRelationsQuestionsInput
    RelationsChoices?: RelationsChoicesCreateNestedManyWithoutRelationsQuestionsInput
    UsersRelationsDetails?: UsersRelationsDetailsCreateNestedManyWithoutRelationsQuestionsInput
  }

  export type RelationsQuestionsUncheckedCreateWithoutQuestionsInput = {
    id?: bigint | number
    reId: bigint | number
    mdId?: bigint | number | null
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    RelationsChoices?: RelationsChoicesUncheckedCreateNestedManyWithoutRelationsQuestionsInput
    UsersRelationsDetails?: UsersRelationsDetailsUncheckedCreateNestedManyWithoutRelationsQuestionsInput
  }

  export type RelationsQuestionsCreateOrConnectWithoutQuestionsInput = {
    where: RelationsQuestionsWhereUniqueInput
    create: XOR<RelationsQuestionsCreateWithoutQuestionsInput, RelationsQuestionsUncheckedCreateWithoutQuestionsInput>
  }

  export type RelationsQuestionsCreateManyQuestionsInputEnvelope = {
    data: RelationsQuestionsCreateManyQuestionsInput | RelationsQuestionsCreateManyQuestionsInput[]
    skipDuplicates?: boolean
  }

  export type QuestionsLangUpsertWithWhereUniqueWithoutQuestionsInput = {
    where: QuestionsLangWhereUniqueInput
    update: XOR<QuestionsLangUpdateWithoutQuestionsInput, QuestionsLangUncheckedUpdateWithoutQuestionsInput>
    create: XOR<QuestionsLangCreateWithoutQuestionsInput, QuestionsLangUncheckedCreateWithoutQuestionsInput>
  }

  export type QuestionsLangUpdateWithWhereUniqueWithoutQuestionsInput = {
    where: QuestionsLangWhereUniqueInput
    data: XOR<QuestionsLangUpdateWithoutQuestionsInput, QuestionsLangUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuestionsLangUpdateManyWithWhereWithoutQuestionsInput = {
    where: QuestionsLangScalarWhereInput
    data: XOR<QuestionsLangUpdateManyMutationInput, QuestionsLangUncheckedUpdateManyWithoutQuestionsInput>
  }

  export type RelationsQuestionsUpsertWithWhereUniqueWithoutQuestionsInput = {
    where: RelationsQuestionsWhereUniqueInput
    update: XOR<RelationsQuestionsUpdateWithoutQuestionsInput, RelationsQuestionsUncheckedUpdateWithoutQuestionsInput>
    create: XOR<RelationsQuestionsCreateWithoutQuestionsInput, RelationsQuestionsUncheckedCreateWithoutQuestionsInput>
  }

  export type RelationsQuestionsUpdateWithWhereUniqueWithoutQuestionsInput = {
    where: RelationsQuestionsWhereUniqueInput
    data: XOR<RelationsQuestionsUpdateWithoutQuestionsInput, RelationsQuestionsUncheckedUpdateWithoutQuestionsInput>
  }

  export type RelationsQuestionsUpdateManyWithWhereWithoutQuestionsInput = {
    where: RelationsQuestionsScalarWhereInput
    data: XOR<RelationsQuestionsUpdateManyMutationInput, RelationsQuestionsUncheckedUpdateManyWithoutQuestionsInput>
  }

  export type QuestionsCreateWithoutQuestionsLangInput = {
    id?: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    RelationsQuestions?: RelationsQuestionsCreateNestedManyWithoutQuestionsInput
  }

  export type QuestionsUncheckedCreateWithoutQuestionsLangInput = {
    id?: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    RelationsQuestions?: RelationsQuestionsUncheckedCreateNestedManyWithoutQuestionsInput
  }

  export type QuestionsCreateOrConnectWithoutQuestionsLangInput = {
    where: QuestionsWhereUniqueInput
    create: XOR<QuestionsCreateWithoutQuestionsLangInput, QuestionsUncheckedCreateWithoutQuestionsLangInput>
  }

  export type LanguagesCreateWithoutQuestionsLangInput = {
    id?: bigint | number
    name: string
    code: string
    voiceCode: string
    voiceType: string
    voiceName: string
    voiceGender: string
    voiceProfile: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    ChoicesLang?: ChoicesLangCreateNestedManyWithoutLanguagesInput
    GroupsLang?: GroupsLangCreateNestedManyWithoutLanguagesInput
    LicensesLang?: LicensesLangCreateNestedManyWithoutLanguagesInput
    QuizzesLang?: QuizzesLangCreateNestedManyWithoutLanguagesInput
  }

  export type LanguagesUncheckedCreateWithoutQuestionsLangInput = {
    id?: bigint | number
    name: string
    code: string
    voiceCode: string
    voiceType: string
    voiceName: string
    voiceGender: string
    voiceProfile: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    ChoicesLang?: ChoicesLangUncheckedCreateNestedManyWithoutLanguagesInput
    GroupsLang?: GroupsLangUncheckedCreateNestedManyWithoutLanguagesInput
    LicensesLang?: LicensesLangUncheckedCreateNestedManyWithoutLanguagesInput
    QuizzesLang?: QuizzesLangUncheckedCreateNestedManyWithoutLanguagesInput
  }

  export type LanguagesCreateOrConnectWithoutQuestionsLangInput = {
    where: LanguagesWhereUniqueInput
    create: XOR<LanguagesCreateWithoutQuestionsLangInput, LanguagesUncheckedCreateWithoutQuestionsLangInput>
  }

  export type AudioCreateWithoutQuestionsLangInput = {
    id?: bigint | number
    name: string
    url: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    ChoicesLang?: ChoicesLangCreateNestedManyWithoutAudioInput
    GroupsLang?: GroupsLangCreateNestedManyWithoutAudioInput
    LicensesLang?: LicensesLangCreateNestedManyWithoutAudioInput
    QuizzesLang?: QuizzesLangCreateNestedManyWithoutAudioInput
  }

  export type AudioUncheckedCreateWithoutQuestionsLangInput = {
    id?: bigint | number
    name: string
    url: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    ChoicesLang?: ChoicesLangUncheckedCreateNestedManyWithoutAudioInput
    GroupsLang?: GroupsLangUncheckedCreateNestedManyWithoutAudioInput
    LicensesLang?: LicensesLangUncheckedCreateNestedManyWithoutAudioInput
    QuizzesLang?: QuizzesLangUncheckedCreateNestedManyWithoutAudioInput
  }

  export type AudioCreateOrConnectWithoutQuestionsLangInput = {
    where: AudioWhereUniqueInput
    create: XOR<AudioCreateWithoutQuestionsLangInput, AudioUncheckedCreateWithoutQuestionsLangInput>
  }

  export type QuestionsUpsertWithoutQuestionsLangInput = {
    update: XOR<QuestionsUpdateWithoutQuestionsLangInput, QuestionsUncheckedUpdateWithoutQuestionsLangInput>
    create: XOR<QuestionsCreateWithoutQuestionsLangInput, QuestionsUncheckedCreateWithoutQuestionsLangInput>
    where?: QuestionsWhereInput
  }

  export type QuestionsUpdateToOneWithWhereWithoutQuestionsLangInput = {
    where?: QuestionsWhereInput
    data: XOR<QuestionsUpdateWithoutQuestionsLangInput, QuestionsUncheckedUpdateWithoutQuestionsLangInput>
  }

  export type QuestionsUpdateWithoutQuestionsLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RelationsQuestions?: RelationsQuestionsUpdateManyWithoutQuestionsNestedInput
  }

  export type QuestionsUncheckedUpdateWithoutQuestionsLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RelationsQuestions?: RelationsQuestionsUncheckedUpdateManyWithoutQuestionsNestedInput
  }

  export type LanguagesUpsertWithoutQuestionsLangInput = {
    update: XOR<LanguagesUpdateWithoutQuestionsLangInput, LanguagesUncheckedUpdateWithoutQuestionsLangInput>
    create: XOR<LanguagesCreateWithoutQuestionsLangInput, LanguagesUncheckedCreateWithoutQuestionsLangInput>
    where?: LanguagesWhereInput
  }

  export type LanguagesUpdateToOneWithWhereWithoutQuestionsLangInput = {
    where?: LanguagesWhereInput
    data: XOR<LanguagesUpdateWithoutQuestionsLangInput, LanguagesUncheckedUpdateWithoutQuestionsLangInput>
  }

  export type LanguagesUpdateWithoutQuestionsLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    voiceCode?: StringFieldUpdateOperationsInput | string
    voiceType?: StringFieldUpdateOperationsInput | string
    voiceName?: StringFieldUpdateOperationsInput | string
    voiceGender?: StringFieldUpdateOperationsInput | string
    voiceProfile?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ChoicesLang?: ChoicesLangUpdateManyWithoutLanguagesNestedInput
    GroupsLang?: GroupsLangUpdateManyWithoutLanguagesNestedInput
    LicensesLang?: LicensesLangUpdateManyWithoutLanguagesNestedInput
    QuizzesLang?: QuizzesLangUpdateManyWithoutLanguagesNestedInput
  }

  export type LanguagesUncheckedUpdateWithoutQuestionsLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    voiceCode?: StringFieldUpdateOperationsInput | string
    voiceType?: StringFieldUpdateOperationsInput | string
    voiceName?: StringFieldUpdateOperationsInput | string
    voiceGender?: StringFieldUpdateOperationsInput | string
    voiceProfile?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ChoicesLang?: ChoicesLangUncheckedUpdateManyWithoutLanguagesNestedInput
    GroupsLang?: GroupsLangUncheckedUpdateManyWithoutLanguagesNestedInput
    LicensesLang?: LicensesLangUncheckedUpdateManyWithoutLanguagesNestedInput
    QuizzesLang?: QuizzesLangUncheckedUpdateManyWithoutLanguagesNestedInput
  }

  export type AudioUpsertWithoutQuestionsLangInput = {
    update: XOR<AudioUpdateWithoutQuestionsLangInput, AudioUncheckedUpdateWithoutQuestionsLangInput>
    create: XOR<AudioCreateWithoutQuestionsLangInput, AudioUncheckedCreateWithoutQuestionsLangInput>
    where?: AudioWhereInput
  }

  export type AudioUpdateToOneWithWhereWithoutQuestionsLangInput = {
    where?: AudioWhereInput
    data: XOR<AudioUpdateWithoutQuestionsLangInput, AudioUncheckedUpdateWithoutQuestionsLangInput>
  }

  export type AudioUpdateWithoutQuestionsLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ChoicesLang?: ChoicesLangUpdateManyWithoutAudioNestedInput
    GroupsLang?: GroupsLangUpdateManyWithoutAudioNestedInput
    LicensesLang?: LicensesLangUpdateManyWithoutAudioNestedInput
    QuizzesLang?: QuizzesLangUpdateManyWithoutAudioNestedInput
  }

  export type AudioUncheckedUpdateWithoutQuestionsLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ChoicesLang?: ChoicesLangUncheckedUpdateManyWithoutAudioNestedInput
    GroupsLang?: GroupsLangUncheckedUpdateManyWithoutAudioNestedInput
    LicensesLang?: LicensesLangUncheckedUpdateManyWithoutAudioNestedInput
    QuizzesLang?: QuizzesLangUncheckedUpdateManyWithoutAudioNestedInput
  }

  export type MediaCreateWithoutQuizzesInput = {
    id?: bigint | number
    name: string
    extension: string
    url: string
    uploadedName: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Groups?: GroupsCreateNestedManyWithoutMediaInput
    Licenses?: LicensesCreateNestedManyWithoutMediaInput
    RelationsChoices?: RelationsChoicesCreateNestedManyWithoutMediaInput
    RelationsQuestions?: RelationsQuestionsCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutQuizzesInput = {
    id?: bigint | number
    name: string
    extension: string
    url: string
    uploadedName: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Groups?: GroupsUncheckedCreateNestedManyWithoutMediaInput
    Licenses?: LicensesUncheckedCreateNestedManyWithoutMediaInput
    RelationsChoices?: RelationsChoicesUncheckedCreateNestedManyWithoutMediaInput
    RelationsQuestions?: RelationsQuestionsUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutQuizzesInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutQuizzesInput, MediaUncheckedCreateWithoutQuizzesInput>
  }

  export type QuizzesLangCreateWithoutQuizzesInput = {
    id?: bigint | number
    name: string
    desc?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Languages: LanguagesCreateNestedOneWithoutQuizzesLangInput
    Audio?: AudioCreateNestedOneWithoutQuizzesLangInput
  }

  export type QuizzesLangUncheckedCreateWithoutQuizzesInput = {
    id?: bigint | number
    lang: bigint | number
    name: string
    desc?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type QuizzesLangCreateOrConnectWithoutQuizzesInput = {
    where: QuizzesLangWhereUniqueInput
    create: XOR<QuizzesLangCreateWithoutQuizzesInput, QuizzesLangUncheckedCreateWithoutQuizzesInput>
  }

  export type QuizzesLangCreateManyQuizzesInputEnvelope = {
    data: QuizzesLangCreateManyQuizzesInput | QuizzesLangCreateManyQuizzesInput[]
    skipDuplicates?: boolean
  }

  export type RelationsCreateWithoutQuizzesInput = {
    id?: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Licenses: LicensesCreateNestedOneWithoutRelationsInput
    Groups: GroupsCreateNestedOneWithoutRelationsInput
    RelationsChoices?: RelationsChoicesCreateNestedManyWithoutRelationsInput
    RelationsQuestions?: RelationsQuestionsCreateNestedManyWithoutRelationsInput
    UsersRelations?: UsersRelationsCreateNestedManyWithoutRelationsInput
  }

  export type RelationsUncheckedCreateWithoutQuizzesInput = {
    id?: bigint | number
    liId: bigint | number
    gpId: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    RelationsChoices?: RelationsChoicesUncheckedCreateNestedManyWithoutRelationsInput
    RelationsQuestions?: RelationsQuestionsUncheckedCreateNestedManyWithoutRelationsInput
    UsersRelations?: UsersRelationsUncheckedCreateNestedManyWithoutRelationsInput
  }

  export type RelationsCreateOrConnectWithoutQuizzesInput = {
    where: RelationsWhereUniqueInput
    create: XOR<RelationsCreateWithoutQuizzesInput, RelationsUncheckedCreateWithoutQuizzesInput>
  }

  export type RelationsCreateManyQuizzesInputEnvelope = {
    data: RelationsCreateManyQuizzesInput | RelationsCreateManyQuizzesInput[]
    skipDuplicates?: boolean
  }

  export type MediaUpsertWithoutQuizzesInput = {
    update: XOR<MediaUpdateWithoutQuizzesInput, MediaUncheckedUpdateWithoutQuizzesInput>
    create: XOR<MediaCreateWithoutQuizzesInput, MediaUncheckedCreateWithoutQuizzesInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutQuizzesInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutQuizzesInput, MediaUncheckedUpdateWithoutQuizzesInput>
  }

  export type MediaUpdateWithoutQuizzesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedName?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Groups?: GroupsUpdateManyWithoutMediaNestedInput
    Licenses?: LicensesUpdateManyWithoutMediaNestedInput
    RelationsChoices?: RelationsChoicesUpdateManyWithoutMediaNestedInput
    RelationsQuestions?: RelationsQuestionsUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutQuizzesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedName?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Groups?: GroupsUncheckedUpdateManyWithoutMediaNestedInput
    Licenses?: LicensesUncheckedUpdateManyWithoutMediaNestedInput
    RelationsChoices?: RelationsChoicesUncheckedUpdateManyWithoutMediaNestedInput
    RelationsQuestions?: RelationsQuestionsUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type QuizzesLangUpsertWithWhereUniqueWithoutQuizzesInput = {
    where: QuizzesLangWhereUniqueInput
    update: XOR<QuizzesLangUpdateWithoutQuizzesInput, QuizzesLangUncheckedUpdateWithoutQuizzesInput>
    create: XOR<QuizzesLangCreateWithoutQuizzesInput, QuizzesLangUncheckedCreateWithoutQuizzesInput>
  }

  export type QuizzesLangUpdateWithWhereUniqueWithoutQuizzesInput = {
    where: QuizzesLangWhereUniqueInput
    data: XOR<QuizzesLangUpdateWithoutQuizzesInput, QuizzesLangUncheckedUpdateWithoutQuizzesInput>
  }

  export type QuizzesLangUpdateManyWithWhereWithoutQuizzesInput = {
    where: QuizzesLangScalarWhereInput
    data: XOR<QuizzesLangUpdateManyMutationInput, QuizzesLangUncheckedUpdateManyWithoutQuizzesInput>
  }

  export type RelationsUpsertWithWhereUniqueWithoutQuizzesInput = {
    where: RelationsWhereUniqueInput
    update: XOR<RelationsUpdateWithoutQuizzesInput, RelationsUncheckedUpdateWithoutQuizzesInput>
    create: XOR<RelationsCreateWithoutQuizzesInput, RelationsUncheckedCreateWithoutQuizzesInput>
  }

  export type RelationsUpdateWithWhereUniqueWithoutQuizzesInput = {
    where: RelationsWhereUniqueInput
    data: XOR<RelationsUpdateWithoutQuizzesInput, RelationsUncheckedUpdateWithoutQuizzesInput>
  }

  export type RelationsUpdateManyWithWhereWithoutQuizzesInput = {
    where: RelationsScalarWhereInput
    data: XOR<RelationsUpdateManyMutationInput, RelationsUncheckedUpdateManyWithoutQuizzesInput>
  }

  export type QuizzesCreateWithoutQuizzesLangInput = {
    id?: bigint | number
    code: string
    duration?: number
    level?: number
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Media?: MediaCreateNestedOneWithoutQuizzesInput
    Relations?: RelationsCreateNestedManyWithoutQuizzesInput
  }

  export type QuizzesUncheckedCreateWithoutQuizzesLangInput = {
    id?: bigint | number
    code: string
    duration?: number
    level?: number
    media?: bigint | number | null
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Relations?: RelationsUncheckedCreateNestedManyWithoutQuizzesInput
  }

  export type QuizzesCreateOrConnectWithoutQuizzesLangInput = {
    where: QuizzesWhereUniqueInput
    create: XOR<QuizzesCreateWithoutQuizzesLangInput, QuizzesUncheckedCreateWithoutQuizzesLangInput>
  }

  export type LanguagesCreateWithoutQuizzesLangInput = {
    id?: bigint | number
    name: string
    code: string
    voiceCode: string
    voiceType: string
    voiceName: string
    voiceGender: string
    voiceProfile: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    ChoicesLang?: ChoicesLangCreateNestedManyWithoutLanguagesInput
    GroupsLang?: GroupsLangCreateNestedManyWithoutLanguagesInput
    LicensesLang?: LicensesLangCreateNestedManyWithoutLanguagesInput
    QuestionsLang?: QuestionsLangCreateNestedManyWithoutLanguagesInput
  }

  export type LanguagesUncheckedCreateWithoutQuizzesLangInput = {
    id?: bigint | number
    name: string
    code: string
    voiceCode: string
    voiceType: string
    voiceName: string
    voiceGender: string
    voiceProfile: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    ChoicesLang?: ChoicesLangUncheckedCreateNestedManyWithoutLanguagesInput
    GroupsLang?: GroupsLangUncheckedCreateNestedManyWithoutLanguagesInput
    LicensesLang?: LicensesLangUncheckedCreateNestedManyWithoutLanguagesInput
    QuestionsLang?: QuestionsLangUncheckedCreateNestedManyWithoutLanguagesInput
  }

  export type LanguagesCreateOrConnectWithoutQuizzesLangInput = {
    where: LanguagesWhereUniqueInput
    create: XOR<LanguagesCreateWithoutQuizzesLangInput, LanguagesUncheckedCreateWithoutQuizzesLangInput>
  }

  export type AudioCreateWithoutQuizzesLangInput = {
    id?: bigint | number
    name: string
    url: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    ChoicesLang?: ChoicesLangCreateNestedManyWithoutAudioInput
    GroupsLang?: GroupsLangCreateNestedManyWithoutAudioInput
    LicensesLang?: LicensesLangCreateNestedManyWithoutAudioInput
    QuestionsLang?: QuestionsLangCreateNestedManyWithoutAudioInput
  }

  export type AudioUncheckedCreateWithoutQuizzesLangInput = {
    id?: bigint | number
    name: string
    url: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    ChoicesLang?: ChoicesLangUncheckedCreateNestedManyWithoutAudioInput
    GroupsLang?: GroupsLangUncheckedCreateNestedManyWithoutAudioInput
    LicensesLang?: LicensesLangUncheckedCreateNestedManyWithoutAudioInput
    QuestionsLang?: QuestionsLangUncheckedCreateNestedManyWithoutAudioInput
  }

  export type AudioCreateOrConnectWithoutQuizzesLangInput = {
    where: AudioWhereUniqueInput
    create: XOR<AudioCreateWithoutQuizzesLangInput, AudioUncheckedCreateWithoutQuizzesLangInput>
  }

  export type QuizzesUpsertWithoutQuizzesLangInput = {
    update: XOR<QuizzesUpdateWithoutQuizzesLangInput, QuizzesUncheckedUpdateWithoutQuizzesLangInput>
    create: XOR<QuizzesCreateWithoutQuizzesLangInput, QuizzesUncheckedCreateWithoutQuizzesLangInput>
    where?: QuizzesWhereInput
  }

  export type QuizzesUpdateToOneWithWhereWithoutQuizzesLangInput = {
    where?: QuizzesWhereInput
    data: XOR<QuizzesUpdateWithoutQuizzesLangInput, QuizzesUncheckedUpdateWithoutQuizzesLangInput>
  }

  export type QuizzesUpdateWithoutQuizzesLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Media?: MediaUpdateOneWithoutQuizzesNestedInput
    Relations?: RelationsUpdateManyWithoutQuizzesNestedInput
  }

  export type QuizzesUncheckedUpdateWithoutQuizzesLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    media?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Relations?: RelationsUncheckedUpdateManyWithoutQuizzesNestedInput
  }

  export type LanguagesUpsertWithoutQuizzesLangInput = {
    update: XOR<LanguagesUpdateWithoutQuizzesLangInput, LanguagesUncheckedUpdateWithoutQuizzesLangInput>
    create: XOR<LanguagesCreateWithoutQuizzesLangInput, LanguagesUncheckedCreateWithoutQuizzesLangInput>
    where?: LanguagesWhereInput
  }

  export type LanguagesUpdateToOneWithWhereWithoutQuizzesLangInput = {
    where?: LanguagesWhereInput
    data: XOR<LanguagesUpdateWithoutQuizzesLangInput, LanguagesUncheckedUpdateWithoutQuizzesLangInput>
  }

  export type LanguagesUpdateWithoutQuizzesLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    voiceCode?: StringFieldUpdateOperationsInput | string
    voiceType?: StringFieldUpdateOperationsInput | string
    voiceName?: StringFieldUpdateOperationsInput | string
    voiceGender?: StringFieldUpdateOperationsInput | string
    voiceProfile?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ChoicesLang?: ChoicesLangUpdateManyWithoutLanguagesNestedInput
    GroupsLang?: GroupsLangUpdateManyWithoutLanguagesNestedInput
    LicensesLang?: LicensesLangUpdateManyWithoutLanguagesNestedInput
    QuestionsLang?: QuestionsLangUpdateManyWithoutLanguagesNestedInput
  }

  export type LanguagesUncheckedUpdateWithoutQuizzesLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    voiceCode?: StringFieldUpdateOperationsInput | string
    voiceType?: StringFieldUpdateOperationsInput | string
    voiceName?: StringFieldUpdateOperationsInput | string
    voiceGender?: StringFieldUpdateOperationsInput | string
    voiceProfile?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ChoicesLang?: ChoicesLangUncheckedUpdateManyWithoutLanguagesNestedInput
    GroupsLang?: GroupsLangUncheckedUpdateManyWithoutLanguagesNestedInput
    LicensesLang?: LicensesLangUncheckedUpdateManyWithoutLanguagesNestedInput
    QuestionsLang?: QuestionsLangUncheckedUpdateManyWithoutLanguagesNestedInput
  }

  export type AudioUpsertWithoutQuizzesLangInput = {
    update: XOR<AudioUpdateWithoutQuizzesLangInput, AudioUncheckedUpdateWithoutQuizzesLangInput>
    create: XOR<AudioCreateWithoutQuizzesLangInput, AudioUncheckedCreateWithoutQuizzesLangInput>
    where?: AudioWhereInput
  }

  export type AudioUpdateToOneWithWhereWithoutQuizzesLangInput = {
    where?: AudioWhereInput
    data: XOR<AudioUpdateWithoutQuizzesLangInput, AudioUncheckedUpdateWithoutQuizzesLangInput>
  }

  export type AudioUpdateWithoutQuizzesLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ChoicesLang?: ChoicesLangUpdateManyWithoutAudioNestedInput
    GroupsLang?: GroupsLangUpdateManyWithoutAudioNestedInput
    LicensesLang?: LicensesLangUpdateManyWithoutAudioNestedInput
    QuestionsLang?: QuestionsLangUpdateManyWithoutAudioNestedInput
  }

  export type AudioUncheckedUpdateWithoutQuizzesLangInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ChoicesLang?: ChoicesLangUncheckedUpdateManyWithoutAudioNestedInput
    GroupsLang?: GroupsLangUncheckedUpdateManyWithoutAudioNestedInput
    LicensesLang?: LicensesLangUncheckedUpdateManyWithoutAudioNestedInput
    QuestionsLang?: QuestionsLangUncheckedUpdateManyWithoutAudioNestedInput
  }

  export type LicensesCreateWithoutRelationsInput = {
    id?: bigint | number
    code: string
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Media?: MediaCreateNestedOneWithoutLicensesInput
    LicensesLang?: LicensesLangCreateNestedManyWithoutLicensesInput
  }

  export type LicensesUncheckedCreateWithoutRelationsInput = {
    id?: bigint | number
    code: string
    media?: bigint | number | null
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    LicensesLang?: LicensesLangUncheckedCreateNestedManyWithoutLicensesInput
  }

  export type LicensesCreateOrConnectWithoutRelationsInput = {
    where: LicensesWhereUniqueInput
    create: XOR<LicensesCreateWithoutRelationsInput, LicensesUncheckedCreateWithoutRelationsInput>
  }

  export type GroupsCreateWithoutRelationsInput = {
    id?: bigint | number
    code: string
    level?: number
    randCount?: number
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Media?: MediaCreateNestedOneWithoutGroupsInput
    GroupsLang?: GroupsLangCreateNestedManyWithoutGroupsInput
    UsersGroups?: UsersGroupsCreateNestedManyWithoutGroupsInput
  }

  export type GroupsUncheckedCreateWithoutRelationsInput = {
    id?: bigint | number
    code: string
    level?: number
    media?: bigint | number | null
    randCount?: number
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    GroupsLang?: GroupsLangUncheckedCreateNestedManyWithoutGroupsInput
    UsersGroups?: UsersGroupsUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupsCreateOrConnectWithoutRelationsInput = {
    where: GroupsWhereUniqueInput
    create: XOR<GroupsCreateWithoutRelationsInput, GroupsUncheckedCreateWithoutRelationsInput>
  }

  export type QuizzesCreateWithoutRelationsInput = {
    id?: bigint | number
    code: string
    duration?: number
    level?: number
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Media?: MediaCreateNestedOneWithoutQuizzesInput
    QuizzesLang?: QuizzesLangCreateNestedManyWithoutQuizzesInput
  }

  export type QuizzesUncheckedCreateWithoutRelationsInput = {
    id?: bigint | number
    code: string
    duration?: number
    level?: number
    media?: bigint | number | null
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    QuizzesLang?: QuizzesLangUncheckedCreateNestedManyWithoutQuizzesInput
  }

  export type QuizzesCreateOrConnectWithoutRelationsInput = {
    where: QuizzesWhereUniqueInput
    create: XOR<QuizzesCreateWithoutRelationsInput, QuizzesUncheckedCreateWithoutRelationsInput>
  }

  export type RelationsChoicesCreateWithoutRelationsInput = {
    id?: bigint | number
    correct?: boolean
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Choices: ChoicesCreateNestedOneWithoutRelationsChoicesInput
    Media?: MediaCreateNestedOneWithoutRelationsChoicesInput
    RelationsQuestions: RelationsQuestionsCreateNestedOneWithoutRelationsChoicesInput
    UsersRelationsDetails?: UsersRelationsDetailsCreateNestedManyWithoutRelationsChoicesInput
  }

  export type RelationsChoicesUncheckedCreateWithoutRelationsInput = {
    id?: bigint | number
    rqId: bigint | number
    chId: bigint | number
    mdId?: bigint | number | null
    correct?: boolean
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    UsersRelationsDetails?: UsersRelationsDetailsUncheckedCreateNestedManyWithoutRelationsChoicesInput
  }

  export type RelationsChoicesCreateOrConnectWithoutRelationsInput = {
    where: RelationsChoicesWhereUniqueInput
    create: XOR<RelationsChoicesCreateWithoutRelationsInput, RelationsChoicesUncheckedCreateWithoutRelationsInput>
  }

  export type RelationsChoicesCreateManyRelationsInputEnvelope = {
    data: RelationsChoicesCreateManyRelationsInput | RelationsChoicesCreateManyRelationsInput[]
    skipDuplicates?: boolean
  }

  export type RelationsQuestionsCreateWithoutRelationsInput = {
    id?: bigint | number
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Questions: QuestionsCreateNestedOneWithoutRelationsQuestionsInput
    Media?: MediaCreateNestedOneWithoutRelationsQuestionsInput
    RelationsChoices?: RelationsChoicesCreateNestedManyWithoutRelationsQuestionsInput
    UsersRelationsDetails?: UsersRelationsDetailsCreateNestedManyWithoutRelationsQuestionsInput
  }

  export type RelationsQuestionsUncheckedCreateWithoutRelationsInput = {
    id?: bigint | number
    qsId: bigint | number
    mdId?: bigint | number | null
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    RelationsChoices?: RelationsChoicesUncheckedCreateNestedManyWithoutRelationsQuestionsInput
    UsersRelationsDetails?: UsersRelationsDetailsUncheckedCreateNestedManyWithoutRelationsQuestionsInput
  }

  export type RelationsQuestionsCreateOrConnectWithoutRelationsInput = {
    where: RelationsQuestionsWhereUniqueInput
    create: XOR<RelationsQuestionsCreateWithoutRelationsInput, RelationsQuestionsUncheckedCreateWithoutRelationsInput>
  }

  export type RelationsQuestionsCreateManyRelationsInputEnvelope = {
    data: RelationsQuestionsCreateManyRelationsInput | RelationsQuestionsCreateManyRelationsInput[]
    skipDuplicates?: boolean
  }

  export type UsersRelationsCreateWithoutRelationsInput = {
    id?: bigint | number
    correct: number
    wrong: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Users: UsersCreateNestedOneWithoutUsersRelationsInput
    UsersRelationsDetails?: UsersRelationsDetailsCreateNestedManyWithoutUsersRelationsInput
  }

  export type UsersRelationsUncheckedCreateWithoutRelationsInput = {
    id?: bigint | number
    usId: bigint | number
    correct: number
    wrong: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    UsersRelationsDetails?: UsersRelationsDetailsUncheckedCreateNestedManyWithoutUsersRelationsInput
  }

  export type UsersRelationsCreateOrConnectWithoutRelationsInput = {
    where: UsersRelationsWhereUniqueInput
    create: XOR<UsersRelationsCreateWithoutRelationsInput, UsersRelationsUncheckedCreateWithoutRelationsInput>
  }

  export type UsersRelationsCreateManyRelationsInputEnvelope = {
    data: UsersRelationsCreateManyRelationsInput | UsersRelationsCreateManyRelationsInput[]
    skipDuplicates?: boolean
  }

  export type LicensesUpsertWithoutRelationsInput = {
    update: XOR<LicensesUpdateWithoutRelationsInput, LicensesUncheckedUpdateWithoutRelationsInput>
    create: XOR<LicensesCreateWithoutRelationsInput, LicensesUncheckedCreateWithoutRelationsInput>
    where?: LicensesWhereInput
  }

  export type LicensesUpdateToOneWithWhereWithoutRelationsInput = {
    where?: LicensesWhereInput
    data: XOR<LicensesUpdateWithoutRelationsInput, LicensesUncheckedUpdateWithoutRelationsInput>
  }

  export type LicensesUpdateWithoutRelationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Media?: MediaUpdateOneWithoutLicensesNestedInput
    LicensesLang?: LicensesLangUpdateManyWithoutLicensesNestedInput
  }

  export type LicensesUncheckedUpdateWithoutRelationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    media?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LicensesLang?: LicensesLangUncheckedUpdateManyWithoutLicensesNestedInput
  }

  export type GroupsUpsertWithoutRelationsInput = {
    update: XOR<GroupsUpdateWithoutRelationsInput, GroupsUncheckedUpdateWithoutRelationsInput>
    create: XOR<GroupsCreateWithoutRelationsInput, GroupsUncheckedCreateWithoutRelationsInput>
    where?: GroupsWhereInput
  }

  export type GroupsUpdateToOneWithWhereWithoutRelationsInput = {
    where?: GroupsWhereInput
    data: XOR<GroupsUpdateWithoutRelationsInput, GroupsUncheckedUpdateWithoutRelationsInput>
  }

  export type GroupsUpdateWithoutRelationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    randCount?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Media?: MediaUpdateOneWithoutGroupsNestedInput
    GroupsLang?: GroupsLangUpdateManyWithoutGroupsNestedInput
    UsersGroups?: UsersGroupsUpdateManyWithoutGroupsNestedInput
  }

  export type GroupsUncheckedUpdateWithoutRelationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    media?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    randCount?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GroupsLang?: GroupsLangUncheckedUpdateManyWithoutGroupsNestedInput
    UsersGroups?: UsersGroupsUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type QuizzesUpsertWithoutRelationsInput = {
    update: XOR<QuizzesUpdateWithoutRelationsInput, QuizzesUncheckedUpdateWithoutRelationsInput>
    create: XOR<QuizzesCreateWithoutRelationsInput, QuizzesUncheckedCreateWithoutRelationsInput>
    where?: QuizzesWhereInput
  }

  export type QuizzesUpdateToOneWithWhereWithoutRelationsInput = {
    where?: QuizzesWhereInput
    data: XOR<QuizzesUpdateWithoutRelationsInput, QuizzesUncheckedUpdateWithoutRelationsInput>
  }

  export type QuizzesUpdateWithoutRelationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Media?: MediaUpdateOneWithoutQuizzesNestedInput
    QuizzesLang?: QuizzesLangUpdateManyWithoutQuizzesNestedInput
  }

  export type QuizzesUncheckedUpdateWithoutRelationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    media?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    QuizzesLang?: QuizzesLangUncheckedUpdateManyWithoutQuizzesNestedInput
  }

  export type RelationsChoicesUpsertWithWhereUniqueWithoutRelationsInput = {
    where: RelationsChoicesWhereUniqueInput
    update: XOR<RelationsChoicesUpdateWithoutRelationsInput, RelationsChoicesUncheckedUpdateWithoutRelationsInput>
    create: XOR<RelationsChoicesCreateWithoutRelationsInput, RelationsChoicesUncheckedCreateWithoutRelationsInput>
  }

  export type RelationsChoicesUpdateWithWhereUniqueWithoutRelationsInput = {
    where: RelationsChoicesWhereUniqueInput
    data: XOR<RelationsChoicesUpdateWithoutRelationsInput, RelationsChoicesUncheckedUpdateWithoutRelationsInput>
  }

  export type RelationsChoicesUpdateManyWithWhereWithoutRelationsInput = {
    where: RelationsChoicesScalarWhereInput
    data: XOR<RelationsChoicesUpdateManyMutationInput, RelationsChoicesUncheckedUpdateManyWithoutRelationsInput>
  }

  export type RelationsQuestionsUpsertWithWhereUniqueWithoutRelationsInput = {
    where: RelationsQuestionsWhereUniqueInput
    update: XOR<RelationsQuestionsUpdateWithoutRelationsInput, RelationsQuestionsUncheckedUpdateWithoutRelationsInput>
    create: XOR<RelationsQuestionsCreateWithoutRelationsInput, RelationsQuestionsUncheckedCreateWithoutRelationsInput>
  }

  export type RelationsQuestionsUpdateWithWhereUniqueWithoutRelationsInput = {
    where: RelationsQuestionsWhereUniqueInput
    data: XOR<RelationsQuestionsUpdateWithoutRelationsInput, RelationsQuestionsUncheckedUpdateWithoutRelationsInput>
  }

  export type RelationsQuestionsUpdateManyWithWhereWithoutRelationsInput = {
    where: RelationsQuestionsScalarWhereInput
    data: XOR<RelationsQuestionsUpdateManyMutationInput, RelationsQuestionsUncheckedUpdateManyWithoutRelationsInput>
  }

  export type UsersRelationsUpsertWithWhereUniqueWithoutRelationsInput = {
    where: UsersRelationsWhereUniqueInput
    update: XOR<UsersRelationsUpdateWithoutRelationsInput, UsersRelationsUncheckedUpdateWithoutRelationsInput>
    create: XOR<UsersRelationsCreateWithoutRelationsInput, UsersRelationsUncheckedCreateWithoutRelationsInput>
  }

  export type UsersRelationsUpdateWithWhereUniqueWithoutRelationsInput = {
    where: UsersRelationsWhereUniqueInput
    data: XOR<UsersRelationsUpdateWithoutRelationsInput, UsersRelationsUncheckedUpdateWithoutRelationsInput>
  }

  export type UsersRelationsUpdateManyWithWhereWithoutRelationsInput = {
    where: UsersRelationsScalarWhereInput
    data: XOR<UsersRelationsUpdateManyMutationInput, UsersRelationsUncheckedUpdateManyWithoutRelationsInput>
  }

  export type UsersRelationsScalarWhereInput = {
    AND?: UsersRelationsScalarWhereInput | UsersRelationsScalarWhereInput[]
    OR?: UsersRelationsScalarWhereInput[]
    NOT?: UsersRelationsScalarWhereInput | UsersRelationsScalarWhereInput[]
    id?: BigIntFilter<"UsersRelations"> | bigint | number
    usId?: BigIntFilter<"UsersRelations"> | bigint | number
    reId?: BigIntFilter<"UsersRelations"> | bigint | number
    correct?: IntFilter<"UsersRelations"> | number
    wrong?: IntFilter<"UsersRelations"> | number
    createdAt?: DateTimeNullableFilter<"UsersRelations"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"UsersRelations"> | Date | string | null
  }

  export type ChoicesCreateWithoutRelationsChoicesInput = {
    id?: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    ChoicesLang?: ChoicesLangCreateNestedManyWithoutChoicesInput
  }

  export type ChoicesUncheckedCreateWithoutRelationsChoicesInput = {
    id?: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    ChoicesLang?: ChoicesLangUncheckedCreateNestedManyWithoutChoicesInput
  }

  export type ChoicesCreateOrConnectWithoutRelationsChoicesInput = {
    where: ChoicesWhereUniqueInput
    create: XOR<ChoicesCreateWithoutRelationsChoicesInput, ChoicesUncheckedCreateWithoutRelationsChoicesInput>
  }

  export type MediaCreateWithoutRelationsChoicesInput = {
    id?: bigint | number
    name: string
    extension: string
    url: string
    uploadedName: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Groups?: GroupsCreateNestedManyWithoutMediaInput
    Licenses?: LicensesCreateNestedManyWithoutMediaInput
    RelationsQuestions?: RelationsQuestionsCreateNestedManyWithoutMediaInput
    Quizzes?: QuizzesCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutRelationsChoicesInput = {
    id?: bigint | number
    name: string
    extension: string
    url: string
    uploadedName: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Groups?: GroupsUncheckedCreateNestedManyWithoutMediaInput
    Licenses?: LicensesUncheckedCreateNestedManyWithoutMediaInput
    RelationsQuestions?: RelationsQuestionsUncheckedCreateNestedManyWithoutMediaInput
    Quizzes?: QuizzesUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutRelationsChoicesInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutRelationsChoicesInput, MediaUncheckedCreateWithoutRelationsChoicesInput>
  }

  export type RelationsQuestionsCreateWithoutRelationsChoicesInput = {
    id?: bigint | number
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Questions: QuestionsCreateNestedOneWithoutRelationsQuestionsInput
    Media?: MediaCreateNestedOneWithoutRelationsQuestionsInput
    Relations: RelationsCreateNestedOneWithoutRelationsQuestionsInput
    UsersRelationsDetails?: UsersRelationsDetailsCreateNestedManyWithoutRelationsQuestionsInput
  }

  export type RelationsQuestionsUncheckedCreateWithoutRelationsChoicesInput = {
    id?: bigint | number
    reId: bigint | number
    qsId: bigint | number
    mdId?: bigint | number | null
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    UsersRelationsDetails?: UsersRelationsDetailsUncheckedCreateNestedManyWithoutRelationsQuestionsInput
  }

  export type RelationsQuestionsCreateOrConnectWithoutRelationsChoicesInput = {
    where: RelationsQuestionsWhereUniqueInput
    create: XOR<RelationsQuestionsCreateWithoutRelationsChoicesInput, RelationsQuestionsUncheckedCreateWithoutRelationsChoicesInput>
  }

  export type RelationsCreateWithoutRelationsChoicesInput = {
    id?: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Licenses: LicensesCreateNestedOneWithoutRelationsInput
    Groups: GroupsCreateNestedOneWithoutRelationsInput
    Quizzes: QuizzesCreateNestedOneWithoutRelationsInput
    RelationsQuestions?: RelationsQuestionsCreateNestedManyWithoutRelationsInput
    UsersRelations?: UsersRelationsCreateNestedManyWithoutRelationsInput
  }

  export type RelationsUncheckedCreateWithoutRelationsChoicesInput = {
    id?: bigint | number
    liId: bigint | number
    gpId: bigint | number
    qzId: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    RelationsQuestions?: RelationsQuestionsUncheckedCreateNestedManyWithoutRelationsInput
    UsersRelations?: UsersRelationsUncheckedCreateNestedManyWithoutRelationsInput
  }

  export type RelationsCreateOrConnectWithoutRelationsChoicesInput = {
    where: RelationsWhereUniqueInput
    create: XOR<RelationsCreateWithoutRelationsChoicesInput, RelationsUncheckedCreateWithoutRelationsChoicesInput>
  }

  export type UsersRelationsDetailsCreateWithoutRelationsChoicesInput = {
    id?: bigint | number
    observed?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    UsersRelations: UsersRelationsCreateNestedOneWithoutUsersRelationsDetailsInput
    RelationsQuestions: RelationsQuestionsCreateNestedOneWithoutUsersRelationsDetailsInput
  }

  export type UsersRelationsDetailsUncheckedCreateWithoutRelationsChoicesInput = {
    id?: bigint | number
    urId: bigint | number
    rqId: bigint | number
    observed?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UsersRelationsDetailsCreateOrConnectWithoutRelationsChoicesInput = {
    where: UsersRelationsDetailsWhereUniqueInput
    create: XOR<UsersRelationsDetailsCreateWithoutRelationsChoicesInput, UsersRelationsDetailsUncheckedCreateWithoutRelationsChoicesInput>
  }

  export type UsersRelationsDetailsCreateManyRelationsChoicesInputEnvelope = {
    data: UsersRelationsDetailsCreateManyRelationsChoicesInput | UsersRelationsDetailsCreateManyRelationsChoicesInput[]
    skipDuplicates?: boolean
  }

  export type ChoicesUpsertWithoutRelationsChoicesInput = {
    update: XOR<ChoicesUpdateWithoutRelationsChoicesInput, ChoicesUncheckedUpdateWithoutRelationsChoicesInput>
    create: XOR<ChoicesCreateWithoutRelationsChoicesInput, ChoicesUncheckedCreateWithoutRelationsChoicesInput>
    where?: ChoicesWhereInput
  }

  export type ChoicesUpdateToOneWithWhereWithoutRelationsChoicesInput = {
    where?: ChoicesWhereInput
    data: XOR<ChoicesUpdateWithoutRelationsChoicesInput, ChoicesUncheckedUpdateWithoutRelationsChoicesInput>
  }

  export type ChoicesUpdateWithoutRelationsChoicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ChoicesLang?: ChoicesLangUpdateManyWithoutChoicesNestedInput
  }

  export type ChoicesUncheckedUpdateWithoutRelationsChoicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ChoicesLang?: ChoicesLangUncheckedUpdateManyWithoutChoicesNestedInput
  }

  export type MediaUpsertWithoutRelationsChoicesInput = {
    update: XOR<MediaUpdateWithoutRelationsChoicesInput, MediaUncheckedUpdateWithoutRelationsChoicesInput>
    create: XOR<MediaCreateWithoutRelationsChoicesInput, MediaUncheckedCreateWithoutRelationsChoicesInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutRelationsChoicesInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutRelationsChoicesInput, MediaUncheckedUpdateWithoutRelationsChoicesInput>
  }

  export type MediaUpdateWithoutRelationsChoicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedName?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Groups?: GroupsUpdateManyWithoutMediaNestedInput
    Licenses?: LicensesUpdateManyWithoutMediaNestedInput
    RelationsQuestions?: RelationsQuestionsUpdateManyWithoutMediaNestedInput
    Quizzes?: QuizzesUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutRelationsChoicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedName?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Groups?: GroupsUncheckedUpdateManyWithoutMediaNestedInput
    Licenses?: LicensesUncheckedUpdateManyWithoutMediaNestedInput
    RelationsQuestions?: RelationsQuestionsUncheckedUpdateManyWithoutMediaNestedInput
    Quizzes?: QuizzesUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type RelationsQuestionsUpsertWithoutRelationsChoicesInput = {
    update: XOR<RelationsQuestionsUpdateWithoutRelationsChoicesInput, RelationsQuestionsUncheckedUpdateWithoutRelationsChoicesInput>
    create: XOR<RelationsQuestionsCreateWithoutRelationsChoicesInput, RelationsQuestionsUncheckedCreateWithoutRelationsChoicesInput>
    where?: RelationsQuestionsWhereInput
  }

  export type RelationsQuestionsUpdateToOneWithWhereWithoutRelationsChoicesInput = {
    where?: RelationsQuestionsWhereInput
    data: XOR<RelationsQuestionsUpdateWithoutRelationsChoicesInput, RelationsQuestionsUncheckedUpdateWithoutRelationsChoicesInput>
  }

  export type RelationsQuestionsUpdateWithoutRelationsChoicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Questions?: QuestionsUpdateOneRequiredWithoutRelationsQuestionsNestedInput
    Media?: MediaUpdateOneWithoutRelationsQuestionsNestedInput
    Relations?: RelationsUpdateOneRequiredWithoutRelationsQuestionsNestedInput
    UsersRelationsDetails?: UsersRelationsDetailsUpdateManyWithoutRelationsQuestionsNestedInput
  }

  export type RelationsQuestionsUncheckedUpdateWithoutRelationsChoicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    reId?: BigIntFieldUpdateOperationsInput | bigint | number
    qsId?: BigIntFieldUpdateOperationsInput | bigint | number
    mdId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UsersRelationsDetails?: UsersRelationsDetailsUncheckedUpdateManyWithoutRelationsQuestionsNestedInput
  }

  export type RelationsUpsertWithoutRelationsChoicesInput = {
    update: XOR<RelationsUpdateWithoutRelationsChoicesInput, RelationsUncheckedUpdateWithoutRelationsChoicesInput>
    create: XOR<RelationsCreateWithoutRelationsChoicesInput, RelationsUncheckedCreateWithoutRelationsChoicesInput>
    where?: RelationsWhereInput
  }

  export type RelationsUpdateToOneWithWhereWithoutRelationsChoicesInput = {
    where?: RelationsWhereInput
    data: XOR<RelationsUpdateWithoutRelationsChoicesInput, RelationsUncheckedUpdateWithoutRelationsChoicesInput>
  }

  export type RelationsUpdateWithoutRelationsChoicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Licenses?: LicensesUpdateOneRequiredWithoutRelationsNestedInput
    Groups?: GroupsUpdateOneRequiredWithoutRelationsNestedInput
    Quizzes?: QuizzesUpdateOneRequiredWithoutRelationsNestedInput
    RelationsQuestions?: RelationsQuestionsUpdateManyWithoutRelationsNestedInput
    UsersRelations?: UsersRelationsUpdateManyWithoutRelationsNestedInput
  }

  export type RelationsUncheckedUpdateWithoutRelationsChoicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    liId?: BigIntFieldUpdateOperationsInput | bigint | number
    gpId?: BigIntFieldUpdateOperationsInput | bigint | number
    qzId?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RelationsQuestions?: RelationsQuestionsUncheckedUpdateManyWithoutRelationsNestedInput
    UsersRelations?: UsersRelationsUncheckedUpdateManyWithoutRelationsNestedInput
  }

  export type UsersRelationsDetailsUpsertWithWhereUniqueWithoutRelationsChoicesInput = {
    where: UsersRelationsDetailsWhereUniqueInput
    update: XOR<UsersRelationsDetailsUpdateWithoutRelationsChoicesInput, UsersRelationsDetailsUncheckedUpdateWithoutRelationsChoicesInput>
    create: XOR<UsersRelationsDetailsCreateWithoutRelationsChoicesInput, UsersRelationsDetailsUncheckedCreateWithoutRelationsChoicesInput>
  }

  export type UsersRelationsDetailsUpdateWithWhereUniqueWithoutRelationsChoicesInput = {
    where: UsersRelationsDetailsWhereUniqueInput
    data: XOR<UsersRelationsDetailsUpdateWithoutRelationsChoicesInput, UsersRelationsDetailsUncheckedUpdateWithoutRelationsChoicesInput>
  }

  export type UsersRelationsDetailsUpdateManyWithWhereWithoutRelationsChoicesInput = {
    where: UsersRelationsDetailsScalarWhereInput
    data: XOR<UsersRelationsDetailsUpdateManyMutationInput, UsersRelationsDetailsUncheckedUpdateManyWithoutRelationsChoicesInput>
  }

  export type UsersRelationsDetailsScalarWhereInput = {
    AND?: UsersRelationsDetailsScalarWhereInput | UsersRelationsDetailsScalarWhereInput[]
    OR?: UsersRelationsDetailsScalarWhereInput[]
    NOT?: UsersRelationsDetailsScalarWhereInput | UsersRelationsDetailsScalarWhereInput[]
    id?: BigIntFilter<"UsersRelationsDetails"> | bigint | number
    urId?: BigIntFilter<"UsersRelationsDetails"> | bigint | number
    rqId?: BigIntFilter<"UsersRelationsDetails"> | bigint | number
    rcId?: BigIntFilter<"UsersRelationsDetails"> | bigint | number
    observed?: BoolFilter<"UsersRelationsDetails"> | boolean
    createdAt?: DateTimeNullableFilter<"UsersRelationsDetails"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"UsersRelationsDetails"> | Date | string | null
  }

  export type QuestionsCreateWithoutRelationsQuestionsInput = {
    id?: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    QuestionsLang?: QuestionsLangCreateNestedManyWithoutQuestionsInput
  }

  export type QuestionsUncheckedCreateWithoutRelationsQuestionsInput = {
    id?: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    QuestionsLang?: QuestionsLangUncheckedCreateNestedManyWithoutQuestionsInput
  }

  export type QuestionsCreateOrConnectWithoutRelationsQuestionsInput = {
    where: QuestionsWhereUniqueInput
    create: XOR<QuestionsCreateWithoutRelationsQuestionsInput, QuestionsUncheckedCreateWithoutRelationsQuestionsInput>
  }

  export type MediaCreateWithoutRelationsQuestionsInput = {
    id?: bigint | number
    name: string
    extension: string
    url: string
    uploadedName: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Groups?: GroupsCreateNestedManyWithoutMediaInput
    Licenses?: LicensesCreateNestedManyWithoutMediaInput
    RelationsChoices?: RelationsChoicesCreateNestedManyWithoutMediaInput
    Quizzes?: QuizzesCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateWithoutRelationsQuestionsInput = {
    id?: bigint | number
    name: string
    extension: string
    url: string
    uploadedName: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Groups?: GroupsUncheckedCreateNestedManyWithoutMediaInput
    Licenses?: LicensesUncheckedCreateNestedManyWithoutMediaInput
    RelationsChoices?: RelationsChoicesUncheckedCreateNestedManyWithoutMediaInput
    Quizzes?: QuizzesUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaCreateOrConnectWithoutRelationsQuestionsInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutRelationsQuestionsInput, MediaUncheckedCreateWithoutRelationsQuestionsInput>
  }

  export type RelationsCreateWithoutRelationsQuestionsInput = {
    id?: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Licenses: LicensesCreateNestedOneWithoutRelationsInput
    Groups: GroupsCreateNestedOneWithoutRelationsInput
    Quizzes: QuizzesCreateNestedOneWithoutRelationsInput
    RelationsChoices?: RelationsChoicesCreateNestedManyWithoutRelationsInput
    UsersRelations?: UsersRelationsCreateNestedManyWithoutRelationsInput
  }

  export type RelationsUncheckedCreateWithoutRelationsQuestionsInput = {
    id?: bigint | number
    liId: bigint | number
    gpId: bigint | number
    qzId: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    RelationsChoices?: RelationsChoicesUncheckedCreateNestedManyWithoutRelationsInput
    UsersRelations?: UsersRelationsUncheckedCreateNestedManyWithoutRelationsInput
  }

  export type RelationsCreateOrConnectWithoutRelationsQuestionsInput = {
    where: RelationsWhereUniqueInput
    create: XOR<RelationsCreateWithoutRelationsQuestionsInput, RelationsUncheckedCreateWithoutRelationsQuestionsInput>
  }

  export type RelationsChoicesCreateWithoutRelationsQuestionsInput = {
    id?: bigint | number
    correct?: boolean
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Choices: ChoicesCreateNestedOneWithoutRelationsChoicesInput
    Media?: MediaCreateNestedOneWithoutRelationsChoicesInput
    Relations?: RelationsCreateNestedOneWithoutRelationsChoicesInput
    UsersRelationsDetails?: UsersRelationsDetailsCreateNestedManyWithoutRelationsChoicesInput
  }

  export type RelationsChoicesUncheckedCreateWithoutRelationsQuestionsInput = {
    id?: bigint | number
    chId: bigint | number
    mdId?: bigint | number | null
    correct?: boolean
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    relationsId?: bigint | number | null
    UsersRelationsDetails?: UsersRelationsDetailsUncheckedCreateNestedManyWithoutRelationsChoicesInput
  }

  export type RelationsChoicesCreateOrConnectWithoutRelationsQuestionsInput = {
    where: RelationsChoicesWhereUniqueInput
    create: XOR<RelationsChoicesCreateWithoutRelationsQuestionsInput, RelationsChoicesUncheckedCreateWithoutRelationsQuestionsInput>
  }

  export type RelationsChoicesCreateManyRelationsQuestionsInputEnvelope = {
    data: RelationsChoicesCreateManyRelationsQuestionsInput | RelationsChoicesCreateManyRelationsQuestionsInput[]
    skipDuplicates?: boolean
  }

  export type UsersRelationsDetailsCreateWithoutRelationsQuestionsInput = {
    id?: bigint | number
    observed?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    UsersRelations: UsersRelationsCreateNestedOneWithoutUsersRelationsDetailsInput
    RelationsChoices: RelationsChoicesCreateNestedOneWithoutUsersRelationsDetailsInput
  }

  export type UsersRelationsDetailsUncheckedCreateWithoutRelationsQuestionsInput = {
    id?: bigint | number
    urId: bigint | number
    rcId: bigint | number
    observed?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UsersRelationsDetailsCreateOrConnectWithoutRelationsQuestionsInput = {
    where: UsersRelationsDetailsWhereUniqueInput
    create: XOR<UsersRelationsDetailsCreateWithoutRelationsQuestionsInput, UsersRelationsDetailsUncheckedCreateWithoutRelationsQuestionsInput>
  }

  export type UsersRelationsDetailsCreateManyRelationsQuestionsInputEnvelope = {
    data: UsersRelationsDetailsCreateManyRelationsQuestionsInput | UsersRelationsDetailsCreateManyRelationsQuestionsInput[]
    skipDuplicates?: boolean
  }

  export type QuestionsUpsertWithoutRelationsQuestionsInput = {
    update: XOR<QuestionsUpdateWithoutRelationsQuestionsInput, QuestionsUncheckedUpdateWithoutRelationsQuestionsInput>
    create: XOR<QuestionsCreateWithoutRelationsQuestionsInput, QuestionsUncheckedCreateWithoutRelationsQuestionsInput>
    where?: QuestionsWhereInput
  }

  export type QuestionsUpdateToOneWithWhereWithoutRelationsQuestionsInput = {
    where?: QuestionsWhereInput
    data: XOR<QuestionsUpdateWithoutRelationsQuestionsInput, QuestionsUncheckedUpdateWithoutRelationsQuestionsInput>
  }

  export type QuestionsUpdateWithoutRelationsQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    QuestionsLang?: QuestionsLangUpdateManyWithoutQuestionsNestedInput
  }

  export type QuestionsUncheckedUpdateWithoutRelationsQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    QuestionsLang?: QuestionsLangUncheckedUpdateManyWithoutQuestionsNestedInput
  }

  export type MediaUpsertWithoutRelationsQuestionsInput = {
    update: XOR<MediaUpdateWithoutRelationsQuestionsInput, MediaUncheckedUpdateWithoutRelationsQuestionsInput>
    create: XOR<MediaCreateWithoutRelationsQuestionsInput, MediaUncheckedCreateWithoutRelationsQuestionsInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutRelationsQuestionsInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutRelationsQuestionsInput, MediaUncheckedUpdateWithoutRelationsQuestionsInput>
  }

  export type MediaUpdateWithoutRelationsQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedName?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Groups?: GroupsUpdateManyWithoutMediaNestedInput
    Licenses?: LicensesUpdateManyWithoutMediaNestedInput
    RelationsChoices?: RelationsChoicesUpdateManyWithoutMediaNestedInput
    Quizzes?: QuizzesUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateWithoutRelationsQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    extension?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedName?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Groups?: GroupsUncheckedUpdateManyWithoutMediaNestedInput
    Licenses?: LicensesUncheckedUpdateManyWithoutMediaNestedInput
    RelationsChoices?: RelationsChoicesUncheckedUpdateManyWithoutMediaNestedInput
    Quizzes?: QuizzesUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type RelationsUpsertWithoutRelationsQuestionsInput = {
    update: XOR<RelationsUpdateWithoutRelationsQuestionsInput, RelationsUncheckedUpdateWithoutRelationsQuestionsInput>
    create: XOR<RelationsCreateWithoutRelationsQuestionsInput, RelationsUncheckedCreateWithoutRelationsQuestionsInput>
    where?: RelationsWhereInput
  }

  export type RelationsUpdateToOneWithWhereWithoutRelationsQuestionsInput = {
    where?: RelationsWhereInput
    data: XOR<RelationsUpdateWithoutRelationsQuestionsInput, RelationsUncheckedUpdateWithoutRelationsQuestionsInput>
  }

  export type RelationsUpdateWithoutRelationsQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Licenses?: LicensesUpdateOneRequiredWithoutRelationsNestedInput
    Groups?: GroupsUpdateOneRequiredWithoutRelationsNestedInput
    Quizzes?: QuizzesUpdateOneRequiredWithoutRelationsNestedInput
    RelationsChoices?: RelationsChoicesUpdateManyWithoutRelationsNestedInput
    UsersRelations?: UsersRelationsUpdateManyWithoutRelationsNestedInput
  }

  export type RelationsUncheckedUpdateWithoutRelationsQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    liId?: BigIntFieldUpdateOperationsInput | bigint | number
    gpId?: BigIntFieldUpdateOperationsInput | bigint | number
    qzId?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RelationsChoices?: RelationsChoicesUncheckedUpdateManyWithoutRelationsNestedInput
    UsersRelations?: UsersRelationsUncheckedUpdateManyWithoutRelationsNestedInput
  }

  export type RelationsChoicesUpsertWithWhereUniqueWithoutRelationsQuestionsInput = {
    where: RelationsChoicesWhereUniqueInput
    update: XOR<RelationsChoicesUpdateWithoutRelationsQuestionsInput, RelationsChoicesUncheckedUpdateWithoutRelationsQuestionsInput>
    create: XOR<RelationsChoicesCreateWithoutRelationsQuestionsInput, RelationsChoicesUncheckedCreateWithoutRelationsQuestionsInput>
  }

  export type RelationsChoicesUpdateWithWhereUniqueWithoutRelationsQuestionsInput = {
    where: RelationsChoicesWhereUniqueInput
    data: XOR<RelationsChoicesUpdateWithoutRelationsQuestionsInput, RelationsChoicesUncheckedUpdateWithoutRelationsQuestionsInput>
  }

  export type RelationsChoicesUpdateManyWithWhereWithoutRelationsQuestionsInput = {
    where: RelationsChoicesScalarWhereInput
    data: XOR<RelationsChoicesUpdateManyMutationInput, RelationsChoicesUncheckedUpdateManyWithoutRelationsQuestionsInput>
  }

  export type UsersRelationsDetailsUpsertWithWhereUniqueWithoutRelationsQuestionsInput = {
    where: UsersRelationsDetailsWhereUniqueInput
    update: XOR<UsersRelationsDetailsUpdateWithoutRelationsQuestionsInput, UsersRelationsDetailsUncheckedUpdateWithoutRelationsQuestionsInput>
    create: XOR<UsersRelationsDetailsCreateWithoutRelationsQuestionsInput, UsersRelationsDetailsUncheckedCreateWithoutRelationsQuestionsInput>
  }

  export type UsersRelationsDetailsUpdateWithWhereUniqueWithoutRelationsQuestionsInput = {
    where: UsersRelationsDetailsWhereUniqueInput
    data: XOR<UsersRelationsDetailsUpdateWithoutRelationsQuestionsInput, UsersRelationsDetailsUncheckedUpdateWithoutRelationsQuestionsInput>
  }

  export type UsersRelationsDetailsUpdateManyWithWhereWithoutRelationsQuestionsInput = {
    where: UsersRelationsDetailsScalarWhereInput
    data: XOR<UsersRelationsDetailsUpdateManyMutationInput, UsersRelationsDetailsUncheckedUpdateManyWithoutRelationsQuestionsInput>
  }

  export type LocationsCreateWithoutUsersInput = {
    id?: bigint | number
    location: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type LocationsUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    location: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type LocationsCreateOrConnectWithoutUsersInput = {
    where: LocationsWhereUniqueInput
    create: XOR<LocationsCreateWithoutUsersInput, LocationsUncheckedCreateWithoutUsersInput>
  }

  export type UsersAuthCreateWithoutUsersInput = {
    id?: bigint | number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Authorizations: AuthorizationsCreateNestedOneWithoutUsersAuthInput
  }

  export type UsersAuthUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    auId: bigint | number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type UsersAuthCreateOrConnectWithoutUsersInput = {
    where: UsersAuthWhereUniqueInput
    create: XOR<UsersAuthCreateWithoutUsersInput, UsersAuthUncheckedCreateWithoutUsersInput>
  }

  export type UsersAuthCreateManyUsersInputEnvelope = {
    data: UsersAuthCreateManyUsersInput | UsersAuthCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type UsersGroupsCreateWithoutUsersInput = {
    id?: bigint | number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Groups: GroupsCreateNestedOneWithoutUsersGroupsInput
  }

  export type UsersGroupsUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    gpId: bigint | number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type UsersGroupsCreateOrConnectWithoutUsersInput = {
    where: UsersGroupsWhereUniqueInput
    create: XOR<UsersGroupsCreateWithoutUsersInput, UsersGroupsUncheckedCreateWithoutUsersInput>
  }

  export type UsersGroupsCreateManyUsersInputEnvelope = {
    data: UsersGroupsCreateManyUsersInput | UsersGroupsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type UsersLoginCreateWithoutUsersInput = {
    id?: bigint | number
    action?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UsersLoginUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    action?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UsersLoginCreateOrConnectWithoutUsersInput = {
    where: UsersLoginWhereUniqueInput
    create: XOR<UsersLoginCreateWithoutUsersInput, UsersLoginUncheckedCreateWithoutUsersInput>
  }

  export type UsersLoginCreateManyUsersInputEnvelope = {
    data: UsersLoginCreateManyUsersInput | UsersLoginCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type UsersRelationsCreateWithoutUsersInput = {
    id?: bigint | number
    correct: number
    wrong: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Relations: RelationsCreateNestedOneWithoutUsersRelationsInput
    UsersRelationsDetails?: UsersRelationsDetailsCreateNestedManyWithoutUsersRelationsInput
  }

  export type UsersRelationsUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    reId: bigint | number
    correct: number
    wrong: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    UsersRelationsDetails?: UsersRelationsDetailsUncheckedCreateNestedManyWithoutUsersRelationsInput
  }

  export type UsersRelationsCreateOrConnectWithoutUsersInput = {
    where: UsersRelationsWhereUniqueInput
    create: XOR<UsersRelationsCreateWithoutUsersInput, UsersRelationsUncheckedCreateWithoutUsersInput>
  }

  export type UsersRelationsCreateManyUsersInputEnvelope = {
    data: UsersRelationsCreateManyUsersInput | UsersRelationsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type LocationsUpsertWithoutUsersInput = {
    update: XOR<LocationsUpdateWithoutUsersInput, LocationsUncheckedUpdateWithoutUsersInput>
    create: XOR<LocationsCreateWithoutUsersInput, LocationsUncheckedCreateWithoutUsersInput>
    where?: LocationsWhereInput
  }

  export type LocationsUpdateToOneWithWhereWithoutUsersInput = {
    where?: LocationsWhereInput
    data: XOR<LocationsUpdateWithoutUsersInput, LocationsUncheckedUpdateWithoutUsersInput>
  }

  export type LocationsUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LocationsUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersAuthUpsertWithWhereUniqueWithoutUsersInput = {
    where: UsersAuthWhereUniqueInput
    update: XOR<UsersAuthUpdateWithoutUsersInput, UsersAuthUncheckedUpdateWithoutUsersInput>
    create: XOR<UsersAuthCreateWithoutUsersInput, UsersAuthUncheckedCreateWithoutUsersInput>
  }

  export type UsersAuthUpdateWithWhereUniqueWithoutUsersInput = {
    where: UsersAuthWhereUniqueInput
    data: XOR<UsersAuthUpdateWithoutUsersInput, UsersAuthUncheckedUpdateWithoutUsersInput>
  }

  export type UsersAuthUpdateManyWithWhereWithoutUsersInput = {
    where: UsersAuthScalarWhereInput
    data: XOR<UsersAuthUpdateManyMutationInput, UsersAuthUncheckedUpdateManyWithoutUsersInput>
  }

  export type UsersGroupsUpsertWithWhereUniqueWithoutUsersInput = {
    where: UsersGroupsWhereUniqueInput
    update: XOR<UsersGroupsUpdateWithoutUsersInput, UsersGroupsUncheckedUpdateWithoutUsersInput>
    create: XOR<UsersGroupsCreateWithoutUsersInput, UsersGroupsUncheckedCreateWithoutUsersInput>
  }

  export type UsersGroupsUpdateWithWhereUniqueWithoutUsersInput = {
    where: UsersGroupsWhereUniqueInput
    data: XOR<UsersGroupsUpdateWithoutUsersInput, UsersGroupsUncheckedUpdateWithoutUsersInput>
  }

  export type UsersGroupsUpdateManyWithWhereWithoutUsersInput = {
    where: UsersGroupsScalarWhereInput
    data: XOR<UsersGroupsUpdateManyMutationInput, UsersGroupsUncheckedUpdateManyWithoutUsersInput>
  }

  export type UsersLoginUpsertWithWhereUniqueWithoutUsersInput = {
    where: UsersLoginWhereUniqueInput
    update: XOR<UsersLoginUpdateWithoutUsersInput, UsersLoginUncheckedUpdateWithoutUsersInput>
    create: XOR<UsersLoginCreateWithoutUsersInput, UsersLoginUncheckedCreateWithoutUsersInput>
  }

  export type UsersLoginUpdateWithWhereUniqueWithoutUsersInput = {
    where: UsersLoginWhereUniqueInput
    data: XOR<UsersLoginUpdateWithoutUsersInput, UsersLoginUncheckedUpdateWithoutUsersInput>
  }

  export type UsersLoginUpdateManyWithWhereWithoutUsersInput = {
    where: UsersLoginScalarWhereInput
    data: XOR<UsersLoginUpdateManyMutationInput, UsersLoginUncheckedUpdateManyWithoutUsersInput>
  }

  export type UsersLoginScalarWhereInput = {
    AND?: UsersLoginScalarWhereInput | UsersLoginScalarWhereInput[]
    OR?: UsersLoginScalarWhereInput[]
    NOT?: UsersLoginScalarWhereInput | UsersLoginScalarWhereInput[]
    id?: BigIntFilter<"UsersLogin"> | bigint | number
    usId?: BigIntFilter<"UsersLogin"> | bigint | number
    action?: BoolFilter<"UsersLogin"> | boolean
    createdAt?: DateTimeNullableFilter<"UsersLogin"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"UsersLogin"> | Date | string | null
  }

  export type UsersRelationsUpsertWithWhereUniqueWithoutUsersInput = {
    where: UsersRelationsWhereUniqueInput
    update: XOR<UsersRelationsUpdateWithoutUsersInput, UsersRelationsUncheckedUpdateWithoutUsersInput>
    create: XOR<UsersRelationsCreateWithoutUsersInput, UsersRelationsUncheckedCreateWithoutUsersInput>
  }

  export type UsersRelationsUpdateWithWhereUniqueWithoutUsersInput = {
    where: UsersRelationsWhereUniqueInput
    data: XOR<UsersRelationsUpdateWithoutUsersInput, UsersRelationsUncheckedUpdateWithoutUsersInput>
  }

  export type UsersRelationsUpdateManyWithWhereWithoutUsersInput = {
    where: UsersRelationsScalarWhereInput
    data: XOR<UsersRelationsUpdateManyMutationInput, UsersRelationsUncheckedUpdateManyWithoutUsersInput>
  }

  export type AuthorizationsCreateWithoutUsersAuthInput = {
    id?: bigint | number
    name: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AuthorizationsUncheckedCreateWithoutUsersAuthInput = {
    id?: bigint | number
    name: string
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type AuthorizationsCreateOrConnectWithoutUsersAuthInput = {
    where: AuthorizationsWhereUniqueInput
    create: XOR<AuthorizationsCreateWithoutUsersAuthInput, AuthorizationsUncheckedCreateWithoutUsersAuthInput>
  }

  export type UsersCreateWithoutUsersAuthInput = {
    id?: bigint | number
    personalNumber: string
    name: string
    email: string
    phone?: string | null
    admin?: boolean
    enabled?: boolean
    activationDate?: Date | string
    rememberToken?: string | null
    emailVerifiedAt?: Date | string | null
    password?: string | null
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Locations: LocationsCreateNestedOneWithoutUsersInput
    UsersGroups?: UsersGroupsCreateNestedManyWithoutUsersInput
    UsersLogin?: UsersLoginCreateNestedManyWithoutUsersInput
    UsersRelations?: UsersRelationsCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutUsersAuthInput = {
    id?: bigint | number
    personalNumber: string
    name: string
    email: string
    phone?: string | null
    location: bigint | number
    admin?: boolean
    enabled?: boolean
    activationDate?: Date | string
    rememberToken?: string | null
    emailVerifiedAt?: Date | string | null
    password?: string | null
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    UsersGroups?: UsersGroupsUncheckedCreateNestedManyWithoutUsersInput
    UsersLogin?: UsersLoginUncheckedCreateNestedManyWithoutUsersInput
    UsersRelations?: UsersRelationsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutUsersAuthInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUsersAuthInput, UsersUncheckedCreateWithoutUsersAuthInput>
  }

  export type AuthorizationsUpsertWithoutUsersAuthInput = {
    update: XOR<AuthorizationsUpdateWithoutUsersAuthInput, AuthorizationsUncheckedUpdateWithoutUsersAuthInput>
    create: XOR<AuthorizationsCreateWithoutUsersAuthInput, AuthorizationsUncheckedCreateWithoutUsersAuthInput>
    where?: AuthorizationsWhereInput
  }

  export type AuthorizationsUpdateToOneWithWhereWithoutUsersAuthInput = {
    where?: AuthorizationsWhereInput
    data: XOR<AuthorizationsUpdateWithoutUsersAuthInput, AuthorizationsUncheckedUpdateWithoutUsersAuthInput>
  }

  export type AuthorizationsUpdateWithoutUsersAuthInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuthorizationsUncheckedUpdateWithoutUsersAuthInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersUpsertWithoutUsersAuthInput = {
    update: XOR<UsersUpdateWithoutUsersAuthInput, UsersUncheckedUpdateWithoutUsersAuthInput>
    create: XOR<UsersCreateWithoutUsersAuthInput, UsersUncheckedCreateWithoutUsersAuthInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutUsersAuthInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutUsersAuthInput, UsersUncheckedUpdateWithoutUsersAuthInput>
  }

  export type UsersUpdateWithoutUsersAuthInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    personalNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    activationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Locations?: LocationsUpdateOneRequiredWithoutUsersNestedInput
    UsersGroups?: UsersGroupsUpdateManyWithoutUsersNestedInput
    UsersLogin?: UsersLoginUpdateManyWithoutUsersNestedInput
    UsersRelations?: UsersRelationsUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutUsersAuthInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    personalNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: BigIntFieldUpdateOperationsInput | bigint | number
    admin?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    activationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UsersGroups?: UsersGroupsUncheckedUpdateManyWithoutUsersNestedInput
    UsersLogin?: UsersLoginUncheckedUpdateManyWithoutUsersNestedInput
    UsersRelations?: UsersRelationsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type GroupsCreateWithoutUsersGroupsInput = {
    id?: bigint | number
    code: string
    level?: number
    randCount?: number
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Media?: MediaCreateNestedOneWithoutGroupsInput
    GroupsLang?: GroupsLangCreateNestedManyWithoutGroupsInput
    Relations?: RelationsCreateNestedManyWithoutGroupsInput
  }

  export type GroupsUncheckedCreateWithoutUsersGroupsInput = {
    id?: bigint | number
    code: string
    level?: number
    media?: bigint | number | null
    randCount?: number
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    GroupsLang?: GroupsLangUncheckedCreateNestedManyWithoutGroupsInput
    Relations?: RelationsUncheckedCreateNestedManyWithoutGroupsInput
  }

  export type GroupsCreateOrConnectWithoutUsersGroupsInput = {
    where: GroupsWhereUniqueInput
    create: XOR<GroupsCreateWithoutUsersGroupsInput, GroupsUncheckedCreateWithoutUsersGroupsInput>
  }

  export type UsersCreateWithoutUsersGroupsInput = {
    id?: bigint | number
    personalNumber: string
    name: string
    email: string
    phone?: string | null
    admin?: boolean
    enabled?: boolean
    activationDate?: Date | string
    rememberToken?: string | null
    emailVerifiedAt?: Date | string | null
    password?: string | null
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Locations: LocationsCreateNestedOneWithoutUsersInput
    UsersAuth?: UsersAuthCreateNestedManyWithoutUsersInput
    UsersLogin?: UsersLoginCreateNestedManyWithoutUsersInput
    UsersRelations?: UsersRelationsCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutUsersGroupsInput = {
    id?: bigint | number
    personalNumber: string
    name: string
    email: string
    phone?: string | null
    location: bigint | number
    admin?: boolean
    enabled?: boolean
    activationDate?: Date | string
    rememberToken?: string | null
    emailVerifiedAt?: Date | string | null
    password?: string | null
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    UsersAuth?: UsersAuthUncheckedCreateNestedManyWithoutUsersInput
    UsersLogin?: UsersLoginUncheckedCreateNestedManyWithoutUsersInput
    UsersRelations?: UsersRelationsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutUsersGroupsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUsersGroupsInput, UsersUncheckedCreateWithoutUsersGroupsInput>
  }

  export type GroupsUpsertWithoutUsersGroupsInput = {
    update: XOR<GroupsUpdateWithoutUsersGroupsInput, GroupsUncheckedUpdateWithoutUsersGroupsInput>
    create: XOR<GroupsCreateWithoutUsersGroupsInput, GroupsUncheckedCreateWithoutUsersGroupsInput>
    where?: GroupsWhereInput
  }

  export type GroupsUpdateToOneWithWhereWithoutUsersGroupsInput = {
    where?: GroupsWhereInput
    data: XOR<GroupsUpdateWithoutUsersGroupsInput, GroupsUncheckedUpdateWithoutUsersGroupsInput>
  }

  export type GroupsUpdateWithoutUsersGroupsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    randCount?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Media?: MediaUpdateOneWithoutGroupsNestedInput
    GroupsLang?: GroupsLangUpdateManyWithoutGroupsNestedInput
    Relations?: RelationsUpdateManyWithoutGroupsNestedInput
  }

  export type GroupsUncheckedUpdateWithoutUsersGroupsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    media?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    randCount?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GroupsLang?: GroupsLangUncheckedUpdateManyWithoutGroupsNestedInput
    Relations?: RelationsUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type UsersUpsertWithoutUsersGroupsInput = {
    update: XOR<UsersUpdateWithoutUsersGroupsInput, UsersUncheckedUpdateWithoutUsersGroupsInput>
    create: XOR<UsersCreateWithoutUsersGroupsInput, UsersUncheckedCreateWithoutUsersGroupsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutUsersGroupsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutUsersGroupsInput, UsersUncheckedUpdateWithoutUsersGroupsInput>
  }

  export type UsersUpdateWithoutUsersGroupsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    personalNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    activationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Locations?: LocationsUpdateOneRequiredWithoutUsersNestedInput
    UsersAuth?: UsersAuthUpdateManyWithoutUsersNestedInput
    UsersLogin?: UsersLoginUpdateManyWithoutUsersNestedInput
    UsersRelations?: UsersRelationsUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutUsersGroupsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    personalNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: BigIntFieldUpdateOperationsInput | bigint | number
    admin?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    activationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UsersAuth?: UsersAuthUncheckedUpdateManyWithoutUsersNestedInput
    UsersLogin?: UsersLoginUncheckedUpdateManyWithoutUsersNestedInput
    UsersRelations?: UsersRelationsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersCreateWithoutUsersLoginInput = {
    id?: bigint | number
    personalNumber: string
    name: string
    email: string
    phone?: string | null
    admin?: boolean
    enabled?: boolean
    activationDate?: Date | string
    rememberToken?: string | null
    emailVerifiedAt?: Date | string | null
    password?: string | null
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Locations: LocationsCreateNestedOneWithoutUsersInput
    UsersAuth?: UsersAuthCreateNestedManyWithoutUsersInput
    UsersGroups?: UsersGroupsCreateNestedManyWithoutUsersInput
    UsersRelations?: UsersRelationsCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutUsersLoginInput = {
    id?: bigint | number
    personalNumber: string
    name: string
    email: string
    phone?: string | null
    location: bigint | number
    admin?: boolean
    enabled?: boolean
    activationDate?: Date | string
    rememberToken?: string | null
    emailVerifiedAt?: Date | string | null
    password?: string | null
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    UsersAuth?: UsersAuthUncheckedCreateNestedManyWithoutUsersInput
    UsersGroups?: UsersGroupsUncheckedCreateNestedManyWithoutUsersInput
    UsersRelations?: UsersRelationsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutUsersLoginInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUsersLoginInput, UsersUncheckedCreateWithoutUsersLoginInput>
  }

  export type UsersUpsertWithoutUsersLoginInput = {
    update: XOR<UsersUpdateWithoutUsersLoginInput, UsersUncheckedUpdateWithoutUsersLoginInput>
    create: XOR<UsersCreateWithoutUsersLoginInput, UsersUncheckedCreateWithoutUsersLoginInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutUsersLoginInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutUsersLoginInput, UsersUncheckedUpdateWithoutUsersLoginInput>
  }

  export type UsersUpdateWithoutUsersLoginInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    personalNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    activationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Locations?: LocationsUpdateOneRequiredWithoutUsersNestedInput
    UsersAuth?: UsersAuthUpdateManyWithoutUsersNestedInput
    UsersGroups?: UsersGroupsUpdateManyWithoutUsersNestedInput
    UsersRelations?: UsersRelationsUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutUsersLoginInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    personalNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: BigIntFieldUpdateOperationsInput | bigint | number
    admin?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    activationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UsersAuth?: UsersAuthUncheckedUpdateManyWithoutUsersNestedInput
    UsersGroups?: UsersGroupsUncheckedUpdateManyWithoutUsersNestedInput
    UsersRelations?: UsersRelationsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type RelationsCreateWithoutUsersRelationsInput = {
    id?: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Licenses: LicensesCreateNestedOneWithoutRelationsInput
    Groups: GroupsCreateNestedOneWithoutRelationsInput
    Quizzes: QuizzesCreateNestedOneWithoutRelationsInput
    RelationsChoices?: RelationsChoicesCreateNestedManyWithoutRelationsInput
    RelationsQuestions?: RelationsQuestionsCreateNestedManyWithoutRelationsInput
  }

  export type RelationsUncheckedCreateWithoutUsersRelationsInput = {
    id?: bigint | number
    liId: bigint | number
    gpId: bigint | number
    qzId: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    RelationsChoices?: RelationsChoicesUncheckedCreateNestedManyWithoutRelationsInput
    RelationsQuestions?: RelationsQuestionsUncheckedCreateNestedManyWithoutRelationsInput
  }

  export type RelationsCreateOrConnectWithoutUsersRelationsInput = {
    where: RelationsWhereUniqueInput
    create: XOR<RelationsCreateWithoutUsersRelationsInput, RelationsUncheckedCreateWithoutUsersRelationsInput>
  }

  export type UsersCreateWithoutUsersRelationsInput = {
    id?: bigint | number
    personalNumber: string
    name: string
    email: string
    phone?: string | null
    admin?: boolean
    enabled?: boolean
    activationDate?: Date | string
    rememberToken?: string | null
    emailVerifiedAt?: Date | string | null
    password?: string | null
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Locations: LocationsCreateNestedOneWithoutUsersInput
    UsersAuth?: UsersAuthCreateNestedManyWithoutUsersInput
    UsersGroups?: UsersGroupsCreateNestedManyWithoutUsersInput
    UsersLogin?: UsersLoginCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutUsersRelationsInput = {
    id?: bigint | number
    personalNumber: string
    name: string
    email: string
    phone?: string | null
    location: bigint | number
    admin?: boolean
    enabled?: boolean
    activationDate?: Date | string
    rememberToken?: string | null
    emailVerifiedAt?: Date | string | null
    password?: string | null
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    UsersAuth?: UsersAuthUncheckedCreateNestedManyWithoutUsersInput
    UsersGroups?: UsersGroupsUncheckedCreateNestedManyWithoutUsersInput
    UsersLogin?: UsersLoginUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutUsersRelationsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutUsersRelationsInput, UsersUncheckedCreateWithoutUsersRelationsInput>
  }

  export type UsersRelationsDetailsCreateWithoutUsersRelationsInput = {
    id?: bigint | number
    observed?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    RelationsChoices: RelationsChoicesCreateNestedOneWithoutUsersRelationsDetailsInput
    RelationsQuestions: RelationsQuestionsCreateNestedOneWithoutUsersRelationsDetailsInput
  }

  export type UsersRelationsDetailsUncheckedCreateWithoutUsersRelationsInput = {
    id?: bigint | number
    rqId: bigint | number
    rcId: bigint | number
    observed?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UsersRelationsDetailsCreateOrConnectWithoutUsersRelationsInput = {
    where: UsersRelationsDetailsWhereUniqueInput
    create: XOR<UsersRelationsDetailsCreateWithoutUsersRelationsInput, UsersRelationsDetailsUncheckedCreateWithoutUsersRelationsInput>
  }

  export type UsersRelationsDetailsCreateManyUsersRelationsInputEnvelope = {
    data: UsersRelationsDetailsCreateManyUsersRelationsInput | UsersRelationsDetailsCreateManyUsersRelationsInput[]
    skipDuplicates?: boolean
  }

  export type RelationsUpsertWithoutUsersRelationsInput = {
    update: XOR<RelationsUpdateWithoutUsersRelationsInput, RelationsUncheckedUpdateWithoutUsersRelationsInput>
    create: XOR<RelationsCreateWithoutUsersRelationsInput, RelationsUncheckedCreateWithoutUsersRelationsInput>
    where?: RelationsWhereInput
  }

  export type RelationsUpdateToOneWithWhereWithoutUsersRelationsInput = {
    where?: RelationsWhereInput
    data: XOR<RelationsUpdateWithoutUsersRelationsInput, RelationsUncheckedUpdateWithoutUsersRelationsInput>
  }

  export type RelationsUpdateWithoutUsersRelationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Licenses?: LicensesUpdateOneRequiredWithoutRelationsNestedInput
    Groups?: GroupsUpdateOneRequiredWithoutRelationsNestedInput
    Quizzes?: QuizzesUpdateOneRequiredWithoutRelationsNestedInput
    RelationsChoices?: RelationsChoicesUpdateManyWithoutRelationsNestedInput
    RelationsQuestions?: RelationsQuestionsUpdateManyWithoutRelationsNestedInput
  }

  export type RelationsUncheckedUpdateWithoutUsersRelationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    liId?: BigIntFieldUpdateOperationsInput | bigint | number
    gpId?: BigIntFieldUpdateOperationsInput | bigint | number
    qzId?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RelationsChoices?: RelationsChoicesUncheckedUpdateManyWithoutRelationsNestedInput
    RelationsQuestions?: RelationsQuestionsUncheckedUpdateManyWithoutRelationsNestedInput
  }

  export type UsersUpsertWithoutUsersRelationsInput = {
    update: XOR<UsersUpdateWithoutUsersRelationsInput, UsersUncheckedUpdateWithoutUsersRelationsInput>
    create: XOR<UsersCreateWithoutUsersRelationsInput, UsersUncheckedCreateWithoutUsersRelationsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutUsersRelationsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutUsersRelationsInput, UsersUncheckedUpdateWithoutUsersRelationsInput>
  }

  export type UsersUpdateWithoutUsersRelationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    personalNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    activationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Locations?: LocationsUpdateOneRequiredWithoutUsersNestedInput
    UsersAuth?: UsersAuthUpdateManyWithoutUsersNestedInput
    UsersGroups?: UsersGroupsUpdateManyWithoutUsersNestedInput
    UsersLogin?: UsersLoginUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutUsersRelationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    personalNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    location?: BigIntFieldUpdateOperationsInput | bigint | number
    admin?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    activationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UsersAuth?: UsersAuthUncheckedUpdateManyWithoutUsersNestedInput
    UsersGroups?: UsersGroupsUncheckedUpdateManyWithoutUsersNestedInput
    UsersLogin?: UsersLoginUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersRelationsDetailsUpsertWithWhereUniqueWithoutUsersRelationsInput = {
    where: UsersRelationsDetailsWhereUniqueInput
    update: XOR<UsersRelationsDetailsUpdateWithoutUsersRelationsInput, UsersRelationsDetailsUncheckedUpdateWithoutUsersRelationsInput>
    create: XOR<UsersRelationsDetailsCreateWithoutUsersRelationsInput, UsersRelationsDetailsUncheckedCreateWithoutUsersRelationsInput>
  }

  export type UsersRelationsDetailsUpdateWithWhereUniqueWithoutUsersRelationsInput = {
    where: UsersRelationsDetailsWhereUniqueInput
    data: XOR<UsersRelationsDetailsUpdateWithoutUsersRelationsInput, UsersRelationsDetailsUncheckedUpdateWithoutUsersRelationsInput>
  }

  export type UsersRelationsDetailsUpdateManyWithWhereWithoutUsersRelationsInput = {
    where: UsersRelationsDetailsScalarWhereInput
    data: XOR<UsersRelationsDetailsUpdateManyMutationInput, UsersRelationsDetailsUncheckedUpdateManyWithoutUsersRelationsInput>
  }

  export type UsersRelationsCreateWithoutUsersRelationsDetailsInput = {
    id?: bigint | number
    correct: number
    wrong: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    Relations: RelationsCreateNestedOneWithoutUsersRelationsInput
    Users: UsersCreateNestedOneWithoutUsersRelationsInput
  }

  export type UsersRelationsUncheckedCreateWithoutUsersRelationsDetailsInput = {
    id?: bigint | number
    usId: bigint | number
    reId: bigint | number
    correct: number
    wrong: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UsersRelationsCreateOrConnectWithoutUsersRelationsDetailsInput = {
    where: UsersRelationsWhereUniqueInput
    create: XOR<UsersRelationsCreateWithoutUsersRelationsDetailsInput, UsersRelationsUncheckedCreateWithoutUsersRelationsDetailsInput>
  }

  export type RelationsChoicesCreateWithoutUsersRelationsDetailsInput = {
    id?: bigint | number
    correct?: boolean
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Choices: ChoicesCreateNestedOneWithoutRelationsChoicesInput
    Media?: MediaCreateNestedOneWithoutRelationsChoicesInput
    RelationsQuestions: RelationsQuestionsCreateNestedOneWithoutRelationsChoicesInput
    Relations?: RelationsCreateNestedOneWithoutRelationsChoicesInput
  }

  export type RelationsChoicesUncheckedCreateWithoutUsersRelationsDetailsInput = {
    id?: bigint | number
    rqId: bigint | number
    chId: bigint | number
    mdId?: bigint | number | null
    correct?: boolean
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    relationsId?: bigint | number | null
  }

  export type RelationsChoicesCreateOrConnectWithoutUsersRelationsDetailsInput = {
    where: RelationsChoicesWhereUniqueInput
    create: XOR<RelationsChoicesCreateWithoutUsersRelationsDetailsInput, RelationsChoicesUncheckedCreateWithoutUsersRelationsDetailsInput>
  }

  export type RelationsQuestionsCreateWithoutUsersRelationsDetailsInput = {
    id?: bigint | number
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    Questions: QuestionsCreateNestedOneWithoutRelationsQuestionsInput
    Media?: MediaCreateNestedOneWithoutRelationsQuestionsInput
    Relations: RelationsCreateNestedOneWithoutRelationsQuestionsInput
    RelationsChoices?: RelationsChoicesCreateNestedManyWithoutRelationsQuestionsInput
  }

  export type RelationsQuestionsUncheckedCreateWithoutUsersRelationsDetailsInput = {
    id?: bigint | number
    reId: bigint | number
    qsId: bigint | number
    mdId?: bigint | number | null
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    RelationsChoices?: RelationsChoicesUncheckedCreateNestedManyWithoutRelationsQuestionsInput
  }

  export type RelationsQuestionsCreateOrConnectWithoutUsersRelationsDetailsInput = {
    where: RelationsQuestionsWhereUniqueInput
    create: XOR<RelationsQuestionsCreateWithoutUsersRelationsDetailsInput, RelationsQuestionsUncheckedCreateWithoutUsersRelationsDetailsInput>
  }

  export type UsersRelationsUpsertWithoutUsersRelationsDetailsInput = {
    update: XOR<UsersRelationsUpdateWithoutUsersRelationsDetailsInput, UsersRelationsUncheckedUpdateWithoutUsersRelationsDetailsInput>
    create: XOR<UsersRelationsCreateWithoutUsersRelationsDetailsInput, UsersRelationsUncheckedCreateWithoutUsersRelationsDetailsInput>
    where?: UsersRelationsWhereInput
  }

  export type UsersRelationsUpdateToOneWithWhereWithoutUsersRelationsDetailsInput = {
    where?: UsersRelationsWhereInput
    data: XOR<UsersRelationsUpdateWithoutUsersRelationsDetailsInput, UsersRelationsUncheckedUpdateWithoutUsersRelationsDetailsInput>
  }

  export type UsersRelationsUpdateWithoutUsersRelationsDetailsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    correct?: IntFieldUpdateOperationsInput | number
    wrong?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Relations?: RelationsUpdateOneRequiredWithoutUsersRelationsNestedInput
    Users?: UsersUpdateOneRequiredWithoutUsersRelationsNestedInput
  }

  export type UsersRelationsUncheckedUpdateWithoutUsersRelationsDetailsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    usId?: BigIntFieldUpdateOperationsInput | bigint | number
    reId?: BigIntFieldUpdateOperationsInput | bigint | number
    correct?: IntFieldUpdateOperationsInput | number
    wrong?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelationsChoicesUpsertWithoutUsersRelationsDetailsInput = {
    update: XOR<RelationsChoicesUpdateWithoutUsersRelationsDetailsInput, RelationsChoicesUncheckedUpdateWithoutUsersRelationsDetailsInput>
    create: XOR<RelationsChoicesCreateWithoutUsersRelationsDetailsInput, RelationsChoicesUncheckedCreateWithoutUsersRelationsDetailsInput>
    where?: RelationsChoicesWhereInput
  }

  export type RelationsChoicesUpdateToOneWithWhereWithoutUsersRelationsDetailsInput = {
    where?: RelationsChoicesWhereInput
    data: XOR<RelationsChoicesUpdateWithoutUsersRelationsDetailsInput, RelationsChoicesUncheckedUpdateWithoutUsersRelationsDetailsInput>
  }

  export type RelationsChoicesUpdateWithoutUsersRelationsDetailsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    correct?: BoolFieldUpdateOperationsInput | boolean
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Choices?: ChoicesUpdateOneRequiredWithoutRelationsChoicesNestedInput
    Media?: MediaUpdateOneWithoutRelationsChoicesNestedInput
    RelationsQuestions?: RelationsQuestionsUpdateOneRequiredWithoutRelationsChoicesNestedInput
    Relations?: RelationsUpdateOneWithoutRelationsChoicesNestedInput
  }

  export type RelationsChoicesUncheckedUpdateWithoutUsersRelationsDetailsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rqId?: BigIntFieldUpdateOperationsInput | bigint | number
    chId?: BigIntFieldUpdateOperationsInput | bigint | number
    mdId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    correct?: BoolFieldUpdateOperationsInput | boolean
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    relationsId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type RelationsQuestionsUpsertWithoutUsersRelationsDetailsInput = {
    update: XOR<RelationsQuestionsUpdateWithoutUsersRelationsDetailsInput, RelationsQuestionsUncheckedUpdateWithoutUsersRelationsDetailsInput>
    create: XOR<RelationsQuestionsCreateWithoutUsersRelationsDetailsInput, RelationsQuestionsUncheckedCreateWithoutUsersRelationsDetailsInput>
    where?: RelationsQuestionsWhereInput
  }

  export type RelationsQuestionsUpdateToOneWithWhereWithoutUsersRelationsDetailsInput = {
    where?: RelationsQuestionsWhereInput
    data: XOR<RelationsQuestionsUpdateWithoutUsersRelationsDetailsInput, RelationsQuestionsUncheckedUpdateWithoutUsersRelationsDetailsInput>
  }

  export type RelationsQuestionsUpdateWithoutUsersRelationsDetailsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Questions?: QuestionsUpdateOneRequiredWithoutRelationsQuestionsNestedInput
    Media?: MediaUpdateOneWithoutRelationsQuestionsNestedInput
    Relations?: RelationsUpdateOneRequiredWithoutRelationsQuestionsNestedInput
    RelationsChoices?: RelationsChoicesUpdateManyWithoutRelationsQuestionsNestedInput
  }

  export type RelationsQuestionsUncheckedUpdateWithoutUsersRelationsDetailsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    reId?: BigIntFieldUpdateOperationsInput | bigint | number
    qsId?: BigIntFieldUpdateOperationsInput | bigint | number
    mdId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RelationsChoices?: RelationsChoicesUncheckedUpdateManyWithoutRelationsQuestionsNestedInput
  }

  export type UsersCreateWithoutLocationsInput = {
    id?: bigint | number
    personalNumber: string
    name: string
    email: string
    phone?: string | null
    admin?: boolean
    enabled?: boolean
    activationDate?: Date | string
    rememberToken?: string | null
    emailVerifiedAt?: Date | string | null
    password?: string | null
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    UsersAuth?: UsersAuthCreateNestedManyWithoutUsersInput
    UsersGroups?: UsersGroupsCreateNestedManyWithoutUsersInput
    UsersLogin?: UsersLoginCreateNestedManyWithoutUsersInput
    UsersRelations?: UsersRelationsCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutLocationsInput = {
    id?: bigint | number
    personalNumber: string
    name: string
    email: string
    phone?: string | null
    admin?: boolean
    enabled?: boolean
    activationDate?: Date | string
    rememberToken?: string | null
    emailVerifiedAt?: Date | string | null
    password?: string | null
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    UsersAuth?: UsersAuthUncheckedCreateNestedManyWithoutUsersInput
    UsersGroups?: UsersGroupsUncheckedCreateNestedManyWithoutUsersInput
    UsersLogin?: UsersLoginUncheckedCreateNestedManyWithoutUsersInput
    UsersRelations?: UsersRelationsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutLocationsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutLocationsInput, UsersUncheckedCreateWithoutLocationsInput>
  }

  export type UsersCreateManyLocationsInputEnvelope = {
    data: UsersCreateManyLocationsInput | UsersCreateManyLocationsInput[]
    skipDuplicates?: boolean
  }

  export type UsersUpsertWithWhereUniqueWithoutLocationsInput = {
    where: UsersWhereUniqueInput
    update: XOR<UsersUpdateWithoutLocationsInput, UsersUncheckedUpdateWithoutLocationsInput>
    create: XOR<UsersCreateWithoutLocationsInput, UsersUncheckedCreateWithoutLocationsInput>
  }

  export type UsersUpdateWithWhereUniqueWithoutLocationsInput = {
    where: UsersWhereUniqueInput
    data: XOR<UsersUpdateWithoutLocationsInput, UsersUncheckedUpdateWithoutLocationsInput>
  }

  export type UsersUpdateManyWithWhereWithoutLocationsInput = {
    where: UsersScalarWhereInput
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyWithoutLocationsInput>
  }

  export type UsersScalarWhereInput = {
    AND?: UsersScalarWhereInput | UsersScalarWhereInput[]
    OR?: UsersScalarWhereInput[]
    NOT?: UsersScalarWhereInput | UsersScalarWhereInput[]
    id?: BigIntFilter<"Users"> | bigint | number
    personalNumber?: StringFilter<"Users"> | string
    name?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    phone?: StringNullableFilter<"Users"> | string | null
    location?: BigIntFilter<"Users"> | bigint | number
    admin?: BoolFilter<"Users"> | boolean
    enabled?: BoolFilter<"Users"> | boolean
    activationDate?: DateTimeFilter<"Users"> | Date | string
    rememberToken?: StringNullableFilter<"Users"> | string | null
    emailVerifiedAt?: DateTimeNullableFilter<"Users"> | Date | string | null
    password?: StringNullableFilter<"Users"> | string | null
    twoFactorSecret?: StringNullableFilter<"Users"> | string | null
    twoFactorRecoveryCodes?: StringNullableFilter<"Users"> | string | null
    createdAt?: DateTimeNullableFilter<"Users"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Users"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Users"> | Date | string | null
  }

  export type ChoicesLangCreateManyAudioInput = {
    id?: bigint | number
    chId: bigint | number
    lang: bigint | number
    text: string
    hint?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type GroupsLangCreateManyAudioInput = {
    id?: bigint | number
    gpId: bigint | number
    lang: bigint | number
    name: string
    desc?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type LicensesLangCreateManyAudioInput = {
    id?: bigint | number
    liId: bigint | number
    lang: bigint | number
    name: string
    desc?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type QuizzesLangCreateManyAudioInput = {
    id?: bigint | number
    qzId: bigint | number
    lang: bigint | number
    name: string
    desc?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type QuestionsLangCreateManyAudioInput = {
    id?: bigint | number
    qsId: bigint | number
    lang: bigint | number
    text: string
    hint?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type ChoicesLangUpdateWithoutAudioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Choices?: ChoicesUpdateOneRequiredWithoutChoicesLangNestedInput
    Languages?: LanguagesUpdateOneRequiredWithoutChoicesLangNestedInput
  }

  export type ChoicesLangUncheckedUpdateWithoutAudioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chId?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChoicesLangUncheckedUpdateManyWithoutAudioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chId?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupsLangUpdateWithoutAudioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Groups?: GroupsUpdateOneRequiredWithoutGroupsLangNestedInput
    Languages?: LanguagesUpdateOneRequiredWithoutGroupsLangNestedInput
  }

  export type GroupsLangUncheckedUpdateWithoutAudioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gpId?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupsLangUncheckedUpdateManyWithoutAudioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gpId?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LicensesLangUpdateWithoutAudioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Licenses?: LicensesUpdateOneRequiredWithoutLicensesLangNestedInput
    Languages?: LanguagesUpdateOneRequiredWithoutLicensesLangNestedInput
  }

  export type LicensesLangUncheckedUpdateWithoutAudioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    liId?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LicensesLangUncheckedUpdateManyWithoutAudioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    liId?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizzesLangUpdateWithoutAudioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Quizzes?: QuizzesUpdateOneRequiredWithoutQuizzesLangNestedInput
    Languages?: LanguagesUpdateOneRequiredWithoutQuizzesLangNestedInput
  }

  export type QuizzesLangUncheckedUpdateWithoutAudioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    qzId?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizzesLangUncheckedUpdateManyWithoutAudioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    qzId?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuestionsLangUpdateWithoutAudioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Questions?: QuestionsUpdateOneRequiredWithoutQuestionsLangNestedInput
    Languages?: LanguagesUpdateOneRequiredWithoutQuestionsLangNestedInput
  }

  export type QuestionsLangUncheckedUpdateWithoutAudioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    qsId?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuestionsLangUncheckedUpdateManyWithoutAudioInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    qsId?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersAuthCreateManyAuthorizationsInput = {
    id?: bigint | number
    usId: bigint | number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type UsersAuthUpdateWithoutAuthorizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users?: UsersUpdateOneRequiredWithoutUsersAuthNestedInput
  }

  export type UsersAuthUncheckedUpdateWithoutAuthorizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    usId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersAuthUncheckedUpdateManyWithoutAuthorizationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    usId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChoicesLangCreateManyChoicesInput = {
    id?: bigint | number
    lang: bigint | number
    text: string
    hint?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type RelationsChoicesCreateManyChoicesInput = {
    id?: bigint | number
    rqId: bigint | number
    mdId?: bigint | number | null
    correct?: boolean
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    relationsId?: bigint | number | null
  }

  export type ChoicesLangUpdateWithoutChoicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Languages?: LanguagesUpdateOneRequiredWithoutChoicesLangNestedInput
    Audio?: AudioUpdateOneWithoutChoicesLangNestedInput
  }

  export type ChoicesLangUncheckedUpdateWithoutChoicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChoicesLangUncheckedUpdateManyWithoutChoicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelationsChoicesUpdateWithoutChoicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    correct?: BoolFieldUpdateOperationsInput | boolean
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Media?: MediaUpdateOneWithoutRelationsChoicesNestedInput
    RelationsQuestions?: RelationsQuestionsUpdateOneRequiredWithoutRelationsChoicesNestedInput
    Relations?: RelationsUpdateOneWithoutRelationsChoicesNestedInput
    UsersRelationsDetails?: UsersRelationsDetailsUpdateManyWithoutRelationsChoicesNestedInput
  }

  export type RelationsChoicesUncheckedUpdateWithoutChoicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rqId?: BigIntFieldUpdateOperationsInput | bigint | number
    mdId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    correct?: BoolFieldUpdateOperationsInput | boolean
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    relationsId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    UsersRelationsDetails?: UsersRelationsDetailsUncheckedUpdateManyWithoutRelationsChoicesNestedInput
  }

  export type RelationsChoicesUncheckedUpdateManyWithoutChoicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rqId?: BigIntFieldUpdateOperationsInput | bigint | number
    mdId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    correct?: BoolFieldUpdateOperationsInput | boolean
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    relationsId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type GroupsLangCreateManyGroupsInput = {
    id?: bigint | number
    lang: bigint | number
    name: string
    desc?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type RelationsCreateManyGroupsInput = {
    id?: bigint | number
    liId: bigint | number
    qzId: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type UsersGroupsCreateManyGroupsInput = {
    id?: bigint | number
    usId: bigint | number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type GroupsLangUpdateWithoutGroupsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Languages?: LanguagesUpdateOneRequiredWithoutGroupsLangNestedInput
    Audio?: AudioUpdateOneWithoutGroupsLangNestedInput
  }

  export type GroupsLangUncheckedUpdateWithoutGroupsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupsLangUncheckedUpdateManyWithoutGroupsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelationsUpdateWithoutGroupsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Licenses?: LicensesUpdateOneRequiredWithoutRelationsNestedInput
    Quizzes?: QuizzesUpdateOneRequiredWithoutRelationsNestedInput
    RelationsChoices?: RelationsChoicesUpdateManyWithoutRelationsNestedInput
    RelationsQuestions?: RelationsQuestionsUpdateManyWithoutRelationsNestedInput
    UsersRelations?: UsersRelationsUpdateManyWithoutRelationsNestedInput
  }

  export type RelationsUncheckedUpdateWithoutGroupsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    liId?: BigIntFieldUpdateOperationsInput | bigint | number
    qzId?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RelationsChoices?: RelationsChoicesUncheckedUpdateManyWithoutRelationsNestedInput
    RelationsQuestions?: RelationsQuestionsUncheckedUpdateManyWithoutRelationsNestedInput
    UsersRelations?: UsersRelationsUncheckedUpdateManyWithoutRelationsNestedInput
  }

  export type RelationsUncheckedUpdateManyWithoutGroupsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    liId?: BigIntFieldUpdateOperationsInput | bigint | number
    qzId?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersGroupsUpdateWithoutGroupsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users?: UsersUpdateOneRequiredWithoutUsersGroupsNestedInput
  }

  export type UsersGroupsUncheckedUpdateWithoutGroupsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    usId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersGroupsUncheckedUpdateManyWithoutGroupsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    usId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChoicesLangCreateManyLanguagesInput = {
    id?: bigint | number
    chId: bigint | number
    text: string
    hint?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type GroupsLangCreateManyLanguagesInput = {
    id?: bigint | number
    gpId: bigint | number
    name: string
    desc?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type LicensesLangCreateManyLanguagesInput = {
    id?: bigint | number
    liId: bigint | number
    name: string
    desc?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type QuestionsLangCreateManyLanguagesInput = {
    id?: bigint | number
    qsId: bigint | number
    text: string
    hint?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type QuizzesLangCreateManyLanguagesInput = {
    id?: bigint | number
    qzId: bigint | number
    name: string
    desc?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type ChoicesLangUpdateWithoutLanguagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Choices?: ChoicesUpdateOneRequiredWithoutChoicesLangNestedInput
    Audio?: AudioUpdateOneWithoutChoicesLangNestedInput
  }

  export type ChoicesLangUncheckedUpdateWithoutLanguagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chId?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChoicesLangUncheckedUpdateManyWithoutLanguagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chId?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupsLangUpdateWithoutLanguagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Groups?: GroupsUpdateOneRequiredWithoutGroupsLangNestedInput
    Audio?: AudioUpdateOneWithoutGroupsLangNestedInput
  }

  export type GroupsLangUncheckedUpdateWithoutLanguagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gpId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupsLangUncheckedUpdateManyWithoutLanguagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gpId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LicensesLangUpdateWithoutLanguagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Licenses?: LicensesUpdateOneRequiredWithoutLicensesLangNestedInput
    Audio?: AudioUpdateOneWithoutLicensesLangNestedInput
  }

  export type LicensesLangUncheckedUpdateWithoutLanguagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    liId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LicensesLangUncheckedUpdateManyWithoutLanguagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    liId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuestionsLangUpdateWithoutLanguagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Questions?: QuestionsUpdateOneRequiredWithoutQuestionsLangNestedInput
    Audio?: AudioUpdateOneWithoutQuestionsLangNestedInput
  }

  export type QuestionsLangUncheckedUpdateWithoutLanguagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    qsId?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuestionsLangUncheckedUpdateManyWithoutLanguagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    qsId?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizzesLangUpdateWithoutLanguagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Quizzes?: QuizzesUpdateOneRequiredWithoutQuizzesLangNestedInput
    Audio?: AudioUpdateOneWithoutQuizzesLangNestedInput
  }

  export type QuizzesLangUncheckedUpdateWithoutLanguagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    qzId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizzesLangUncheckedUpdateManyWithoutLanguagesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    qzId?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LicensesLangCreateManyLicensesInput = {
    id?: bigint | number
    lang: bigint | number
    name: string
    desc?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type RelationsCreateManyLicensesInput = {
    id?: bigint | number
    gpId: bigint | number
    qzId: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type LicensesLangUpdateWithoutLicensesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Languages?: LanguagesUpdateOneRequiredWithoutLicensesLangNestedInput
    Audio?: AudioUpdateOneWithoutLicensesLangNestedInput
  }

  export type LicensesLangUncheckedUpdateWithoutLicensesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LicensesLangUncheckedUpdateManyWithoutLicensesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelationsUpdateWithoutLicensesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Groups?: GroupsUpdateOneRequiredWithoutRelationsNestedInput
    Quizzes?: QuizzesUpdateOneRequiredWithoutRelationsNestedInput
    RelationsChoices?: RelationsChoicesUpdateManyWithoutRelationsNestedInput
    RelationsQuestions?: RelationsQuestionsUpdateManyWithoutRelationsNestedInput
    UsersRelations?: UsersRelationsUpdateManyWithoutRelationsNestedInput
  }

  export type RelationsUncheckedUpdateWithoutLicensesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gpId?: BigIntFieldUpdateOperationsInput | bigint | number
    qzId?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RelationsChoices?: RelationsChoicesUncheckedUpdateManyWithoutRelationsNestedInput
    RelationsQuestions?: RelationsQuestionsUncheckedUpdateManyWithoutRelationsNestedInput
    UsersRelations?: UsersRelationsUncheckedUpdateManyWithoutRelationsNestedInput
  }

  export type RelationsUncheckedUpdateManyWithoutLicensesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gpId?: BigIntFieldUpdateOperationsInput | bigint | number
    qzId?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GroupsCreateManyMediaInput = {
    id?: bigint | number
    code: string
    level?: number
    randCount?: number
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type LicensesCreateManyMediaInput = {
    id?: bigint | number
    code: string
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type RelationsChoicesCreateManyMediaInput = {
    id?: bigint | number
    rqId: bigint | number
    chId: bigint | number
    correct?: boolean
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    relationsId?: bigint | number | null
  }

  export type RelationsQuestionsCreateManyMediaInput = {
    id?: bigint | number
    reId: bigint | number
    qsId: bigint | number
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type QuizzesCreateManyMediaInput = {
    id?: bigint | number
    code: string
    duration?: number
    level?: number
    enabled?: boolean
    other?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type GroupsUpdateWithoutMediaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    randCount?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GroupsLang?: GroupsLangUpdateManyWithoutGroupsNestedInput
    Relations?: RelationsUpdateManyWithoutGroupsNestedInput
    UsersGroups?: UsersGroupsUpdateManyWithoutGroupsNestedInput
  }

  export type GroupsUncheckedUpdateWithoutMediaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    randCount?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    GroupsLang?: GroupsLangUncheckedUpdateManyWithoutGroupsNestedInput
    Relations?: RelationsUncheckedUpdateManyWithoutGroupsNestedInput
    UsersGroups?: UsersGroupsUncheckedUpdateManyWithoutGroupsNestedInput
  }

  export type GroupsUncheckedUpdateManyWithoutMediaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    randCount?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LicensesUpdateWithoutMediaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LicensesLang?: LicensesLangUpdateManyWithoutLicensesNestedInput
    Relations?: RelationsUpdateManyWithoutLicensesNestedInput
  }

  export type LicensesUncheckedUpdateWithoutMediaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LicensesLang?: LicensesLangUncheckedUpdateManyWithoutLicensesNestedInput
    Relations?: RelationsUncheckedUpdateManyWithoutLicensesNestedInput
  }

  export type LicensesUncheckedUpdateManyWithoutMediaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelationsChoicesUpdateWithoutMediaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    correct?: BoolFieldUpdateOperationsInput | boolean
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Choices?: ChoicesUpdateOneRequiredWithoutRelationsChoicesNestedInput
    RelationsQuestions?: RelationsQuestionsUpdateOneRequiredWithoutRelationsChoicesNestedInput
    Relations?: RelationsUpdateOneWithoutRelationsChoicesNestedInput
    UsersRelationsDetails?: UsersRelationsDetailsUpdateManyWithoutRelationsChoicesNestedInput
  }

  export type RelationsChoicesUncheckedUpdateWithoutMediaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rqId?: BigIntFieldUpdateOperationsInput | bigint | number
    chId?: BigIntFieldUpdateOperationsInput | bigint | number
    correct?: BoolFieldUpdateOperationsInput | boolean
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    relationsId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    UsersRelationsDetails?: UsersRelationsDetailsUncheckedUpdateManyWithoutRelationsChoicesNestedInput
  }

  export type RelationsChoicesUncheckedUpdateManyWithoutMediaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rqId?: BigIntFieldUpdateOperationsInput | bigint | number
    chId?: BigIntFieldUpdateOperationsInput | bigint | number
    correct?: BoolFieldUpdateOperationsInput | boolean
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    relationsId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type RelationsQuestionsUpdateWithoutMediaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Questions?: QuestionsUpdateOneRequiredWithoutRelationsQuestionsNestedInput
    Relations?: RelationsUpdateOneRequiredWithoutRelationsQuestionsNestedInput
    RelationsChoices?: RelationsChoicesUpdateManyWithoutRelationsQuestionsNestedInput
    UsersRelationsDetails?: UsersRelationsDetailsUpdateManyWithoutRelationsQuestionsNestedInput
  }

  export type RelationsQuestionsUncheckedUpdateWithoutMediaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    reId?: BigIntFieldUpdateOperationsInput | bigint | number
    qsId?: BigIntFieldUpdateOperationsInput | bigint | number
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RelationsChoices?: RelationsChoicesUncheckedUpdateManyWithoutRelationsQuestionsNestedInput
    UsersRelationsDetails?: UsersRelationsDetailsUncheckedUpdateManyWithoutRelationsQuestionsNestedInput
  }

  export type RelationsQuestionsUncheckedUpdateManyWithoutMediaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    reId?: BigIntFieldUpdateOperationsInput | bigint | number
    qsId?: BigIntFieldUpdateOperationsInput | bigint | number
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizzesUpdateWithoutMediaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    QuizzesLang?: QuizzesLangUpdateManyWithoutQuizzesNestedInput
    Relations?: RelationsUpdateManyWithoutQuizzesNestedInput
  }

  export type QuizzesUncheckedUpdateWithoutMediaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    QuizzesLang?: QuizzesLangUncheckedUpdateManyWithoutQuizzesNestedInput
    Relations?: RelationsUncheckedUpdateManyWithoutQuizzesNestedInput
  }

  export type QuizzesUncheckedUpdateManyWithoutMediaInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    code?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    other?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuestionsLangCreateManyQuestionsInput = {
    id?: bigint | number
    lang: bigint | number
    text: string
    hint?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type RelationsQuestionsCreateManyQuestionsInput = {
    id?: bigint | number
    reId: bigint | number
    mdId?: bigint | number | null
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type QuestionsLangUpdateWithoutQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Languages?: LanguagesUpdateOneRequiredWithoutQuestionsLangNestedInput
    Audio?: AudioUpdateOneWithoutQuestionsLangNestedInput
  }

  export type QuestionsLangUncheckedUpdateWithoutQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuestionsLangUncheckedUpdateManyWithoutQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    text?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelationsQuestionsUpdateWithoutQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Media?: MediaUpdateOneWithoutRelationsQuestionsNestedInput
    Relations?: RelationsUpdateOneRequiredWithoutRelationsQuestionsNestedInput
    RelationsChoices?: RelationsChoicesUpdateManyWithoutRelationsQuestionsNestedInput
    UsersRelationsDetails?: UsersRelationsDetailsUpdateManyWithoutRelationsQuestionsNestedInput
  }

  export type RelationsQuestionsUncheckedUpdateWithoutQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    reId?: BigIntFieldUpdateOperationsInput | bigint | number
    mdId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RelationsChoices?: RelationsChoicesUncheckedUpdateManyWithoutRelationsQuestionsNestedInput
    UsersRelationsDetails?: UsersRelationsDetailsUncheckedUpdateManyWithoutRelationsQuestionsNestedInput
  }

  export type RelationsQuestionsUncheckedUpdateManyWithoutQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    reId?: BigIntFieldUpdateOperationsInput | bigint | number
    mdId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizzesLangCreateManyQuizzesInput = {
    id?: bigint | number
    lang: bigint | number
    name: string
    desc?: string | null
    audio?: bigint | number | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type RelationsCreateManyQuizzesInput = {
    id?: bigint | number
    liId: bigint | number
    gpId: bigint | number
    enabled?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type QuizzesLangUpdateWithoutQuizzesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Languages?: LanguagesUpdateOneRequiredWithoutQuizzesLangNestedInput
    Audio?: AudioUpdateOneWithoutQuizzesLangNestedInput
  }

  export type QuizzesLangUncheckedUpdateWithoutQuizzesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizzesLangUncheckedUpdateManyWithoutQuizzesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    lang?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    audio?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelationsUpdateWithoutQuizzesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Licenses?: LicensesUpdateOneRequiredWithoutRelationsNestedInput
    Groups?: GroupsUpdateOneRequiredWithoutRelationsNestedInput
    RelationsChoices?: RelationsChoicesUpdateManyWithoutRelationsNestedInput
    RelationsQuestions?: RelationsQuestionsUpdateManyWithoutRelationsNestedInput
    UsersRelations?: UsersRelationsUpdateManyWithoutRelationsNestedInput
  }

  export type RelationsUncheckedUpdateWithoutQuizzesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    liId?: BigIntFieldUpdateOperationsInput | bigint | number
    gpId?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RelationsChoices?: RelationsChoicesUncheckedUpdateManyWithoutRelationsNestedInput
    RelationsQuestions?: RelationsQuestionsUncheckedUpdateManyWithoutRelationsNestedInput
    UsersRelations?: UsersRelationsUncheckedUpdateManyWithoutRelationsNestedInput
  }

  export type RelationsUncheckedUpdateManyWithoutQuizzesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    liId?: BigIntFieldUpdateOperationsInput | bigint | number
    gpId?: BigIntFieldUpdateOperationsInput | bigint | number
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelationsChoicesCreateManyRelationsInput = {
    id?: bigint | number
    rqId: bigint | number
    chId: bigint | number
    mdId?: bigint | number | null
    correct?: boolean
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type RelationsQuestionsCreateManyRelationsInput = {
    id?: bigint | number
    qsId: bigint | number
    mdId?: bigint | number | null
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type UsersRelationsCreateManyRelationsInput = {
    id?: bigint | number
    usId: bigint | number
    correct: number
    wrong: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelationsChoicesUpdateWithoutRelationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    correct?: BoolFieldUpdateOperationsInput | boolean
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Choices?: ChoicesUpdateOneRequiredWithoutRelationsChoicesNestedInput
    Media?: MediaUpdateOneWithoutRelationsChoicesNestedInput
    RelationsQuestions?: RelationsQuestionsUpdateOneRequiredWithoutRelationsChoicesNestedInput
    UsersRelationsDetails?: UsersRelationsDetailsUpdateManyWithoutRelationsChoicesNestedInput
  }

  export type RelationsChoicesUncheckedUpdateWithoutRelationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rqId?: BigIntFieldUpdateOperationsInput | bigint | number
    chId?: BigIntFieldUpdateOperationsInput | bigint | number
    mdId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    correct?: BoolFieldUpdateOperationsInput | boolean
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UsersRelationsDetails?: UsersRelationsDetailsUncheckedUpdateManyWithoutRelationsChoicesNestedInput
  }

  export type RelationsChoicesUncheckedUpdateManyWithoutRelationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rqId?: BigIntFieldUpdateOperationsInput | bigint | number
    chId?: BigIntFieldUpdateOperationsInput | bigint | number
    mdId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    correct?: BoolFieldUpdateOperationsInput | boolean
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelationsQuestionsUpdateWithoutRelationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Questions?: QuestionsUpdateOneRequiredWithoutRelationsQuestionsNestedInput
    Media?: MediaUpdateOneWithoutRelationsQuestionsNestedInput
    RelationsChoices?: RelationsChoicesUpdateManyWithoutRelationsQuestionsNestedInput
    UsersRelationsDetails?: UsersRelationsDetailsUpdateManyWithoutRelationsQuestionsNestedInput
  }

  export type RelationsQuestionsUncheckedUpdateWithoutRelationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    qsId?: BigIntFieldUpdateOperationsInput | bigint | number
    mdId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RelationsChoices?: RelationsChoicesUncheckedUpdateManyWithoutRelationsQuestionsNestedInput
    UsersRelationsDetails?: UsersRelationsDetailsUncheckedUpdateManyWithoutRelationsQuestionsNestedInput
  }

  export type RelationsQuestionsUncheckedUpdateManyWithoutRelationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    qsId?: BigIntFieldUpdateOperationsInput | bigint | number
    mdId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersRelationsUpdateWithoutRelationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    correct?: IntFieldUpdateOperationsInput | number
    wrong?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Users?: UsersUpdateOneRequiredWithoutUsersRelationsNestedInput
    UsersRelationsDetails?: UsersRelationsDetailsUpdateManyWithoutUsersRelationsNestedInput
  }

  export type UsersRelationsUncheckedUpdateWithoutRelationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    usId?: BigIntFieldUpdateOperationsInput | bigint | number
    correct?: IntFieldUpdateOperationsInput | number
    wrong?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UsersRelationsDetails?: UsersRelationsDetailsUncheckedUpdateManyWithoutUsersRelationsNestedInput
  }

  export type UsersRelationsUncheckedUpdateManyWithoutRelationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    usId?: BigIntFieldUpdateOperationsInput | bigint | number
    correct?: IntFieldUpdateOperationsInput | number
    wrong?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersRelationsDetailsCreateManyRelationsChoicesInput = {
    id?: bigint | number
    urId: bigint | number
    rqId: bigint | number
    observed?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UsersRelationsDetailsUpdateWithoutRelationsChoicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    observed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UsersRelations?: UsersRelationsUpdateOneRequiredWithoutUsersRelationsDetailsNestedInput
    RelationsQuestions?: RelationsQuestionsUpdateOneRequiredWithoutUsersRelationsDetailsNestedInput
  }

  export type UsersRelationsDetailsUncheckedUpdateWithoutRelationsChoicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    urId?: BigIntFieldUpdateOperationsInput | bigint | number
    rqId?: BigIntFieldUpdateOperationsInput | bigint | number
    observed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersRelationsDetailsUncheckedUpdateManyWithoutRelationsChoicesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    urId?: BigIntFieldUpdateOperationsInput | bigint | number
    rqId?: BigIntFieldUpdateOperationsInput | bigint | number
    observed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RelationsChoicesCreateManyRelationsQuestionsInput = {
    id?: bigint | number
    chId: bigint | number
    mdId?: bigint | number | null
    correct?: boolean
    ordering?: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
    relationsId?: bigint | number | null
  }

  export type UsersRelationsDetailsCreateManyRelationsQuestionsInput = {
    id?: bigint | number
    urId: bigint | number
    rcId: bigint | number
    observed?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type RelationsChoicesUpdateWithoutRelationsQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    correct?: BoolFieldUpdateOperationsInput | boolean
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Choices?: ChoicesUpdateOneRequiredWithoutRelationsChoicesNestedInput
    Media?: MediaUpdateOneWithoutRelationsChoicesNestedInput
    Relations?: RelationsUpdateOneWithoutRelationsChoicesNestedInput
    UsersRelationsDetails?: UsersRelationsDetailsUpdateManyWithoutRelationsChoicesNestedInput
  }

  export type RelationsChoicesUncheckedUpdateWithoutRelationsQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chId?: BigIntFieldUpdateOperationsInput | bigint | number
    mdId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    correct?: BoolFieldUpdateOperationsInput | boolean
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    relationsId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    UsersRelationsDetails?: UsersRelationsDetailsUncheckedUpdateManyWithoutRelationsChoicesNestedInput
  }

  export type RelationsChoicesUncheckedUpdateManyWithoutRelationsQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    chId?: BigIntFieldUpdateOperationsInput | bigint | number
    mdId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    correct?: BoolFieldUpdateOperationsInput | boolean
    ordering?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    relationsId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type UsersRelationsDetailsUpdateWithoutRelationsQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    observed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UsersRelations?: UsersRelationsUpdateOneRequiredWithoutUsersRelationsDetailsNestedInput
    RelationsChoices?: RelationsChoicesUpdateOneRequiredWithoutUsersRelationsDetailsNestedInput
  }

  export type UsersRelationsDetailsUncheckedUpdateWithoutRelationsQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    urId?: BigIntFieldUpdateOperationsInput | bigint | number
    rcId?: BigIntFieldUpdateOperationsInput | bigint | number
    observed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersRelationsDetailsUncheckedUpdateManyWithoutRelationsQuestionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    urId?: BigIntFieldUpdateOperationsInput | bigint | number
    rcId?: BigIntFieldUpdateOperationsInput | bigint | number
    observed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersAuthCreateManyUsersInput = {
    id?: bigint | number
    auId: bigint | number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type UsersGroupsCreateManyUsersInput = {
    id?: bigint | number
    gpId: bigint | number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type UsersLoginCreateManyUsersInput = {
    id?: bigint | number
    action?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UsersRelationsCreateManyUsersInput = {
    id?: bigint | number
    reId: bigint | number
    correct: number
    wrong: number
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UsersAuthUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Authorizations?: AuthorizationsUpdateOneRequiredWithoutUsersAuthNestedInput
  }

  export type UsersAuthUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    auId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersAuthUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    auId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersGroupsUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Groups?: GroupsUpdateOneRequiredWithoutUsersGroupsNestedInput
  }

  export type UsersGroupsUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gpId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersGroupsUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    gpId?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersLoginUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    action?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersLoginUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    action?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersLoginUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    action?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersRelationsUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    correct?: IntFieldUpdateOperationsInput | number
    wrong?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Relations?: RelationsUpdateOneRequiredWithoutUsersRelationsNestedInput
    UsersRelationsDetails?: UsersRelationsDetailsUpdateManyWithoutUsersRelationsNestedInput
  }

  export type UsersRelationsUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    reId?: BigIntFieldUpdateOperationsInput | bigint | number
    correct?: IntFieldUpdateOperationsInput | number
    wrong?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UsersRelationsDetails?: UsersRelationsDetailsUncheckedUpdateManyWithoutUsersRelationsNestedInput
  }

  export type UsersRelationsUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    reId?: BigIntFieldUpdateOperationsInput | bigint | number
    correct?: IntFieldUpdateOperationsInput | number
    wrong?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersRelationsDetailsCreateManyUsersRelationsInput = {
    id?: bigint | number
    rqId: bigint | number
    rcId: bigint | number
    observed?: boolean
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type UsersRelationsDetailsUpdateWithoutUsersRelationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    observed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RelationsChoices?: RelationsChoicesUpdateOneRequiredWithoutUsersRelationsDetailsNestedInput
    RelationsQuestions?: RelationsQuestionsUpdateOneRequiredWithoutUsersRelationsDetailsNestedInput
  }

  export type UsersRelationsDetailsUncheckedUpdateWithoutUsersRelationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rqId?: BigIntFieldUpdateOperationsInput | bigint | number
    rcId?: BigIntFieldUpdateOperationsInput | bigint | number
    observed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersRelationsDetailsUncheckedUpdateManyWithoutUsersRelationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rqId?: BigIntFieldUpdateOperationsInput | bigint | number
    rcId?: BigIntFieldUpdateOperationsInput | bigint | number
    observed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsersCreateManyLocationsInput = {
    id?: bigint | number
    personalNumber: string
    name: string
    email: string
    phone?: string | null
    admin?: boolean
    enabled?: boolean
    activationDate?: Date | string
    rememberToken?: string | null
    emailVerifiedAt?: Date | string | null
    password?: string | null
    twoFactorSecret?: string | null
    twoFactorRecoveryCodes?: string | null
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type UsersUpdateWithoutLocationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    personalNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    activationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UsersAuth?: UsersAuthUpdateManyWithoutUsersNestedInput
    UsersGroups?: UsersGroupsUpdateManyWithoutUsersNestedInput
    UsersLogin?: UsersLoginUpdateManyWithoutUsersNestedInput
    UsersRelations?: UsersRelationsUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutLocationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    personalNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    activationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UsersAuth?: UsersAuthUncheckedUpdateManyWithoutUsersNestedInput
    UsersGroups?: UsersGroupsUncheckedUpdateManyWithoutUsersNestedInput
    UsersLogin?: UsersLoginUncheckedUpdateManyWithoutUsersNestedInput
    UsersRelations?: UsersRelationsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateManyWithoutLocationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    personalNumber?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    admin?: BoolFieldUpdateOperationsInput | boolean
    enabled?: BoolFieldUpdateOperationsInput | boolean
    activationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rememberToken?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    twoFactorRecoveryCodes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use AudioCountOutputTypeDefaultArgs instead
     */
    export type AudioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AudioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuthorizationsCountOutputTypeDefaultArgs instead
     */
    export type AuthorizationsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuthorizationsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChoicesCountOutputTypeDefaultArgs instead
     */
    export type ChoicesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChoicesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupsCountOutputTypeDefaultArgs instead
     */
    export type GroupsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LanguagesCountOutputTypeDefaultArgs instead
     */
    export type LanguagesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LanguagesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LicensesCountOutputTypeDefaultArgs instead
     */
    export type LicensesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LicensesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaCountOutputTypeDefaultArgs instead
     */
    export type MediaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionsCountOutputTypeDefaultArgs instead
     */
    export type QuestionsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuizzesCountOutputTypeDefaultArgs instead
     */
    export type QuizzesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuizzesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RelationsCountOutputTypeDefaultArgs instead
     */
    export type RelationsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RelationsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RelationsChoicesCountOutputTypeDefaultArgs instead
     */
    export type RelationsChoicesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RelationsChoicesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RelationsQuestionsCountOutputTypeDefaultArgs instead
     */
    export type RelationsQuestionsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RelationsQuestionsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersCountOutputTypeDefaultArgs instead
     */
    export type UsersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersRelationsCountOutputTypeDefaultArgs instead
     */
    export type UsersRelationsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersRelationsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationsCountOutputTypeDefaultArgs instead
     */
    export type LocationsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AudioDefaultArgs instead
     */
    export type AudioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AudioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuthorizationsDefaultArgs instead
     */
    export type AuthorizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuthorizationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChoicesDefaultArgs instead
     */
    export type ChoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChoicesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChoicesLangDefaultArgs instead
     */
    export type ChoicesLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChoicesLangDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FailedJobsDefaultArgs instead
     */
    export type FailedJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FailedJobsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupsDefaultArgs instead
     */
    export type GroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GroupsLangDefaultArgs instead
     */
    export type GroupsLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GroupsLangDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LanguagesDefaultArgs instead
     */
    export type LanguagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LanguagesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LicensesDefaultArgs instead
     */
    export type LicensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LicensesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LicensesLangDefaultArgs instead
     */
    export type LicensesLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LicensesLangDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MediaDefaultArgs instead
     */
    export type MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MediaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MigrationsDefaultArgs instead
     */
    export type MigrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MigrationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PasswordResetsDefaultArgs instead
     */
    export type PasswordResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PasswordResetsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionsDefaultArgs instead
     */
    export type QuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionsLangDefaultArgs instead
     */
    export type QuestionsLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionsLangDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuizzesDefaultArgs instead
     */
    export type QuizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuizzesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuizzesLangDefaultArgs instead
     */
    export type QuizzesLangArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuizzesLangDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RelationsDefaultArgs instead
     */
    export type RelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RelationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RelationsChoicesDefaultArgs instead
     */
    export type RelationsChoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RelationsChoicesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RelationsQuestionsDefaultArgs instead
     */
    export type RelationsQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RelationsQuestionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersDefaultArgs instead
     */
    export type UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersAuthDefaultArgs instead
     */
    export type UsersAuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersAuthDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersGroupsDefaultArgs instead
     */
    export type UsersGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersGroupsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersLoginDefaultArgs instead
     */
    export type UsersLoginArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersLoginDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersRelationsDefaultArgs instead
     */
    export type UsersRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersRelationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersRelationsDetailsDefaultArgs instead
     */
    export type UsersRelationsDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersRelationsDetailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LocationsDefaultArgs instead
     */
    export type LocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LocationsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}